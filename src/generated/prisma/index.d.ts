
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ColorLookup
 * 
 */
export type ColorLookup = $Result.DefaultSelection<Prisma.$ColorLookupPayload>
/**
 * Model DeviceEntry
 * 
 */
export type DeviceEntry = $Result.DefaultSelection<Prisma.$DeviceEntryPayload>
/**
 * Model DeviceGroupEntry
 * 
 */
export type DeviceGroupEntry = $Result.DefaultSelection<Prisma.$DeviceGroupEntryPayload>
/**
 * Model DeviceGroupMapDevice
 * 
 */
export type DeviceGroupMapDevice = $Result.DefaultSelection<Prisma.$DeviceGroupMapDevicePayload>
/**
 * Model DeviceGroupMapDeviceGroup
 * 
 */
export type DeviceGroupMapDeviceGroup = $Result.DefaultSelection<Prisma.$DeviceGroupMapDeviceGroupPayload>
/**
 * Model DeviceImageColors
 * 
 */
export type DeviceImageColors = $Result.DefaultSelection<Prisma.$DeviceImageColorsPayload>
/**
 * Model DeviceLookupArchitecture
 * 
 */
export type DeviceLookupArchitecture = $Result.DefaultSelection<Prisma.$DeviceLookupArchitecturePayload>
/**
 * Model DeviceLookupCategory
 * 
 */
export type DeviceLookupCategory = $Result.DefaultSelection<Prisma.$DeviceLookupCategoryPayload>
/**
 * Model DeviceLookupImage
 * 
 */
export type DeviceLookupImage = $Result.DefaultSelection<Prisma.$DeviceLookupImagePayload>
/**
 * Model DeviceLookupSoc
 * 
 */
export type DeviceLookupSoc = $Result.DefaultSelection<Prisma.$DeviceLookupSocPayload>
/**
 * Model DeviceMapArchitecture
 * 
 */
export type DeviceMapArchitecture = $Result.DefaultSelection<Prisma.$DeviceMapArchitecturePayload>
/**
 * Model DeviceMapIdentifier
 * 
 */
export type DeviceMapIdentifier = $Result.DefaultSelection<Prisma.$DeviceMapIdentifierPayload>
/**
 * Model DeviceMapModel
 * 
 */
export type DeviceMapModel = $Result.DefaultSelection<Prisma.$DeviceMapModelPayload>
/**
 * Model DeviceMapRelease
 * 
 */
export type DeviceMapRelease = $Result.DefaultSelection<Prisma.$DeviceMapReleasePayload>
/**
 * Model DeviceMapSoc
 * 
 */
export type DeviceMapSoc = $Result.DefaultSelection<Prisma.$DeviceMapSocPayload>
/**
 * Model MapDeviceOs
 * 
 */
export type MapDeviceOs = $Result.DefaultSelection<Prisma.$MapDeviceOsPayload>
/**
 * Model OsEntry
 * 
 */
export type OsEntry = $Result.DefaultSelection<Prisma.$OsEntryPayload>
/**
 * Model OsEntryBuildTrain
 * 
 */
export type OsEntryBuildTrain = $Result.DefaultSelection<Prisma.$OsEntryBuildTrainPayload>
/**
 * Model OsEntryIpd
 * 
 */
export type OsEntryIpd = $Result.DefaultSelection<Prisma.$OsEntryIpdPayload>
/**
 * Model OsEntryOsStringMap
 * 
 */
export type OsEntryOsStringMap = $Result.DefaultSelection<Prisma.$OsEntryOsStringMapPayload>
/**
 * Model OsEntryPreinstalled
 * 
 */
export type OsEntryPreinstalled = $Result.DefaultSelection<Prisma.$OsEntryPreinstalledPayload>
/**
 * Model OsEntryReleaseNote
 * 
 */
export type OsEntryReleaseNote = $Result.DefaultSelection<Prisma.$OsEntryReleaseNotePayload>
/**
 * Model OsEntrySafariVersion
 * 
 */
export type OsEntrySafariVersion = $Result.DefaultSelection<Prisma.$OsEntrySafariVersionPayload>
/**
 * Model OsEntrySecurityNote
 * 
 */
export type OsEntrySecurityNote = $Result.DefaultSelection<Prisma.$OsEntrySecurityNotePayload>
/**
 * Model OsLookupName
 * 
 */
export type OsLookupName = $Result.DefaultSelection<Prisma.$OsLookupNamePayload>
/**
 * Model SourceEntry
 * 
 */
export type SourceEntry = $Result.DefaultSelection<Prisma.$SourceEntryPayload>
/**
 * Model SourceHash
 * 
 */
export type SourceHash = $Result.DefaultSelection<Prisma.$SourceHashPayload>
/**
 * Model SourceLink
 * 
 */
export type SourceLink = $Result.DefaultSelection<Prisma.$SourceLinkPayload>
/**
 * Model SourceMapDevice
 * 
 */
export type SourceMapDevice = $Result.DefaultSelection<Prisma.$SourceMapDevicePayload>
/**
 * Model SourceMapOsString
 * 
 */
export type SourceMapOsString = $Result.DefaultSelection<Prisma.$SourceMapOsStringPayload>
/**
 * Model SourcePrequisiteBuild
 * 
 */
export type SourcePrequisiteBuild = $Result.DefaultSelection<Prisma.$SourcePrequisiteBuildPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ColorLookups
 * const colorLookups = await prisma.colorLookup.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ColorLookups
   * const colorLookups = await prisma.colorLookup.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.colorLookup`: Exposes CRUD operations for the **ColorLookup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ColorLookups
    * const colorLookups = await prisma.colorLookup.findMany()
    * ```
    */
  get colorLookup(): Prisma.ColorLookupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceEntry`: Exposes CRUD operations for the **DeviceEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceEntries
    * const deviceEntries = await prisma.deviceEntry.findMany()
    * ```
    */
  get deviceEntry(): Prisma.DeviceEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceGroupEntry`: Exposes CRUD operations for the **DeviceGroupEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceGroupEntries
    * const deviceGroupEntries = await prisma.deviceGroupEntry.findMany()
    * ```
    */
  get deviceGroupEntry(): Prisma.DeviceGroupEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceGroupMapDevice`: Exposes CRUD operations for the **DeviceGroupMapDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceGroupMapDevices
    * const deviceGroupMapDevices = await prisma.deviceGroupMapDevice.findMany()
    * ```
    */
  get deviceGroupMapDevice(): Prisma.DeviceGroupMapDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceGroupMapDeviceGroup`: Exposes CRUD operations for the **DeviceGroupMapDeviceGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceGroupMapDeviceGroups
    * const deviceGroupMapDeviceGroups = await prisma.deviceGroupMapDeviceGroup.findMany()
    * ```
    */
  get deviceGroupMapDeviceGroup(): Prisma.DeviceGroupMapDeviceGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceImageColors`: Exposes CRUD operations for the **DeviceImageColors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceImageColors
    * const deviceImageColors = await prisma.deviceImageColors.findMany()
    * ```
    */
  get deviceImageColors(): Prisma.DeviceImageColorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceLookupArchitecture`: Exposes CRUD operations for the **DeviceLookupArchitecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceLookupArchitectures
    * const deviceLookupArchitectures = await prisma.deviceLookupArchitecture.findMany()
    * ```
    */
  get deviceLookupArchitecture(): Prisma.DeviceLookupArchitectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceLookupCategory`: Exposes CRUD operations for the **DeviceLookupCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceLookupCategories
    * const deviceLookupCategories = await prisma.deviceLookupCategory.findMany()
    * ```
    */
  get deviceLookupCategory(): Prisma.DeviceLookupCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceLookupImage`: Exposes CRUD operations for the **DeviceLookupImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceLookupImages
    * const deviceLookupImages = await prisma.deviceLookupImage.findMany()
    * ```
    */
  get deviceLookupImage(): Prisma.DeviceLookupImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceLookupSoc`: Exposes CRUD operations for the **DeviceLookupSoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceLookupSocs
    * const deviceLookupSocs = await prisma.deviceLookupSoc.findMany()
    * ```
    */
  get deviceLookupSoc(): Prisma.DeviceLookupSocDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceMapArchitecture`: Exposes CRUD operations for the **DeviceMapArchitecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceMapArchitectures
    * const deviceMapArchitectures = await prisma.deviceMapArchitecture.findMany()
    * ```
    */
  get deviceMapArchitecture(): Prisma.DeviceMapArchitectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceMapIdentifier`: Exposes CRUD operations for the **DeviceMapIdentifier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceMapIdentifiers
    * const deviceMapIdentifiers = await prisma.deviceMapIdentifier.findMany()
    * ```
    */
  get deviceMapIdentifier(): Prisma.DeviceMapIdentifierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceMapModel`: Exposes CRUD operations for the **DeviceMapModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceMapModels
    * const deviceMapModels = await prisma.deviceMapModel.findMany()
    * ```
    */
  get deviceMapModel(): Prisma.DeviceMapModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceMapRelease`: Exposes CRUD operations for the **DeviceMapRelease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceMapReleases
    * const deviceMapReleases = await prisma.deviceMapRelease.findMany()
    * ```
    */
  get deviceMapRelease(): Prisma.DeviceMapReleaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceMapSoc`: Exposes CRUD operations for the **DeviceMapSoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceMapSocs
    * const deviceMapSocs = await prisma.deviceMapSoc.findMany()
    * ```
    */
  get deviceMapSoc(): Prisma.DeviceMapSocDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapDeviceOs`: Exposes CRUD operations for the **MapDeviceOs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapDeviceOs
    * const mapDeviceOs = await prisma.mapDeviceOs.findMany()
    * ```
    */
  get mapDeviceOs(): Prisma.MapDeviceOsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntry`: Exposes CRUD operations for the **OsEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntries
    * const osEntries = await prisma.osEntry.findMany()
    * ```
    */
  get osEntry(): Prisma.OsEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntryBuildTrain`: Exposes CRUD operations for the **OsEntryBuildTrain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntryBuildTrains
    * const osEntryBuildTrains = await prisma.osEntryBuildTrain.findMany()
    * ```
    */
  get osEntryBuildTrain(): Prisma.OsEntryBuildTrainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntryIpd`: Exposes CRUD operations for the **OsEntryIpd** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntryIpds
    * const osEntryIpds = await prisma.osEntryIpd.findMany()
    * ```
    */
  get osEntryIpd(): Prisma.OsEntryIpdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntryOsStringMap`: Exposes CRUD operations for the **OsEntryOsStringMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntryOsStringMaps
    * const osEntryOsStringMaps = await prisma.osEntryOsStringMap.findMany()
    * ```
    */
  get osEntryOsStringMap(): Prisma.OsEntryOsStringMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntryPreinstalled`: Exposes CRUD operations for the **OsEntryPreinstalled** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntryPreinstalleds
    * const osEntryPreinstalleds = await prisma.osEntryPreinstalled.findMany()
    * ```
    */
  get osEntryPreinstalled(): Prisma.OsEntryPreinstalledDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntryReleaseNote`: Exposes CRUD operations for the **OsEntryReleaseNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntryReleaseNotes
    * const osEntryReleaseNotes = await prisma.osEntryReleaseNote.findMany()
    * ```
    */
  get osEntryReleaseNote(): Prisma.OsEntryReleaseNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntrySafariVersion`: Exposes CRUD operations for the **OsEntrySafariVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntrySafariVersions
    * const osEntrySafariVersions = await prisma.osEntrySafariVersion.findMany()
    * ```
    */
  get osEntrySafariVersion(): Prisma.OsEntrySafariVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osEntrySecurityNote`: Exposes CRUD operations for the **OsEntrySecurityNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsEntrySecurityNotes
    * const osEntrySecurityNotes = await prisma.osEntrySecurityNote.findMany()
    * ```
    */
  get osEntrySecurityNote(): Prisma.OsEntrySecurityNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.osLookupName`: Exposes CRUD operations for the **OsLookupName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OsLookupNames
    * const osLookupNames = await prisma.osLookupName.findMany()
    * ```
    */
  get osLookupName(): Prisma.OsLookupNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceEntry`: Exposes CRUD operations for the **SourceEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceEntries
    * const sourceEntries = await prisma.sourceEntry.findMany()
    * ```
    */
  get sourceEntry(): Prisma.SourceEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceHash`: Exposes CRUD operations for the **SourceHash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceHashes
    * const sourceHashes = await prisma.sourceHash.findMany()
    * ```
    */
  get sourceHash(): Prisma.SourceHashDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceLink`: Exposes CRUD operations for the **SourceLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceLinks
    * const sourceLinks = await prisma.sourceLink.findMany()
    * ```
    */
  get sourceLink(): Prisma.SourceLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceMapDevice`: Exposes CRUD operations for the **SourceMapDevice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceMapDevices
    * const sourceMapDevices = await prisma.sourceMapDevice.findMany()
    * ```
    */
  get sourceMapDevice(): Prisma.SourceMapDeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceMapOsString`: Exposes CRUD operations for the **SourceMapOsString** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceMapOsStrings
    * const sourceMapOsStrings = await prisma.sourceMapOsString.findMany()
    * ```
    */
  get sourceMapOsString(): Prisma.SourceMapOsStringDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourcePrequisiteBuild`: Exposes CRUD operations for the **SourcePrequisiteBuild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourcePrequisiteBuilds
    * const sourcePrequisiteBuilds = await prisma.sourcePrequisiteBuild.findMany()
    * ```
    */
  get sourcePrequisiteBuild(): Prisma.SourcePrequisiteBuildDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ColorLookup: 'ColorLookup',
    DeviceEntry: 'DeviceEntry',
    DeviceGroupEntry: 'DeviceGroupEntry',
    DeviceGroupMapDevice: 'DeviceGroupMapDevice',
    DeviceGroupMapDeviceGroup: 'DeviceGroupMapDeviceGroup',
    DeviceImageColors: 'DeviceImageColors',
    DeviceLookupArchitecture: 'DeviceLookupArchitecture',
    DeviceLookupCategory: 'DeviceLookupCategory',
    DeviceLookupImage: 'DeviceLookupImage',
    DeviceLookupSoc: 'DeviceLookupSoc',
    DeviceMapArchitecture: 'DeviceMapArchitecture',
    DeviceMapIdentifier: 'DeviceMapIdentifier',
    DeviceMapModel: 'DeviceMapModel',
    DeviceMapRelease: 'DeviceMapRelease',
    DeviceMapSoc: 'DeviceMapSoc',
    MapDeviceOs: 'MapDeviceOs',
    OsEntry: 'OsEntry',
    OsEntryBuildTrain: 'OsEntryBuildTrain',
    OsEntryIpd: 'OsEntryIpd',
    OsEntryOsStringMap: 'OsEntryOsStringMap',
    OsEntryPreinstalled: 'OsEntryPreinstalled',
    OsEntryReleaseNote: 'OsEntryReleaseNote',
    OsEntrySafariVersion: 'OsEntrySafariVersion',
    OsEntrySecurityNote: 'OsEntrySecurityNote',
    OsLookupName: 'OsLookupName',
    SourceEntry: 'SourceEntry',
    SourceHash: 'SourceHash',
    SourceLink: 'SourceLink',
    SourceMapDevice: 'SourceMapDevice',
    SourceMapOsString: 'SourceMapOsString',
    SourcePrequisiteBuild: 'SourcePrequisiteBuild'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "colorLookup" | "deviceEntry" | "deviceGroupEntry" | "deviceGroupMapDevice" | "deviceGroupMapDeviceGroup" | "deviceImageColors" | "deviceLookupArchitecture" | "deviceLookupCategory" | "deviceLookupImage" | "deviceLookupSoc" | "deviceMapArchitecture" | "deviceMapIdentifier" | "deviceMapModel" | "deviceMapRelease" | "deviceMapSoc" | "mapDeviceOs" | "osEntry" | "osEntryBuildTrain" | "osEntryIpd" | "osEntryOsStringMap" | "osEntryPreinstalled" | "osEntryReleaseNote" | "osEntrySafariVersion" | "osEntrySecurityNote" | "osLookupName" | "sourceEntry" | "sourceHash" | "sourceLink" | "sourceMapDevice" | "sourceMapOsString" | "sourcePrequisiteBuild"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ColorLookup: {
        payload: Prisma.$ColorLookupPayload<ExtArgs>
        fields: Prisma.ColorLookupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorLookupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorLookupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          findFirst: {
            args: Prisma.ColorLookupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorLookupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          findMany: {
            args: Prisma.ColorLookupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>[]
          }
          create: {
            args: Prisma.ColorLookupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          createMany: {
            args: Prisma.ColorLookupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColorLookupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>[]
          }
          delete: {
            args: Prisma.ColorLookupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          update: {
            args: Prisma.ColorLookupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          deleteMany: {
            args: Prisma.ColorLookupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColorLookupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColorLookupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>[]
          }
          upsert: {
            args: Prisma.ColorLookupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorLookupPayload>
          }
          aggregate: {
            args: Prisma.ColorLookupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColorLookup>
          }
          groupBy: {
            args: Prisma.ColorLookupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColorLookupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorLookupCountArgs<ExtArgs>
            result: $Utils.Optional<ColorLookupCountAggregateOutputType> | number
          }
        }
      }
      DeviceEntry: {
        payload: Prisma.$DeviceEntryPayload<ExtArgs>
        fields: Prisma.DeviceEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          findFirst: {
            args: Prisma.DeviceEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          findMany: {
            args: Prisma.DeviceEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>[]
          }
          create: {
            args: Prisma.DeviceEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          createMany: {
            args: Prisma.DeviceEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>[]
          }
          delete: {
            args: Prisma.DeviceEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          update: {
            args: Prisma.DeviceEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          deleteMany: {
            args: Prisma.DeviceEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>[]
          }
          upsert: {
            args: Prisma.DeviceEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceEntryPayload>
          }
          aggregate: {
            args: Prisma.DeviceEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceEntry>
          }
          groupBy: {
            args: Prisma.DeviceEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceEntryCountAggregateOutputType> | number
          }
        }
      }
      DeviceGroupEntry: {
        payload: Prisma.$DeviceGroupEntryPayload<ExtArgs>
        fields: Prisma.DeviceGroupEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceGroupEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceGroupEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          findFirst: {
            args: Prisma.DeviceGroupEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceGroupEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          findMany: {
            args: Prisma.DeviceGroupEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>[]
          }
          create: {
            args: Prisma.DeviceGroupEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          createMany: {
            args: Prisma.DeviceGroupEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceGroupEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>[]
          }
          delete: {
            args: Prisma.DeviceGroupEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          update: {
            args: Prisma.DeviceGroupEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          deleteMany: {
            args: Prisma.DeviceGroupEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceGroupEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceGroupEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>[]
          }
          upsert: {
            args: Prisma.DeviceGroupEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupEntryPayload>
          }
          aggregate: {
            args: Prisma.DeviceGroupEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceGroupEntry>
          }
          groupBy: {
            args: Prisma.DeviceGroupEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceGroupEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupEntryCountAggregateOutputType> | number
          }
        }
      }
      DeviceGroupMapDevice: {
        payload: Prisma.$DeviceGroupMapDevicePayload<ExtArgs>
        fields: Prisma.DeviceGroupMapDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceGroupMapDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceGroupMapDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceGroupMapDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceGroupMapDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          findMany: {
            args: Prisma.DeviceGroupMapDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>[]
          }
          create: {
            args: Prisma.DeviceGroupMapDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          createMany: {
            args: Prisma.DeviceGroupMapDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceGroupMapDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceGroupMapDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          update: {
            args: Prisma.DeviceGroupMapDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceGroupMapDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceGroupMapDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceGroupMapDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceGroupMapDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceGroupMapDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceGroupMapDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupMapDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupMapDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceGroupMapDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupMapDeviceCountAggregateOutputType> | number
          }
        }
      }
      DeviceGroupMapDeviceGroup: {
        payload: Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>
        fields: Prisma.DeviceGroupMapDeviceGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceGroupMapDeviceGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceGroupMapDeviceGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          findFirst: {
            args: Prisma.DeviceGroupMapDeviceGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceGroupMapDeviceGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          findMany: {
            args: Prisma.DeviceGroupMapDeviceGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>[]
          }
          create: {
            args: Prisma.DeviceGroupMapDeviceGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          createMany: {
            args: Prisma.DeviceGroupMapDeviceGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceGroupMapDeviceGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>[]
          }
          delete: {
            args: Prisma.DeviceGroupMapDeviceGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          update: {
            args: Prisma.DeviceGroupMapDeviceGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          deleteMany: {
            args: Prisma.DeviceGroupMapDeviceGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceGroupMapDeviceGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceGroupMapDeviceGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>[]
          }
          upsert: {
            args: Prisma.DeviceGroupMapDeviceGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceGroupMapDeviceGroupPayload>
          }
          aggregate: {
            args: Prisma.DeviceGroupMapDeviceGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceGroupMapDeviceGroup>
          }
          groupBy: {
            args: Prisma.DeviceGroupMapDeviceGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupMapDeviceGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceGroupMapDeviceGroupCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupMapDeviceGroupCountAggregateOutputType> | number
          }
        }
      }
      DeviceImageColors: {
        payload: Prisma.$DeviceImageColorsPayload<ExtArgs>
        fields: Prisma.DeviceImageColorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceImageColorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceImageColorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          findFirst: {
            args: Prisma.DeviceImageColorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceImageColorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          findMany: {
            args: Prisma.DeviceImageColorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>[]
          }
          create: {
            args: Prisma.DeviceImageColorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          createMany: {
            args: Prisma.DeviceImageColorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceImageColorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>[]
          }
          delete: {
            args: Prisma.DeviceImageColorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          update: {
            args: Prisma.DeviceImageColorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          deleteMany: {
            args: Prisma.DeviceImageColorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceImageColorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceImageColorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>[]
          }
          upsert: {
            args: Prisma.DeviceImageColorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceImageColorsPayload>
          }
          aggregate: {
            args: Prisma.DeviceImageColorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceImageColors>
          }
          groupBy: {
            args: Prisma.DeviceImageColorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceImageColorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceImageColorsCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceImageColorsCountAggregateOutputType> | number
          }
        }
      }
      DeviceLookupArchitecture: {
        payload: Prisma.$DeviceLookupArchitecturePayload<ExtArgs>
        fields: Prisma.DeviceLookupArchitectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceLookupArchitectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceLookupArchitectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          findFirst: {
            args: Prisma.DeviceLookupArchitectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceLookupArchitectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          findMany: {
            args: Prisma.DeviceLookupArchitectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>[]
          }
          create: {
            args: Prisma.DeviceLookupArchitectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          createMany: {
            args: Prisma.DeviceLookupArchitectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceLookupArchitectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>[]
          }
          delete: {
            args: Prisma.DeviceLookupArchitectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          update: {
            args: Prisma.DeviceLookupArchitectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          deleteMany: {
            args: Prisma.DeviceLookupArchitectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceLookupArchitectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceLookupArchitectureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>[]
          }
          upsert: {
            args: Prisma.DeviceLookupArchitectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupArchitecturePayload>
          }
          aggregate: {
            args: Prisma.DeviceLookupArchitectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceLookupArchitecture>
          }
          groupBy: {
            args: Prisma.DeviceLookupArchitectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupArchitectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceLookupArchitectureCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupArchitectureCountAggregateOutputType> | number
          }
        }
      }
      DeviceLookupCategory: {
        payload: Prisma.$DeviceLookupCategoryPayload<ExtArgs>
        fields: Prisma.DeviceLookupCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceLookupCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceLookupCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          findFirst: {
            args: Prisma.DeviceLookupCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceLookupCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          findMany: {
            args: Prisma.DeviceLookupCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>[]
          }
          create: {
            args: Prisma.DeviceLookupCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          createMany: {
            args: Prisma.DeviceLookupCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceLookupCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>[]
          }
          delete: {
            args: Prisma.DeviceLookupCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          update: {
            args: Prisma.DeviceLookupCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          deleteMany: {
            args: Prisma.DeviceLookupCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceLookupCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceLookupCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>[]
          }
          upsert: {
            args: Prisma.DeviceLookupCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupCategoryPayload>
          }
          aggregate: {
            args: Prisma.DeviceLookupCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceLookupCategory>
          }
          groupBy: {
            args: Prisma.DeviceLookupCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceLookupCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupCategoryCountAggregateOutputType> | number
          }
        }
      }
      DeviceLookupImage: {
        payload: Prisma.$DeviceLookupImagePayload<ExtArgs>
        fields: Prisma.DeviceLookupImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceLookupImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceLookupImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          findFirst: {
            args: Prisma.DeviceLookupImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceLookupImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          findMany: {
            args: Prisma.DeviceLookupImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>[]
          }
          create: {
            args: Prisma.DeviceLookupImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          createMany: {
            args: Prisma.DeviceLookupImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceLookupImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>[]
          }
          delete: {
            args: Prisma.DeviceLookupImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          update: {
            args: Prisma.DeviceLookupImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          deleteMany: {
            args: Prisma.DeviceLookupImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceLookupImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceLookupImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>[]
          }
          upsert: {
            args: Prisma.DeviceLookupImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupImagePayload>
          }
          aggregate: {
            args: Prisma.DeviceLookupImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceLookupImage>
          }
          groupBy: {
            args: Prisma.DeviceLookupImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceLookupImageCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupImageCountAggregateOutputType> | number
          }
        }
      }
      DeviceLookupSoc: {
        payload: Prisma.$DeviceLookupSocPayload<ExtArgs>
        fields: Prisma.DeviceLookupSocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceLookupSocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceLookupSocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          findFirst: {
            args: Prisma.DeviceLookupSocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceLookupSocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          findMany: {
            args: Prisma.DeviceLookupSocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>[]
          }
          create: {
            args: Prisma.DeviceLookupSocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          createMany: {
            args: Prisma.DeviceLookupSocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceLookupSocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>[]
          }
          delete: {
            args: Prisma.DeviceLookupSocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          update: {
            args: Prisma.DeviceLookupSocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          deleteMany: {
            args: Prisma.DeviceLookupSocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceLookupSocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceLookupSocUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>[]
          }
          upsert: {
            args: Prisma.DeviceLookupSocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceLookupSocPayload>
          }
          aggregate: {
            args: Prisma.DeviceLookupSocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceLookupSoc>
          }
          groupBy: {
            args: Prisma.DeviceLookupSocGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupSocGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceLookupSocCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceLookupSocCountAggregateOutputType> | number
          }
        }
      }
      DeviceMapArchitecture: {
        payload: Prisma.$DeviceMapArchitecturePayload<ExtArgs>
        fields: Prisma.DeviceMapArchitectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceMapArchitectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceMapArchitectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          findFirst: {
            args: Prisma.DeviceMapArchitectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceMapArchitectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          findMany: {
            args: Prisma.DeviceMapArchitectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>[]
          }
          create: {
            args: Prisma.DeviceMapArchitectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          createMany: {
            args: Prisma.DeviceMapArchitectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceMapArchitectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>[]
          }
          delete: {
            args: Prisma.DeviceMapArchitectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          update: {
            args: Prisma.DeviceMapArchitectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          deleteMany: {
            args: Prisma.DeviceMapArchitectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceMapArchitectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceMapArchitectureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>[]
          }
          upsert: {
            args: Prisma.DeviceMapArchitectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapArchitecturePayload>
          }
          aggregate: {
            args: Prisma.DeviceMapArchitectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceMapArchitecture>
          }
          groupBy: {
            args: Prisma.DeviceMapArchitectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapArchitectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceMapArchitectureCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapArchitectureCountAggregateOutputType> | number
          }
        }
      }
      DeviceMapIdentifier: {
        payload: Prisma.$DeviceMapIdentifierPayload<ExtArgs>
        fields: Prisma.DeviceMapIdentifierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceMapIdentifierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceMapIdentifierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          findFirst: {
            args: Prisma.DeviceMapIdentifierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceMapIdentifierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          findMany: {
            args: Prisma.DeviceMapIdentifierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>[]
          }
          create: {
            args: Prisma.DeviceMapIdentifierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          createMany: {
            args: Prisma.DeviceMapIdentifierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceMapIdentifierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>[]
          }
          delete: {
            args: Prisma.DeviceMapIdentifierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          update: {
            args: Prisma.DeviceMapIdentifierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          deleteMany: {
            args: Prisma.DeviceMapIdentifierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceMapIdentifierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceMapIdentifierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>[]
          }
          upsert: {
            args: Prisma.DeviceMapIdentifierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapIdentifierPayload>
          }
          aggregate: {
            args: Prisma.DeviceMapIdentifierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceMapIdentifier>
          }
          groupBy: {
            args: Prisma.DeviceMapIdentifierGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapIdentifierGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceMapIdentifierCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapIdentifierCountAggregateOutputType> | number
          }
        }
      }
      DeviceMapModel: {
        payload: Prisma.$DeviceMapModelPayload<ExtArgs>
        fields: Prisma.DeviceMapModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceMapModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceMapModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          findFirst: {
            args: Prisma.DeviceMapModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceMapModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          findMany: {
            args: Prisma.DeviceMapModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>[]
          }
          create: {
            args: Prisma.DeviceMapModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          createMany: {
            args: Prisma.DeviceMapModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceMapModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>[]
          }
          delete: {
            args: Prisma.DeviceMapModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          update: {
            args: Prisma.DeviceMapModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          deleteMany: {
            args: Prisma.DeviceMapModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceMapModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceMapModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>[]
          }
          upsert: {
            args: Prisma.DeviceMapModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapModelPayload>
          }
          aggregate: {
            args: Prisma.DeviceMapModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceMapModel>
          }
          groupBy: {
            args: Prisma.DeviceMapModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceMapModelCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapModelCountAggregateOutputType> | number
          }
        }
      }
      DeviceMapRelease: {
        payload: Prisma.$DeviceMapReleasePayload<ExtArgs>
        fields: Prisma.DeviceMapReleaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceMapReleaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceMapReleaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          findFirst: {
            args: Prisma.DeviceMapReleaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceMapReleaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          findMany: {
            args: Prisma.DeviceMapReleaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>[]
          }
          create: {
            args: Prisma.DeviceMapReleaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          createMany: {
            args: Prisma.DeviceMapReleaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceMapReleaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>[]
          }
          delete: {
            args: Prisma.DeviceMapReleaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          update: {
            args: Prisma.DeviceMapReleaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          deleteMany: {
            args: Prisma.DeviceMapReleaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceMapReleaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceMapReleaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>[]
          }
          upsert: {
            args: Prisma.DeviceMapReleaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapReleasePayload>
          }
          aggregate: {
            args: Prisma.DeviceMapReleaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceMapRelease>
          }
          groupBy: {
            args: Prisma.DeviceMapReleaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapReleaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceMapReleaseCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapReleaseCountAggregateOutputType> | number
          }
        }
      }
      DeviceMapSoc: {
        payload: Prisma.$DeviceMapSocPayload<ExtArgs>
        fields: Prisma.DeviceMapSocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceMapSocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceMapSocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          findFirst: {
            args: Prisma.DeviceMapSocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceMapSocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          findMany: {
            args: Prisma.DeviceMapSocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>[]
          }
          create: {
            args: Prisma.DeviceMapSocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          createMany: {
            args: Prisma.DeviceMapSocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceMapSocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>[]
          }
          delete: {
            args: Prisma.DeviceMapSocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          update: {
            args: Prisma.DeviceMapSocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          deleteMany: {
            args: Prisma.DeviceMapSocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceMapSocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceMapSocUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>[]
          }
          upsert: {
            args: Prisma.DeviceMapSocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceMapSocPayload>
          }
          aggregate: {
            args: Prisma.DeviceMapSocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceMapSoc>
          }
          groupBy: {
            args: Prisma.DeviceMapSocGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapSocGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceMapSocCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceMapSocCountAggregateOutputType> | number
          }
        }
      }
      MapDeviceOs: {
        payload: Prisma.$MapDeviceOsPayload<ExtArgs>
        fields: Prisma.MapDeviceOsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapDeviceOsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapDeviceOsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          findFirst: {
            args: Prisma.MapDeviceOsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapDeviceOsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          findMany: {
            args: Prisma.MapDeviceOsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>[]
          }
          create: {
            args: Prisma.MapDeviceOsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          createMany: {
            args: Prisma.MapDeviceOsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapDeviceOsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>[]
          }
          delete: {
            args: Prisma.MapDeviceOsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          update: {
            args: Prisma.MapDeviceOsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          deleteMany: {
            args: Prisma.MapDeviceOsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapDeviceOsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapDeviceOsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>[]
          }
          upsert: {
            args: Prisma.MapDeviceOsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapDeviceOsPayload>
          }
          aggregate: {
            args: Prisma.MapDeviceOsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapDeviceOs>
          }
          groupBy: {
            args: Prisma.MapDeviceOsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapDeviceOsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapDeviceOsCountArgs<ExtArgs>
            result: $Utils.Optional<MapDeviceOsCountAggregateOutputType> | number
          }
        }
      }
      OsEntry: {
        payload: Prisma.$OsEntryPayload<ExtArgs>
        fields: Prisma.OsEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          findFirst: {
            args: Prisma.OsEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          findMany: {
            args: Prisma.OsEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>[]
          }
          create: {
            args: Prisma.OsEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          createMany: {
            args: Prisma.OsEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>[]
          }
          delete: {
            args: Prisma.OsEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          update: {
            args: Prisma.OsEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          deleteMany: {
            args: Prisma.OsEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>[]
          }
          upsert: {
            args: Prisma.OsEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPayload>
          }
          aggregate: {
            args: Prisma.OsEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntry>
          }
          groupBy: {
            args: Prisma.OsEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryCountAggregateOutputType> | number
          }
        }
      }
      OsEntryBuildTrain: {
        payload: Prisma.$OsEntryBuildTrainPayload<ExtArgs>
        fields: Prisma.OsEntryBuildTrainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryBuildTrainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryBuildTrainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          findFirst: {
            args: Prisma.OsEntryBuildTrainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryBuildTrainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          findMany: {
            args: Prisma.OsEntryBuildTrainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>[]
          }
          create: {
            args: Prisma.OsEntryBuildTrainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          createMany: {
            args: Prisma.OsEntryBuildTrainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryBuildTrainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>[]
          }
          delete: {
            args: Prisma.OsEntryBuildTrainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          update: {
            args: Prisma.OsEntryBuildTrainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          deleteMany: {
            args: Prisma.OsEntryBuildTrainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryBuildTrainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryBuildTrainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>[]
          }
          upsert: {
            args: Prisma.OsEntryBuildTrainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryBuildTrainPayload>
          }
          aggregate: {
            args: Prisma.OsEntryBuildTrainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntryBuildTrain>
          }
          groupBy: {
            args: Prisma.OsEntryBuildTrainGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryBuildTrainGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryBuildTrainCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryBuildTrainCountAggregateOutputType> | number
          }
        }
      }
      OsEntryIpd: {
        payload: Prisma.$OsEntryIpdPayload<ExtArgs>
        fields: Prisma.OsEntryIpdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryIpdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryIpdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          findFirst: {
            args: Prisma.OsEntryIpdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryIpdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          findMany: {
            args: Prisma.OsEntryIpdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>[]
          }
          create: {
            args: Prisma.OsEntryIpdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          createMany: {
            args: Prisma.OsEntryIpdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryIpdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>[]
          }
          delete: {
            args: Prisma.OsEntryIpdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          update: {
            args: Prisma.OsEntryIpdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          deleteMany: {
            args: Prisma.OsEntryIpdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryIpdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryIpdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>[]
          }
          upsert: {
            args: Prisma.OsEntryIpdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryIpdPayload>
          }
          aggregate: {
            args: Prisma.OsEntryIpdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntryIpd>
          }
          groupBy: {
            args: Prisma.OsEntryIpdGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryIpdGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryIpdCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryIpdCountAggregateOutputType> | number
          }
        }
      }
      OsEntryOsStringMap: {
        payload: Prisma.$OsEntryOsStringMapPayload<ExtArgs>
        fields: Prisma.OsEntryOsStringMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryOsStringMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryOsStringMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          findFirst: {
            args: Prisma.OsEntryOsStringMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryOsStringMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          findMany: {
            args: Prisma.OsEntryOsStringMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>[]
          }
          create: {
            args: Prisma.OsEntryOsStringMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          createMany: {
            args: Prisma.OsEntryOsStringMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryOsStringMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>[]
          }
          delete: {
            args: Prisma.OsEntryOsStringMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          update: {
            args: Prisma.OsEntryOsStringMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          deleteMany: {
            args: Prisma.OsEntryOsStringMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryOsStringMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryOsStringMapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>[]
          }
          upsert: {
            args: Prisma.OsEntryOsStringMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryOsStringMapPayload>
          }
          aggregate: {
            args: Prisma.OsEntryOsStringMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntryOsStringMap>
          }
          groupBy: {
            args: Prisma.OsEntryOsStringMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryOsStringMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryOsStringMapCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryOsStringMapCountAggregateOutputType> | number
          }
        }
      }
      OsEntryPreinstalled: {
        payload: Prisma.$OsEntryPreinstalledPayload<ExtArgs>
        fields: Prisma.OsEntryPreinstalledFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryPreinstalledFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryPreinstalledFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          findFirst: {
            args: Prisma.OsEntryPreinstalledFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryPreinstalledFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          findMany: {
            args: Prisma.OsEntryPreinstalledFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>[]
          }
          create: {
            args: Prisma.OsEntryPreinstalledCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          createMany: {
            args: Prisma.OsEntryPreinstalledCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryPreinstalledCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>[]
          }
          delete: {
            args: Prisma.OsEntryPreinstalledDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          update: {
            args: Prisma.OsEntryPreinstalledUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          deleteMany: {
            args: Prisma.OsEntryPreinstalledDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryPreinstalledUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryPreinstalledUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>[]
          }
          upsert: {
            args: Prisma.OsEntryPreinstalledUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryPreinstalledPayload>
          }
          aggregate: {
            args: Prisma.OsEntryPreinstalledAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntryPreinstalled>
          }
          groupBy: {
            args: Prisma.OsEntryPreinstalledGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryPreinstalledGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryPreinstalledCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryPreinstalledCountAggregateOutputType> | number
          }
        }
      }
      OsEntryReleaseNote: {
        payload: Prisma.$OsEntryReleaseNotePayload<ExtArgs>
        fields: Prisma.OsEntryReleaseNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntryReleaseNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntryReleaseNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          findFirst: {
            args: Prisma.OsEntryReleaseNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntryReleaseNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          findMany: {
            args: Prisma.OsEntryReleaseNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>[]
          }
          create: {
            args: Prisma.OsEntryReleaseNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          createMany: {
            args: Prisma.OsEntryReleaseNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntryReleaseNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>[]
          }
          delete: {
            args: Prisma.OsEntryReleaseNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          update: {
            args: Prisma.OsEntryReleaseNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          deleteMany: {
            args: Prisma.OsEntryReleaseNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntryReleaseNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntryReleaseNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>[]
          }
          upsert: {
            args: Prisma.OsEntryReleaseNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntryReleaseNotePayload>
          }
          aggregate: {
            args: Prisma.OsEntryReleaseNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntryReleaseNote>
          }
          groupBy: {
            args: Prisma.OsEntryReleaseNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntryReleaseNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntryReleaseNoteCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntryReleaseNoteCountAggregateOutputType> | number
          }
        }
      }
      OsEntrySafariVersion: {
        payload: Prisma.$OsEntrySafariVersionPayload<ExtArgs>
        fields: Prisma.OsEntrySafariVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntrySafariVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntrySafariVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          findFirst: {
            args: Prisma.OsEntrySafariVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntrySafariVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          findMany: {
            args: Prisma.OsEntrySafariVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>[]
          }
          create: {
            args: Prisma.OsEntrySafariVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          createMany: {
            args: Prisma.OsEntrySafariVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntrySafariVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>[]
          }
          delete: {
            args: Prisma.OsEntrySafariVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          update: {
            args: Prisma.OsEntrySafariVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          deleteMany: {
            args: Prisma.OsEntrySafariVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntrySafariVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntrySafariVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>[]
          }
          upsert: {
            args: Prisma.OsEntrySafariVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySafariVersionPayload>
          }
          aggregate: {
            args: Prisma.OsEntrySafariVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntrySafariVersion>
          }
          groupBy: {
            args: Prisma.OsEntrySafariVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntrySafariVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntrySafariVersionCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntrySafariVersionCountAggregateOutputType> | number
          }
        }
      }
      OsEntrySecurityNote: {
        payload: Prisma.$OsEntrySecurityNotePayload<ExtArgs>
        fields: Prisma.OsEntrySecurityNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsEntrySecurityNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsEntrySecurityNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          findFirst: {
            args: Prisma.OsEntrySecurityNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsEntrySecurityNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          findMany: {
            args: Prisma.OsEntrySecurityNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>[]
          }
          create: {
            args: Prisma.OsEntrySecurityNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          createMany: {
            args: Prisma.OsEntrySecurityNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsEntrySecurityNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>[]
          }
          delete: {
            args: Prisma.OsEntrySecurityNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          update: {
            args: Prisma.OsEntrySecurityNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          deleteMany: {
            args: Prisma.OsEntrySecurityNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsEntrySecurityNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsEntrySecurityNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>[]
          }
          upsert: {
            args: Prisma.OsEntrySecurityNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsEntrySecurityNotePayload>
          }
          aggregate: {
            args: Prisma.OsEntrySecurityNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsEntrySecurityNote>
          }
          groupBy: {
            args: Prisma.OsEntrySecurityNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsEntrySecurityNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsEntrySecurityNoteCountArgs<ExtArgs>
            result: $Utils.Optional<OsEntrySecurityNoteCountAggregateOutputType> | number
          }
        }
      }
      OsLookupName: {
        payload: Prisma.$OsLookupNamePayload<ExtArgs>
        fields: Prisma.OsLookupNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OsLookupNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OsLookupNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          findFirst: {
            args: Prisma.OsLookupNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OsLookupNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          findMany: {
            args: Prisma.OsLookupNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>[]
          }
          create: {
            args: Prisma.OsLookupNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          createMany: {
            args: Prisma.OsLookupNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OsLookupNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>[]
          }
          delete: {
            args: Prisma.OsLookupNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          update: {
            args: Prisma.OsLookupNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          deleteMany: {
            args: Prisma.OsLookupNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OsLookupNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OsLookupNameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>[]
          }
          upsert: {
            args: Prisma.OsLookupNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OsLookupNamePayload>
          }
          aggregate: {
            args: Prisma.OsLookupNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOsLookupName>
          }
          groupBy: {
            args: Prisma.OsLookupNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<OsLookupNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.OsLookupNameCountArgs<ExtArgs>
            result: $Utils.Optional<OsLookupNameCountAggregateOutputType> | number
          }
        }
      }
      SourceEntry: {
        payload: Prisma.$SourceEntryPayload<ExtArgs>
        fields: Prisma.SourceEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          findFirst: {
            args: Prisma.SourceEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          findMany: {
            args: Prisma.SourceEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>[]
          }
          create: {
            args: Prisma.SourceEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          createMany: {
            args: Prisma.SourceEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>[]
          }
          delete: {
            args: Prisma.SourceEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          update: {
            args: Prisma.SourceEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          deleteMany: {
            args: Prisma.SourceEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>[]
          }
          upsert: {
            args: Prisma.SourceEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceEntryPayload>
          }
          aggregate: {
            args: Prisma.SourceEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceEntry>
          }
          groupBy: {
            args: Prisma.SourceEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceEntryCountArgs<ExtArgs>
            result: $Utils.Optional<SourceEntryCountAggregateOutputType> | number
          }
        }
      }
      SourceHash: {
        payload: Prisma.$SourceHashPayload<ExtArgs>
        fields: Prisma.SourceHashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceHashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceHashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          findFirst: {
            args: Prisma.SourceHashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceHashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          findMany: {
            args: Prisma.SourceHashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>[]
          }
          create: {
            args: Prisma.SourceHashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          createMany: {
            args: Prisma.SourceHashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceHashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>[]
          }
          delete: {
            args: Prisma.SourceHashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          update: {
            args: Prisma.SourceHashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          deleteMany: {
            args: Prisma.SourceHashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceHashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceHashUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>[]
          }
          upsert: {
            args: Prisma.SourceHashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceHashPayload>
          }
          aggregate: {
            args: Prisma.SourceHashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceHash>
          }
          groupBy: {
            args: Prisma.SourceHashGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceHashGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceHashCountArgs<ExtArgs>
            result: $Utils.Optional<SourceHashCountAggregateOutputType> | number
          }
        }
      }
      SourceLink: {
        payload: Prisma.$SourceLinkPayload<ExtArgs>
        fields: Prisma.SourceLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          findFirst: {
            args: Prisma.SourceLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          findMany: {
            args: Prisma.SourceLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>[]
          }
          create: {
            args: Prisma.SourceLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          createMany: {
            args: Prisma.SourceLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>[]
          }
          delete: {
            args: Prisma.SourceLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          update: {
            args: Prisma.SourceLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          deleteMany: {
            args: Prisma.SourceLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>[]
          }
          upsert: {
            args: Prisma.SourceLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceLinkPayload>
          }
          aggregate: {
            args: Prisma.SourceLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceLink>
          }
          groupBy: {
            args: Prisma.SourceLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SourceLinkCountAggregateOutputType> | number
          }
        }
      }
      SourceMapDevice: {
        payload: Prisma.$SourceMapDevicePayload<ExtArgs>
        fields: Prisma.SourceMapDeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceMapDeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceMapDeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          findFirst: {
            args: Prisma.SourceMapDeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceMapDeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          findMany: {
            args: Prisma.SourceMapDeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>[]
          }
          create: {
            args: Prisma.SourceMapDeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          createMany: {
            args: Prisma.SourceMapDeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceMapDeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>[]
          }
          delete: {
            args: Prisma.SourceMapDeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          update: {
            args: Prisma.SourceMapDeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          deleteMany: {
            args: Prisma.SourceMapDeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceMapDeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceMapDeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>[]
          }
          upsert: {
            args: Prisma.SourceMapDeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapDevicePayload>
          }
          aggregate: {
            args: Prisma.SourceMapDeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceMapDevice>
          }
          groupBy: {
            args: Prisma.SourceMapDeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceMapDeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceMapDeviceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceMapDeviceCountAggregateOutputType> | number
          }
        }
      }
      SourceMapOsString: {
        payload: Prisma.$SourceMapOsStringPayload<ExtArgs>
        fields: Prisma.SourceMapOsStringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceMapOsStringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceMapOsStringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          findFirst: {
            args: Prisma.SourceMapOsStringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceMapOsStringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          findMany: {
            args: Prisma.SourceMapOsStringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>[]
          }
          create: {
            args: Prisma.SourceMapOsStringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          createMany: {
            args: Prisma.SourceMapOsStringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceMapOsStringCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>[]
          }
          delete: {
            args: Prisma.SourceMapOsStringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          update: {
            args: Prisma.SourceMapOsStringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          deleteMany: {
            args: Prisma.SourceMapOsStringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceMapOsStringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceMapOsStringUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>[]
          }
          upsert: {
            args: Prisma.SourceMapOsStringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceMapOsStringPayload>
          }
          aggregate: {
            args: Prisma.SourceMapOsStringAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceMapOsString>
          }
          groupBy: {
            args: Prisma.SourceMapOsStringGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceMapOsStringGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceMapOsStringCountArgs<ExtArgs>
            result: $Utils.Optional<SourceMapOsStringCountAggregateOutputType> | number
          }
        }
      }
      SourcePrequisiteBuild: {
        payload: Prisma.$SourcePrequisiteBuildPayload<ExtArgs>
        fields: Prisma.SourcePrequisiteBuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourcePrequisiteBuildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourcePrequisiteBuildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          findFirst: {
            args: Prisma.SourcePrequisiteBuildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourcePrequisiteBuildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          findMany: {
            args: Prisma.SourcePrequisiteBuildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>[]
          }
          create: {
            args: Prisma.SourcePrequisiteBuildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          createMany: {
            args: Prisma.SourcePrequisiteBuildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourcePrequisiteBuildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>[]
          }
          delete: {
            args: Prisma.SourcePrequisiteBuildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          update: {
            args: Prisma.SourcePrequisiteBuildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          deleteMany: {
            args: Prisma.SourcePrequisiteBuildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourcePrequisiteBuildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourcePrequisiteBuildUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>[]
          }
          upsert: {
            args: Prisma.SourcePrequisiteBuildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePrequisiteBuildPayload>
          }
          aggregate: {
            args: Prisma.SourcePrequisiteBuildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourcePrequisiteBuild>
          }
          groupBy: {
            args: Prisma.SourcePrequisiteBuildGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourcePrequisiteBuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourcePrequisiteBuildCountArgs<ExtArgs>
            result: $Utils.Optional<SourcePrequisiteBuildCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    colorLookup?: ColorLookupOmit
    deviceEntry?: DeviceEntryOmit
    deviceGroupEntry?: DeviceGroupEntryOmit
    deviceGroupMapDevice?: DeviceGroupMapDeviceOmit
    deviceGroupMapDeviceGroup?: DeviceGroupMapDeviceGroupOmit
    deviceImageColors?: DeviceImageColorsOmit
    deviceLookupArchitecture?: DeviceLookupArchitectureOmit
    deviceLookupCategory?: DeviceLookupCategoryOmit
    deviceLookupImage?: DeviceLookupImageOmit
    deviceLookupSoc?: DeviceLookupSocOmit
    deviceMapArchitecture?: DeviceMapArchitectureOmit
    deviceMapIdentifier?: DeviceMapIdentifierOmit
    deviceMapModel?: DeviceMapModelOmit
    deviceMapRelease?: DeviceMapReleaseOmit
    deviceMapSoc?: DeviceMapSocOmit
    mapDeviceOs?: MapDeviceOsOmit
    osEntry?: OsEntryOmit
    osEntryBuildTrain?: OsEntryBuildTrainOmit
    osEntryIpd?: OsEntryIpdOmit
    osEntryOsStringMap?: OsEntryOsStringMapOmit
    osEntryPreinstalled?: OsEntryPreinstalledOmit
    osEntryReleaseNote?: OsEntryReleaseNoteOmit
    osEntrySafariVersion?: OsEntrySafariVersionOmit
    osEntrySecurityNote?: OsEntrySecurityNoteOmit
    osLookupName?: OsLookupNameOmit
    sourceEntry?: SourceEntryOmit
    sourceHash?: SourceHashOmit
    sourceLink?: SourceLinkOmit
    sourceMapDevice?: SourceMapDeviceOmit
    sourceMapOsString?: SourceMapOsStringOmit
    sourcePrequisiteBuild?: SourcePrequisiteBuildOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ColorLookupCountOutputType
   */

  export type ColorLookupCountOutputType = {
    DeviceImageColors: number
  }

  export type ColorLookupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceImageColors?: boolean | ColorLookupCountOutputTypeCountDeviceImageColorsArgs
  }

  // Custom InputTypes
  /**
   * ColorLookupCountOutputType without action
   */
  export type ColorLookupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookupCountOutputType
     */
    select?: ColorLookupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColorLookupCountOutputType without action
   */
  export type ColorLookupCountOutputTypeCountDeviceImageColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceImageColorsWhereInput
  }


  /**
   * Count Type DeviceEntryCountOutputType
   */

  export type DeviceEntryCountOutputType = {
    DeviceGroupMapDevice: number
    DeviceMapArchitecture: number
    DeviceMapIdentifier: number
    DeviceMapModel: number
    DeviceMapRelease: number
    DeviceMapSoc: number
    MapDeviceOs: number
    OsEntryPreinstalled: number
    SourceMapDevice: number
  }

  export type DeviceEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupMapDevice?: boolean | DeviceEntryCountOutputTypeCountDeviceGroupMapDeviceArgs
    DeviceMapArchitecture?: boolean | DeviceEntryCountOutputTypeCountDeviceMapArchitectureArgs
    DeviceMapIdentifier?: boolean | DeviceEntryCountOutputTypeCountDeviceMapIdentifierArgs
    DeviceMapModel?: boolean | DeviceEntryCountOutputTypeCountDeviceMapModelArgs
    DeviceMapRelease?: boolean | DeviceEntryCountOutputTypeCountDeviceMapReleaseArgs
    DeviceMapSoc?: boolean | DeviceEntryCountOutputTypeCountDeviceMapSocArgs
    MapDeviceOs?: boolean | DeviceEntryCountOutputTypeCountMapDeviceOsArgs
    OsEntryPreinstalled?: boolean | DeviceEntryCountOutputTypeCountOsEntryPreinstalledArgs
    SourceMapDevice?: boolean | DeviceEntryCountOutputTypeCountSourceMapDeviceArgs
  }

  // Custom InputTypes
  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntryCountOutputType
     */
    select?: DeviceEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceGroupMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceMapArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapArchitectureWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceMapIdentifierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapIdentifierWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceMapModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapModelWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceMapReleaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapReleaseWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountDeviceMapSocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapSocWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountMapDeviceOsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapDeviceOsWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountOsEntryPreinstalledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryPreinstalledWhereInput
  }

  /**
   * DeviceEntryCountOutputType without action
   */
  export type DeviceEntryCountOutputTypeCountSourceMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceMapDeviceWhereInput
  }


  /**
   * Count Type DeviceGroupEntryCountOutputType
   */

  export type DeviceGroupEntryCountOutputType = {
    DeviceGroupMapDevice: number
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry: number
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry: number
  }

  export type DeviceGroupEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupMapDevice?: boolean | DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceArgs
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs
  }

  // Custom InputTypes
  /**
   * DeviceGroupEntryCountOutputType without action
   */
  export type DeviceGroupEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntryCountOutputType
     */
    select?: DeviceGroupEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceGroupEntryCountOutputType without action
   */
  export type DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceWhereInput
  }

  /**
   * DeviceGroupEntryCountOutputType without action
   */
  export type DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceGroupWhereInput
  }

  /**
   * DeviceGroupEntryCountOutputType without action
   */
  export type DeviceGroupEntryCountOutputTypeCountDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceGroupWhereInput
  }


  /**
   * Count Type DeviceLookupArchitectureCountOutputType
   */

  export type DeviceLookupArchitectureCountOutputType = {
    DeviceMapArchitecture: number
  }

  export type DeviceLookupArchitectureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceMapArchitecture?: boolean | DeviceLookupArchitectureCountOutputTypeCountDeviceMapArchitectureArgs
  }

  // Custom InputTypes
  /**
   * DeviceLookupArchitectureCountOutputType without action
   */
  export type DeviceLookupArchitectureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitectureCountOutputType
     */
    select?: DeviceLookupArchitectureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceLookupArchitectureCountOutputType without action
   */
  export type DeviceLookupArchitectureCountOutputTypeCountDeviceMapArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapArchitectureWhereInput
  }


  /**
   * Count Type DeviceLookupCategoryCountOutputType
   */

  export type DeviceLookupCategoryCountOutputType = {
    DeviceEntry: number
  }

  export type DeviceLookupCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceLookupCategoryCountOutputTypeCountDeviceEntryArgs
  }

  // Custom InputTypes
  /**
   * DeviceLookupCategoryCountOutputType without action
   */
  export type DeviceLookupCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategoryCountOutputType
     */
    select?: DeviceLookupCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceLookupCategoryCountOutputType without action
   */
  export type DeviceLookupCategoryCountOutputTypeCountDeviceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceEntryWhereInput
  }


  /**
   * Count Type DeviceLookupImageCountOutputType
   */

  export type DeviceLookupImageCountOutputType = {
    DeviceEntry: number
    DeviceImageColors: number
  }

  export type DeviceLookupImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceLookupImageCountOutputTypeCountDeviceEntryArgs
    DeviceImageColors?: boolean | DeviceLookupImageCountOutputTypeCountDeviceImageColorsArgs
  }

  // Custom InputTypes
  /**
   * DeviceLookupImageCountOutputType without action
   */
  export type DeviceLookupImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImageCountOutputType
     */
    select?: DeviceLookupImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceLookupImageCountOutputType without action
   */
  export type DeviceLookupImageCountOutputTypeCountDeviceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceEntryWhereInput
  }

  /**
   * DeviceLookupImageCountOutputType without action
   */
  export type DeviceLookupImageCountOutputTypeCountDeviceImageColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceImageColorsWhereInput
  }


  /**
   * Count Type DeviceLookupSocCountOutputType
   */

  export type DeviceLookupSocCountOutputType = {
    DeviceMapSoc: number
  }

  export type DeviceLookupSocCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceMapSoc?: boolean | DeviceLookupSocCountOutputTypeCountDeviceMapSocArgs
  }

  // Custom InputTypes
  /**
   * DeviceLookupSocCountOutputType without action
   */
  export type DeviceLookupSocCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSocCountOutputType
     */
    select?: DeviceLookupSocCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviceLookupSocCountOutputType without action
   */
  export type DeviceLookupSocCountOutputTypeCountDeviceMapSocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapSocWhereInput
  }


  /**
   * Count Type OsEntryCountOutputType
   */

  export type OsEntryCountOutputType = {
    MapDeviceOs: number
    OsEntryBuildTrain: number
    OsEntryIpd: number
    OsEntryOsStringMap: number
    OsEntryPreinstalled: number
    OsEntryReleaseNote: number
    OsEntrySafariVersion: number
    OsEntrySecurityNote: number
    SourceEntry: number
  }

  export type OsEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapDeviceOs?: boolean | OsEntryCountOutputTypeCountMapDeviceOsArgs
    OsEntryBuildTrain?: boolean | OsEntryCountOutputTypeCountOsEntryBuildTrainArgs
    OsEntryIpd?: boolean | OsEntryCountOutputTypeCountOsEntryIpdArgs
    OsEntryOsStringMap?: boolean | OsEntryCountOutputTypeCountOsEntryOsStringMapArgs
    OsEntryPreinstalled?: boolean | OsEntryCountOutputTypeCountOsEntryPreinstalledArgs
    OsEntryReleaseNote?: boolean | OsEntryCountOutputTypeCountOsEntryReleaseNoteArgs
    OsEntrySafariVersion?: boolean | OsEntryCountOutputTypeCountOsEntrySafariVersionArgs
    OsEntrySecurityNote?: boolean | OsEntryCountOutputTypeCountOsEntrySecurityNoteArgs
    SourceEntry?: boolean | OsEntryCountOutputTypeCountSourceEntryArgs
  }

  // Custom InputTypes
  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryCountOutputType
     */
    select?: OsEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountMapDeviceOsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapDeviceOsWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntryBuildTrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryBuildTrainWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntryIpdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryIpdWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntryOsStringMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryOsStringMapWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntryPreinstalledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryPreinstalledWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntryReleaseNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryReleaseNoteWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntrySafariVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntrySafariVersionWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountOsEntrySecurityNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntrySecurityNoteWhereInput
  }

  /**
   * OsEntryCountOutputType without action
   */
  export type OsEntryCountOutputTypeCountSourceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceEntryWhereInput
  }


  /**
   * Count Type OsLookupNameCountOutputType
   */

  export type OsLookupNameCountOutputType = {
    OsEntry: number
  }

  export type OsLookupNameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsLookupNameCountOutputTypeCountOsEntryArgs
  }

  // Custom InputTypes
  /**
   * OsLookupNameCountOutputType without action
   */
  export type OsLookupNameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupNameCountOutputType
     */
    select?: OsLookupNameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OsLookupNameCountOutputType without action
   */
  export type OsLookupNameCountOutputTypeCountOsEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryWhereInput
  }


  /**
   * Count Type SourceEntryCountOutputType
   */

  export type SourceEntryCountOutputType = {
    SourceHash: number
    SourceLink: number
    SourceMapDevice: number
    SourcePrequisiteBuild: number
  }

  export type SourceEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceHash?: boolean | SourceEntryCountOutputTypeCountSourceHashArgs
    SourceLink?: boolean | SourceEntryCountOutputTypeCountSourceLinkArgs
    SourceMapDevice?: boolean | SourceEntryCountOutputTypeCountSourceMapDeviceArgs
    SourcePrequisiteBuild?: boolean | SourceEntryCountOutputTypeCountSourcePrequisiteBuildArgs
  }

  // Custom InputTypes
  /**
   * SourceEntryCountOutputType without action
   */
  export type SourceEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntryCountOutputType
     */
    select?: SourceEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceEntryCountOutputType without action
   */
  export type SourceEntryCountOutputTypeCountSourceHashArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceHashWhereInput
  }

  /**
   * SourceEntryCountOutputType without action
   */
  export type SourceEntryCountOutputTypeCountSourceLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceLinkWhereInput
  }

  /**
   * SourceEntryCountOutputType without action
   */
  export type SourceEntryCountOutputTypeCountSourceMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceMapDeviceWhereInput
  }

  /**
   * SourceEntryCountOutputType without action
   */
  export type SourceEntryCountOutputTypeCountSourcePrequisiteBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourcePrequisiteBuildWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ColorLookup
   */

  export type AggregateColorLookup = {
    _count: ColorLookupCountAggregateOutputType | null
    _avg: ColorLookupAvgAggregateOutputType | null
    _sum: ColorLookupSumAggregateOutputType | null
    _min: ColorLookupMinAggregateOutputType | null
    _max: ColorLookupMaxAggregateOutputType | null
  }

  export type ColorLookupAvgAggregateOutputType = {
    id: number | null
  }

  export type ColorLookupSumAggregateOutputType = {
    id: number | null
  }

  export type ColorLookupMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ColorLookupMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type ColorLookupCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ColorLookupAvgAggregateInputType = {
    id?: true
  }

  export type ColorLookupSumAggregateInputType = {
    id?: true
  }

  export type ColorLookupMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ColorLookupMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ColorLookupCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ColorLookupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ColorLookup to aggregate.
     */
    where?: ColorLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorLookups to fetch.
     */
    orderBy?: ColorLookupOrderByWithRelationInput | ColorLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ColorLookups
    **/
    _count?: true | ColorLookupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorLookupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorLookupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorLookupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorLookupMaxAggregateInputType
  }

  export type GetColorLookupAggregateType<T extends ColorLookupAggregateArgs> = {
        [P in keyof T & keyof AggregateColorLookup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColorLookup[P]>
      : GetScalarType<T[P], AggregateColorLookup[P]>
  }




  export type ColorLookupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorLookupWhereInput
    orderBy?: ColorLookupOrderByWithAggregationInput | ColorLookupOrderByWithAggregationInput[]
    by: ColorLookupScalarFieldEnum[] | ColorLookupScalarFieldEnum
    having?: ColorLookupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorLookupCountAggregateInputType | true
    _avg?: ColorLookupAvgAggregateInputType
    _sum?: ColorLookupSumAggregateInputType
    _min?: ColorLookupMinAggregateInputType
    _max?: ColorLookupMaxAggregateInputType
  }

  export type ColorLookupGroupByOutputType = {
    id: number
    name: string
    _count: ColorLookupCountAggregateOutputType | null
    _avg: ColorLookupAvgAggregateOutputType | null
    _sum: ColorLookupSumAggregateOutputType | null
    _min: ColorLookupMinAggregateOutputType | null
    _max: ColorLookupMaxAggregateOutputType | null
  }

  type GetColorLookupGroupByPayload<T extends ColorLookupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorLookupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorLookupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorLookupGroupByOutputType[P]>
            : GetScalarType<T[P], ColorLookupGroupByOutputType[P]>
        }
      >
    >


  export type ColorLookupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DeviceImageColors?: boolean | ColorLookup$DeviceImageColorsArgs<ExtArgs>
    _count?: boolean | ColorLookupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colorLookup"]>

  export type ColorLookupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["colorLookup"]>

  export type ColorLookupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["colorLookup"]>

  export type ColorLookupSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ColorLookupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["colorLookup"]>
  export type ColorLookupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceImageColors?: boolean | ColorLookup$DeviceImageColorsArgs<ExtArgs>
    _count?: boolean | ColorLookupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColorLookupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ColorLookupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ColorLookupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ColorLookup"
    objects: {
      DeviceImageColors: Prisma.$DeviceImageColorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["colorLookup"]>
    composites: {}
  }

  type ColorLookupGetPayload<S extends boolean | null | undefined | ColorLookupDefaultArgs> = $Result.GetResult<Prisma.$ColorLookupPayload, S>

  type ColorLookupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColorLookupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColorLookupCountAggregateInputType | true
    }

  export interface ColorLookupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ColorLookup'], meta: { name: 'ColorLookup' } }
    /**
     * Find zero or one ColorLookup that matches the filter.
     * @param {ColorLookupFindUniqueArgs} args - Arguments to find a ColorLookup
     * @example
     * // Get one ColorLookup
     * const colorLookup = await prisma.colorLookup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColorLookupFindUniqueArgs>(args: SelectSubset<T, ColorLookupFindUniqueArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ColorLookup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColorLookupFindUniqueOrThrowArgs} args - Arguments to find a ColorLookup
     * @example
     * // Get one ColorLookup
     * const colorLookup = await prisma.colorLookup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColorLookupFindUniqueOrThrowArgs>(args: SelectSubset<T, ColorLookupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ColorLookup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupFindFirstArgs} args - Arguments to find a ColorLookup
     * @example
     * // Get one ColorLookup
     * const colorLookup = await prisma.colorLookup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColorLookupFindFirstArgs>(args?: SelectSubset<T, ColorLookupFindFirstArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ColorLookup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupFindFirstOrThrowArgs} args - Arguments to find a ColorLookup
     * @example
     * // Get one ColorLookup
     * const colorLookup = await prisma.colorLookup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColorLookupFindFirstOrThrowArgs>(args?: SelectSubset<T, ColorLookupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ColorLookups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ColorLookups
     * const colorLookups = await prisma.colorLookup.findMany()
     * 
     * // Get first 10 ColorLookups
     * const colorLookups = await prisma.colorLookup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorLookupWithIdOnly = await prisma.colorLookup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColorLookupFindManyArgs>(args?: SelectSubset<T, ColorLookupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ColorLookup.
     * @param {ColorLookupCreateArgs} args - Arguments to create a ColorLookup.
     * @example
     * // Create one ColorLookup
     * const ColorLookup = await prisma.colorLookup.create({
     *   data: {
     *     // ... data to create a ColorLookup
     *   }
     * })
     * 
     */
    create<T extends ColorLookupCreateArgs>(args: SelectSubset<T, ColorLookupCreateArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ColorLookups.
     * @param {ColorLookupCreateManyArgs} args - Arguments to create many ColorLookups.
     * @example
     * // Create many ColorLookups
     * const colorLookup = await prisma.colorLookup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColorLookupCreateManyArgs>(args?: SelectSubset<T, ColorLookupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ColorLookups and returns the data saved in the database.
     * @param {ColorLookupCreateManyAndReturnArgs} args - Arguments to create many ColorLookups.
     * @example
     * // Create many ColorLookups
     * const colorLookup = await prisma.colorLookup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ColorLookups and only return the `id`
     * const colorLookupWithIdOnly = await prisma.colorLookup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColorLookupCreateManyAndReturnArgs>(args?: SelectSubset<T, ColorLookupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ColorLookup.
     * @param {ColorLookupDeleteArgs} args - Arguments to delete one ColorLookup.
     * @example
     * // Delete one ColorLookup
     * const ColorLookup = await prisma.colorLookup.delete({
     *   where: {
     *     // ... filter to delete one ColorLookup
     *   }
     * })
     * 
     */
    delete<T extends ColorLookupDeleteArgs>(args: SelectSubset<T, ColorLookupDeleteArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ColorLookup.
     * @param {ColorLookupUpdateArgs} args - Arguments to update one ColorLookup.
     * @example
     * // Update one ColorLookup
     * const colorLookup = await prisma.colorLookup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColorLookupUpdateArgs>(args: SelectSubset<T, ColorLookupUpdateArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ColorLookups.
     * @param {ColorLookupDeleteManyArgs} args - Arguments to filter ColorLookups to delete.
     * @example
     * // Delete a few ColorLookups
     * const { count } = await prisma.colorLookup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColorLookupDeleteManyArgs>(args?: SelectSubset<T, ColorLookupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ColorLookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ColorLookups
     * const colorLookup = await prisma.colorLookup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColorLookupUpdateManyArgs>(args: SelectSubset<T, ColorLookupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ColorLookups and returns the data updated in the database.
     * @param {ColorLookupUpdateManyAndReturnArgs} args - Arguments to update many ColorLookups.
     * @example
     * // Update many ColorLookups
     * const colorLookup = await prisma.colorLookup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ColorLookups and only return the `id`
     * const colorLookupWithIdOnly = await prisma.colorLookup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColorLookupUpdateManyAndReturnArgs>(args: SelectSubset<T, ColorLookupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ColorLookup.
     * @param {ColorLookupUpsertArgs} args - Arguments to update or create a ColorLookup.
     * @example
     * // Update or create a ColorLookup
     * const colorLookup = await prisma.colorLookup.upsert({
     *   create: {
     *     // ... data to create a ColorLookup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ColorLookup we want to update
     *   }
     * })
     */
    upsert<T extends ColorLookupUpsertArgs>(args: SelectSubset<T, ColorLookupUpsertArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ColorLookups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupCountArgs} args - Arguments to filter ColorLookups to count.
     * @example
     * // Count the number of ColorLookups
     * const count = await prisma.colorLookup.count({
     *   where: {
     *     // ... the filter for the ColorLookups we want to count
     *   }
     * })
    **/
    count<T extends ColorLookupCountArgs>(
      args?: Subset<T, ColorLookupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorLookupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ColorLookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorLookupAggregateArgs>(args: Subset<T, ColorLookupAggregateArgs>): Prisma.PrismaPromise<GetColorLookupAggregateType<T>>

    /**
     * Group by ColorLookup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorLookupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorLookupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorLookupGroupByArgs['orderBy'] }
        : { orderBy?: ColorLookupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorLookupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorLookupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ColorLookup model
   */
  readonly fields: ColorLookupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ColorLookup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorLookupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceImageColors<T extends ColorLookup$DeviceImageColorsArgs<ExtArgs> = {}>(args?: Subset<T, ColorLookup$DeviceImageColorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ColorLookup model
   */
  interface ColorLookupFieldRefs {
    readonly id: FieldRef<"ColorLookup", 'Int'>
    readonly name: FieldRef<"ColorLookup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ColorLookup findUnique
   */
  export type ColorLookupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter, which ColorLookup to fetch.
     */
    where: ColorLookupWhereUniqueInput
  }

  /**
   * ColorLookup findUniqueOrThrow
   */
  export type ColorLookupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter, which ColorLookup to fetch.
     */
    where: ColorLookupWhereUniqueInput
  }

  /**
   * ColorLookup findFirst
   */
  export type ColorLookupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter, which ColorLookup to fetch.
     */
    where?: ColorLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorLookups to fetch.
     */
    orderBy?: ColorLookupOrderByWithRelationInput | ColorLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ColorLookups.
     */
    cursor?: ColorLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ColorLookups.
     */
    distinct?: ColorLookupScalarFieldEnum | ColorLookupScalarFieldEnum[]
  }

  /**
   * ColorLookup findFirstOrThrow
   */
  export type ColorLookupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter, which ColorLookup to fetch.
     */
    where?: ColorLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorLookups to fetch.
     */
    orderBy?: ColorLookupOrderByWithRelationInput | ColorLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ColorLookups.
     */
    cursor?: ColorLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorLookups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ColorLookups.
     */
    distinct?: ColorLookupScalarFieldEnum | ColorLookupScalarFieldEnum[]
  }

  /**
   * ColorLookup findMany
   */
  export type ColorLookupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter, which ColorLookups to fetch.
     */
    where?: ColorLookupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ColorLookups to fetch.
     */
    orderBy?: ColorLookupOrderByWithRelationInput | ColorLookupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ColorLookups.
     */
    cursor?: ColorLookupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ColorLookups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ColorLookups.
     */
    skip?: number
    distinct?: ColorLookupScalarFieldEnum | ColorLookupScalarFieldEnum[]
  }

  /**
   * ColorLookup create
   */
  export type ColorLookupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * The data needed to create a ColorLookup.
     */
    data: XOR<ColorLookupCreateInput, ColorLookupUncheckedCreateInput>
  }

  /**
   * ColorLookup createMany
   */
  export type ColorLookupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ColorLookups.
     */
    data: ColorLookupCreateManyInput | ColorLookupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ColorLookup createManyAndReturn
   */
  export type ColorLookupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * The data used to create many ColorLookups.
     */
    data: ColorLookupCreateManyInput | ColorLookupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ColorLookup update
   */
  export type ColorLookupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * The data needed to update a ColorLookup.
     */
    data: XOR<ColorLookupUpdateInput, ColorLookupUncheckedUpdateInput>
    /**
     * Choose, which ColorLookup to update.
     */
    where: ColorLookupWhereUniqueInput
  }

  /**
   * ColorLookup updateMany
   */
  export type ColorLookupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ColorLookups.
     */
    data: XOR<ColorLookupUpdateManyMutationInput, ColorLookupUncheckedUpdateManyInput>
    /**
     * Filter which ColorLookups to update
     */
    where?: ColorLookupWhereInput
    /**
     * Limit how many ColorLookups to update.
     */
    limit?: number
  }

  /**
   * ColorLookup updateManyAndReturn
   */
  export type ColorLookupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * The data used to update ColorLookups.
     */
    data: XOR<ColorLookupUpdateManyMutationInput, ColorLookupUncheckedUpdateManyInput>
    /**
     * Filter which ColorLookups to update
     */
    where?: ColorLookupWhereInput
    /**
     * Limit how many ColorLookups to update.
     */
    limit?: number
  }

  /**
   * ColorLookup upsert
   */
  export type ColorLookupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * The filter to search for the ColorLookup to update in case it exists.
     */
    where: ColorLookupWhereUniqueInput
    /**
     * In case the ColorLookup found by the `where` argument doesn't exist, create a new ColorLookup with this data.
     */
    create: XOR<ColorLookupCreateInput, ColorLookupUncheckedCreateInput>
    /**
     * In case the ColorLookup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorLookupUpdateInput, ColorLookupUncheckedUpdateInput>
  }

  /**
   * ColorLookup delete
   */
  export type ColorLookupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
    /**
     * Filter which ColorLookup to delete.
     */
    where: ColorLookupWhereUniqueInput
  }

  /**
   * ColorLookup deleteMany
   */
  export type ColorLookupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ColorLookups to delete
     */
    where?: ColorLookupWhereInput
    /**
     * Limit how many ColorLookups to delete.
     */
    limit?: number
  }

  /**
   * ColorLookup.DeviceImageColors
   */
  export type ColorLookup$DeviceImageColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    where?: DeviceImageColorsWhereInput
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    cursor?: DeviceImageColorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceImageColorsScalarFieldEnum | DeviceImageColorsScalarFieldEnum[]
  }

  /**
   * ColorLookup without action
   */
  export type ColorLookupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorLookup
     */
    select?: ColorLookupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ColorLookup
     */
    omit?: ColorLookupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorLookupInclude<ExtArgs> | null
  }


  /**
   * Model DeviceEntry
   */

  export type AggregateDeviceEntry = {
    _count: DeviceEntryCountAggregateOutputType | null
    _avg: DeviceEntryAvgAggregateOutputType | null
    _sum: DeviceEntrySumAggregateOutputType | null
    _min: DeviceEntryMinAggregateOutputType | null
    _max: DeviceEntryMaxAggregateOutputType | null
  }

  export type DeviceEntryAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    image_id: number | null
  }

  export type DeviceEntrySumAggregateOutputType = {
    id: number | null
    category_id: number | null
    image_id: number | null
  }

  export type DeviceEntryMinAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
  }

  export type DeviceEntryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
  }

  export type DeviceEntryCountAggregateOutputType = {
    id: number
    name: number
    category_id: number
    image_id: number
    is_internal: number
    legacy_unique_key: number
    _all: number
  }


  export type DeviceEntryAvgAggregateInputType = {
    id?: true
    category_id?: true
    image_id?: true
  }

  export type DeviceEntrySumAggregateInputType = {
    id?: true
    category_id?: true
    image_id?: true
  }

  export type DeviceEntryMinAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
  }

  export type DeviceEntryMaxAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
  }

  export type DeviceEntryCountAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
    _all?: true
  }

  export type DeviceEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceEntry to aggregate.
     */
    where?: DeviceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceEntries to fetch.
     */
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceEntries
    **/
    _count?: true | DeviceEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceEntryMaxAggregateInputType
  }

  export type GetDeviceEntryAggregateType<T extends DeviceEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceEntry[P]>
      : GetScalarType<T[P], AggregateDeviceEntry[P]>
  }




  export type DeviceEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceEntryWhereInput
    orderBy?: DeviceEntryOrderByWithAggregationInput | DeviceEntryOrderByWithAggregationInput[]
    by: DeviceEntryScalarFieldEnum[] | DeviceEntryScalarFieldEnum
    having?: DeviceEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceEntryCountAggregateInputType | true
    _avg?: DeviceEntryAvgAggregateInputType
    _sum?: DeviceEntrySumAggregateInputType
    _min?: DeviceEntryMinAggregateInputType
    _max?: DeviceEntryMaxAggregateInputType
  }

  export type DeviceEntryGroupByOutputType = {
    id: number
    name: string
    category_id: number
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
    _count: DeviceEntryCountAggregateOutputType | null
    _avg: DeviceEntryAvgAggregateOutputType | null
    _sum: DeviceEntrySumAggregateOutputType | null
    _min: DeviceEntryMinAggregateOutputType | null
    _max: DeviceEntryMaxAggregateOutputType | null
  }

  type GetDeviceEntryGroupByPayload<T extends DeviceEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceEntryGroupByOutputType[P]>
        }
      >
    >


  export type DeviceEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
    DeviceGroupMapDevice?: boolean | DeviceEntry$DeviceGroupMapDeviceArgs<ExtArgs>
    DeviceMapArchitecture?: boolean | DeviceEntry$DeviceMapArchitectureArgs<ExtArgs>
    DeviceMapIdentifier?: boolean | DeviceEntry$DeviceMapIdentifierArgs<ExtArgs>
    DeviceMapModel?: boolean | DeviceEntry$DeviceMapModelArgs<ExtArgs>
    DeviceMapRelease?: boolean | DeviceEntry$DeviceMapReleaseArgs<ExtArgs>
    DeviceMapSoc?: boolean | DeviceEntry$DeviceMapSocArgs<ExtArgs>
    MapDeviceOs?: boolean | DeviceEntry$MapDeviceOsArgs<ExtArgs>
    OsEntryPreinstalled?: boolean | DeviceEntry$OsEntryPreinstalledArgs<ExtArgs>
    SourceMapDevice?: boolean | DeviceEntry$SourceMapDeviceArgs<ExtArgs>
    _count?: boolean | DeviceEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceEntry"]>

  export type DeviceEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
  }, ExtArgs["result"]["deviceEntry"]>

  export type DeviceEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
  }, ExtArgs["result"]["deviceEntry"]>

  export type DeviceEntrySelectScalar = {
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
  }

  export type DeviceEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category_id" | "image_id" | "is_internal" | "legacy_unique_key", ExtArgs["result"]["deviceEntry"]>
  export type DeviceEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
    DeviceGroupMapDevice?: boolean | DeviceEntry$DeviceGroupMapDeviceArgs<ExtArgs>
    DeviceMapArchitecture?: boolean | DeviceEntry$DeviceMapArchitectureArgs<ExtArgs>
    DeviceMapIdentifier?: boolean | DeviceEntry$DeviceMapIdentifierArgs<ExtArgs>
    DeviceMapModel?: boolean | DeviceEntry$DeviceMapModelArgs<ExtArgs>
    DeviceMapRelease?: boolean | DeviceEntry$DeviceMapReleaseArgs<ExtArgs>
    DeviceMapSoc?: boolean | DeviceEntry$DeviceMapSocArgs<ExtArgs>
    MapDeviceOs?: boolean | DeviceEntry$MapDeviceOsArgs<ExtArgs>
    OsEntryPreinstalled?: boolean | DeviceEntry$OsEntryPreinstalledArgs<ExtArgs>
    SourceMapDevice?: boolean | DeviceEntry$SourceMapDeviceArgs<ExtArgs>
    _count?: boolean | DeviceEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
  }
  export type DeviceEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupCategory?: boolean | DeviceLookupCategoryDefaultArgs<ExtArgs>
    DeviceLookupImage?: boolean | DeviceEntry$DeviceLookupImageArgs<ExtArgs>
  }

  export type $DeviceEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceEntry"
    objects: {
      DeviceLookupCategory: Prisma.$DeviceLookupCategoryPayload<ExtArgs>
      DeviceLookupImage: Prisma.$DeviceLookupImagePayload<ExtArgs> | null
      DeviceGroupMapDevice: Prisma.$DeviceGroupMapDevicePayload<ExtArgs>[]
      DeviceMapArchitecture: Prisma.$DeviceMapArchitecturePayload<ExtArgs>[]
      DeviceMapIdentifier: Prisma.$DeviceMapIdentifierPayload<ExtArgs>[]
      DeviceMapModel: Prisma.$DeviceMapModelPayload<ExtArgs>[]
      DeviceMapRelease: Prisma.$DeviceMapReleasePayload<ExtArgs>[]
      DeviceMapSoc: Prisma.$DeviceMapSocPayload<ExtArgs>[]
      MapDeviceOs: Prisma.$MapDeviceOsPayload<ExtArgs>[]
      OsEntryPreinstalled: Prisma.$OsEntryPreinstalledPayload<ExtArgs>[]
      SourceMapDevice: Prisma.$SourceMapDevicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category_id: number
      image_id: number | null
      is_internal: boolean | null
      legacy_unique_key: string | null
    }, ExtArgs["result"]["deviceEntry"]>
    composites: {}
  }

  type DeviceEntryGetPayload<S extends boolean | null | undefined | DeviceEntryDefaultArgs> = $Result.GetResult<Prisma.$DeviceEntryPayload, S>

  type DeviceEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceEntryCountAggregateInputType | true
    }

  export interface DeviceEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceEntry'], meta: { name: 'DeviceEntry' } }
    /**
     * Find zero or one DeviceEntry that matches the filter.
     * @param {DeviceEntryFindUniqueArgs} args - Arguments to find a DeviceEntry
     * @example
     * // Get one DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceEntryFindUniqueArgs>(args: SelectSubset<T, DeviceEntryFindUniqueArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceEntryFindUniqueOrThrowArgs} args - Arguments to find a DeviceEntry
     * @example
     * // Get one DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryFindFirstArgs} args - Arguments to find a DeviceEntry
     * @example
     * // Get one DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceEntryFindFirstArgs>(args?: SelectSubset<T, DeviceEntryFindFirstArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryFindFirstOrThrowArgs} args - Arguments to find a DeviceEntry
     * @example
     * // Get one DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceEntries
     * const deviceEntries = await prisma.deviceEntry.findMany()
     * 
     * // Get first 10 DeviceEntries
     * const deviceEntries = await prisma.deviceEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceEntryWithIdOnly = await prisma.deviceEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceEntryFindManyArgs>(args?: SelectSubset<T, DeviceEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceEntry.
     * @param {DeviceEntryCreateArgs} args - Arguments to create a DeviceEntry.
     * @example
     * // Create one DeviceEntry
     * const DeviceEntry = await prisma.deviceEntry.create({
     *   data: {
     *     // ... data to create a DeviceEntry
     *   }
     * })
     * 
     */
    create<T extends DeviceEntryCreateArgs>(args: SelectSubset<T, DeviceEntryCreateArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceEntries.
     * @param {DeviceEntryCreateManyArgs} args - Arguments to create many DeviceEntries.
     * @example
     * // Create many DeviceEntries
     * const deviceEntry = await prisma.deviceEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceEntryCreateManyArgs>(args?: SelectSubset<T, DeviceEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceEntries and returns the data saved in the database.
     * @param {DeviceEntryCreateManyAndReturnArgs} args - Arguments to create many DeviceEntries.
     * @example
     * // Create many DeviceEntries
     * const deviceEntry = await prisma.deviceEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceEntries and only return the `id`
     * const deviceEntryWithIdOnly = await prisma.deviceEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceEntry.
     * @param {DeviceEntryDeleteArgs} args - Arguments to delete one DeviceEntry.
     * @example
     * // Delete one DeviceEntry
     * const DeviceEntry = await prisma.deviceEntry.delete({
     *   where: {
     *     // ... filter to delete one DeviceEntry
     *   }
     * })
     * 
     */
    delete<T extends DeviceEntryDeleteArgs>(args: SelectSubset<T, DeviceEntryDeleteArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceEntry.
     * @param {DeviceEntryUpdateArgs} args - Arguments to update one DeviceEntry.
     * @example
     * // Update one DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceEntryUpdateArgs>(args: SelectSubset<T, DeviceEntryUpdateArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceEntries.
     * @param {DeviceEntryDeleteManyArgs} args - Arguments to filter DeviceEntries to delete.
     * @example
     * // Delete a few DeviceEntries
     * const { count } = await prisma.deviceEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceEntryDeleteManyArgs>(args?: SelectSubset<T, DeviceEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceEntries
     * const deviceEntry = await prisma.deviceEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceEntryUpdateManyArgs>(args: SelectSubset<T, DeviceEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceEntries and returns the data updated in the database.
     * @param {DeviceEntryUpdateManyAndReturnArgs} args - Arguments to update many DeviceEntries.
     * @example
     * // Update many DeviceEntries
     * const deviceEntry = await prisma.deviceEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceEntries and only return the `id`
     * const deviceEntryWithIdOnly = await prisma.deviceEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceEntry.
     * @param {DeviceEntryUpsertArgs} args - Arguments to update or create a DeviceEntry.
     * @example
     * // Update or create a DeviceEntry
     * const deviceEntry = await prisma.deviceEntry.upsert({
     *   create: {
     *     // ... data to create a DeviceEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceEntry we want to update
     *   }
     * })
     */
    upsert<T extends DeviceEntryUpsertArgs>(args: SelectSubset<T, DeviceEntryUpsertArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryCountArgs} args - Arguments to filter DeviceEntries to count.
     * @example
     * // Count the number of DeviceEntries
     * const count = await prisma.deviceEntry.count({
     *   where: {
     *     // ... the filter for the DeviceEntries we want to count
     *   }
     * })
    **/
    count<T extends DeviceEntryCountArgs>(
      args?: Subset<T, DeviceEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceEntryAggregateArgs>(args: Subset<T, DeviceEntryAggregateArgs>): Prisma.PrismaPromise<GetDeviceEntryAggregateType<T>>

    /**
     * Group by DeviceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceEntryGroupByArgs['orderBy'] }
        : { orderBy?: DeviceEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceEntry model
   */
  readonly fields: DeviceEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceLookupCategory<T extends DeviceLookupCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupCategoryDefaultArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceLookupImage<T extends DeviceEntry$DeviceLookupImageArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceLookupImageArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    DeviceGroupMapDevice<T extends DeviceEntry$DeviceGroupMapDeviceArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceGroupMapDeviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceMapArchitecture<T extends DeviceEntry$DeviceMapArchitectureArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceMapArchitectureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceMapIdentifier<T extends DeviceEntry$DeviceMapIdentifierArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceMapIdentifierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceMapModel<T extends DeviceEntry$DeviceMapModelArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceMapModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceMapRelease<T extends DeviceEntry$DeviceMapReleaseArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceMapReleaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceMapSoc<T extends DeviceEntry$DeviceMapSocArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$DeviceMapSocArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MapDeviceOs<T extends DeviceEntry$MapDeviceOsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$MapDeviceOsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntryPreinstalled<T extends DeviceEntry$OsEntryPreinstalledArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$OsEntryPreinstalledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceMapDevice<T extends DeviceEntry$SourceMapDeviceArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntry$SourceMapDeviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceEntry model
   */
  interface DeviceEntryFieldRefs {
    readonly id: FieldRef<"DeviceEntry", 'Int'>
    readonly name: FieldRef<"DeviceEntry", 'String'>
    readonly category_id: FieldRef<"DeviceEntry", 'Int'>
    readonly image_id: FieldRef<"DeviceEntry", 'Int'>
    readonly is_internal: FieldRef<"DeviceEntry", 'Boolean'>
    readonly legacy_unique_key: FieldRef<"DeviceEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceEntry findUnique
   */
  export type DeviceEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceEntry to fetch.
     */
    where: DeviceEntryWhereUniqueInput
  }

  /**
   * DeviceEntry findUniqueOrThrow
   */
  export type DeviceEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceEntry to fetch.
     */
    where: DeviceEntryWhereUniqueInput
  }

  /**
   * DeviceEntry findFirst
   */
  export type DeviceEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceEntry to fetch.
     */
    where?: DeviceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceEntries to fetch.
     */
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceEntries.
     */
    cursor?: DeviceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceEntries.
     */
    distinct?: DeviceEntryScalarFieldEnum | DeviceEntryScalarFieldEnum[]
  }

  /**
   * DeviceEntry findFirstOrThrow
   */
  export type DeviceEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceEntry to fetch.
     */
    where?: DeviceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceEntries to fetch.
     */
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceEntries.
     */
    cursor?: DeviceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceEntries.
     */
    distinct?: DeviceEntryScalarFieldEnum | DeviceEntryScalarFieldEnum[]
  }

  /**
   * DeviceEntry findMany
   */
  export type DeviceEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceEntries to fetch.
     */
    where?: DeviceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceEntries to fetch.
     */
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceEntries.
     */
    cursor?: DeviceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceEntries.
     */
    skip?: number
    distinct?: DeviceEntryScalarFieldEnum | DeviceEntryScalarFieldEnum[]
  }

  /**
   * DeviceEntry create
   */
  export type DeviceEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceEntry.
     */
    data: XOR<DeviceEntryCreateInput, DeviceEntryUncheckedCreateInput>
  }

  /**
   * DeviceEntry createMany
   */
  export type DeviceEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceEntries.
     */
    data: DeviceEntryCreateManyInput | DeviceEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceEntry createManyAndReturn
   */
  export type DeviceEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceEntries.
     */
    data: DeviceEntryCreateManyInput | DeviceEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceEntry update
   */
  export type DeviceEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceEntry.
     */
    data: XOR<DeviceEntryUpdateInput, DeviceEntryUncheckedUpdateInput>
    /**
     * Choose, which DeviceEntry to update.
     */
    where: DeviceEntryWhereUniqueInput
  }

  /**
   * DeviceEntry updateMany
   */
  export type DeviceEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceEntries.
     */
    data: XOR<DeviceEntryUpdateManyMutationInput, DeviceEntryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceEntries to update
     */
    where?: DeviceEntryWhereInput
    /**
     * Limit how many DeviceEntries to update.
     */
    limit?: number
  }

  /**
   * DeviceEntry updateManyAndReturn
   */
  export type DeviceEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * The data used to update DeviceEntries.
     */
    data: XOR<DeviceEntryUpdateManyMutationInput, DeviceEntryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceEntries to update
     */
    where?: DeviceEntryWhereInput
    /**
     * Limit how many DeviceEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceEntry upsert
   */
  export type DeviceEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceEntry to update in case it exists.
     */
    where: DeviceEntryWhereUniqueInput
    /**
     * In case the DeviceEntry found by the `where` argument doesn't exist, create a new DeviceEntry with this data.
     */
    create: XOR<DeviceEntryCreateInput, DeviceEntryUncheckedCreateInput>
    /**
     * In case the DeviceEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceEntryUpdateInput, DeviceEntryUncheckedUpdateInput>
  }

  /**
   * DeviceEntry delete
   */
  export type DeviceEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    /**
     * Filter which DeviceEntry to delete.
     */
    where: DeviceEntryWhereUniqueInput
  }

  /**
   * DeviceEntry deleteMany
   */
  export type DeviceEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceEntries to delete
     */
    where?: DeviceEntryWhereInput
    /**
     * Limit how many DeviceEntries to delete.
     */
    limit?: number
  }

  /**
   * DeviceEntry.DeviceLookupImage
   */
  export type DeviceEntry$DeviceLookupImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    where?: DeviceLookupImageWhereInput
  }

  /**
   * DeviceEntry.DeviceGroupMapDevice
   */
  export type DeviceEntry$DeviceGroupMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    where?: DeviceGroupMapDeviceWhereInput
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupMapDeviceScalarFieldEnum | DeviceGroupMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceEntry.DeviceMapArchitecture
   */
  export type DeviceEntry$DeviceMapArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    where?: DeviceMapArchitectureWhereInput
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    cursor?: DeviceMapArchitectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapArchitectureScalarFieldEnum | DeviceMapArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceEntry.DeviceMapIdentifier
   */
  export type DeviceEntry$DeviceMapIdentifierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    where?: DeviceMapIdentifierWhereInput
    orderBy?: DeviceMapIdentifierOrderByWithRelationInput | DeviceMapIdentifierOrderByWithRelationInput[]
    cursor?: DeviceMapIdentifierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapIdentifierScalarFieldEnum | DeviceMapIdentifierScalarFieldEnum[]
  }

  /**
   * DeviceEntry.DeviceMapModel
   */
  export type DeviceEntry$DeviceMapModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    where?: DeviceMapModelWhereInput
    orderBy?: DeviceMapModelOrderByWithRelationInput | DeviceMapModelOrderByWithRelationInput[]
    cursor?: DeviceMapModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapModelScalarFieldEnum | DeviceMapModelScalarFieldEnum[]
  }

  /**
   * DeviceEntry.DeviceMapRelease
   */
  export type DeviceEntry$DeviceMapReleaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    where?: DeviceMapReleaseWhereInput
    orderBy?: DeviceMapReleaseOrderByWithRelationInput | DeviceMapReleaseOrderByWithRelationInput[]
    cursor?: DeviceMapReleaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapReleaseScalarFieldEnum | DeviceMapReleaseScalarFieldEnum[]
  }

  /**
   * DeviceEntry.DeviceMapSoc
   */
  export type DeviceEntry$DeviceMapSocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    where?: DeviceMapSocWhereInput
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    cursor?: DeviceMapSocWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapSocScalarFieldEnum | DeviceMapSocScalarFieldEnum[]
  }

  /**
   * DeviceEntry.MapDeviceOs
   */
  export type DeviceEntry$MapDeviceOsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    where?: MapDeviceOsWhereInput
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    cursor?: MapDeviceOsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapDeviceOsScalarFieldEnum | MapDeviceOsScalarFieldEnum[]
  }

  /**
   * DeviceEntry.OsEntryPreinstalled
   */
  export type DeviceEntry$OsEntryPreinstalledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    where?: OsEntryPreinstalledWhereInput
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    cursor?: OsEntryPreinstalledWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryPreinstalledScalarFieldEnum | OsEntryPreinstalledScalarFieldEnum[]
  }

  /**
   * DeviceEntry.SourceMapDevice
   */
  export type DeviceEntry$SourceMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    where?: SourceMapDeviceWhereInput
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    cursor?: SourceMapDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceMapDeviceScalarFieldEnum | SourceMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceEntry without action
   */
  export type DeviceEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
  }


  /**
   * Model DeviceGroupEntry
   */

  export type AggregateDeviceGroupEntry = {
    _count: DeviceGroupEntryCountAggregateOutputType | null
    _avg: DeviceGroupEntryAvgAggregateOutputType | null
    _sum: DeviceGroupEntrySumAggregateOutputType | null
    _min: DeviceGroupEntryMinAggregateOutputType | null
    _max: DeviceGroupEntryMaxAggregateOutputType | null
  }

  export type DeviceGroupEntryAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    image_id: number | null
  }

  export type DeviceGroupEntrySumAggregateOutputType = {
    id: number | null
    category_id: number | null
    image_id: number | null
  }

  export type DeviceGroupEntryMinAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
  }

  export type DeviceGroupEntryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
  }

  export type DeviceGroupEntryCountAggregateOutputType = {
    id: number
    name: number
    category_id: number
    image_id: number
    is_internal: number
    legacy_unique_key: number
    _all: number
  }


  export type DeviceGroupEntryAvgAggregateInputType = {
    id?: true
    category_id?: true
    image_id?: true
  }

  export type DeviceGroupEntrySumAggregateInputType = {
    id?: true
    category_id?: true
    image_id?: true
  }

  export type DeviceGroupEntryMinAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
  }

  export type DeviceGroupEntryMaxAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
  }

  export type DeviceGroupEntryCountAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    image_id?: true
    is_internal?: true
    legacy_unique_key?: true
    _all?: true
  }

  export type DeviceGroupEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupEntry to aggregate.
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupEntries to fetch.
     */
    orderBy?: DeviceGroupEntryOrderByWithRelationInput | DeviceGroupEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceGroupEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceGroupEntries
    **/
    _count?: true | DeviceGroupEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceGroupEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceGroupEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceGroupEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceGroupEntryMaxAggregateInputType
  }

  export type GetDeviceGroupEntryAggregateType<T extends DeviceGroupEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceGroupEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceGroupEntry[P]>
      : GetScalarType<T[P], AggregateDeviceGroupEntry[P]>
  }




  export type DeviceGroupEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupEntryWhereInput
    orderBy?: DeviceGroupEntryOrderByWithAggregationInput | DeviceGroupEntryOrderByWithAggregationInput[]
    by: DeviceGroupEntryScalarFieldEnum[] | DeviceGroupEntryScalarFieldEnum
    having?: DeviceGroupEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceGroupEntryCountAggregateInputType | true
    _avg?: DeviceGroupEntryAvgAggregateInputType
    _sum?: DeviceGroupEntrySumAggregateInputType
    _min?: DeviceGroupEntryMinAggregateInputType
    _max?: DeviceGroupEntryMaxAggregateInputType
  }

  export type DeviceGroupEntryGroupByOutputType = {
    id: number
    name: string
    category_id: number | null
    image_id: number | null
    is_internal: boolean | null
    legacy_unique_key: string | null
    _count: DeviceGroupEntryCountAggregateOutputType | null
    _avg: DeviceGroupEntryAvgAggregateOutputType | null
    _sum: DeviceGroupEntrySumAggregateOutputType | null
    _min: DeviceGroupEntryMinAggregateOutputType | null
    _max: DeviceGroupEntryMaxAggregateOutputType | null
  }

  type GetDeviceGroupEntryGroupByPayload<T extends DeviceGroupEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupEntryGroupByOutputType[P]>
        }
      >
    >


  export type DeviceGroupEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
    DeviceGroupMapDevice?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceArgs<ExtArgs>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs>
    _count?: boolean | DeviceGroupEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupEntry"]>

  export type DeviceGroupEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
  }, ExtArgs["result"]["deviceGroupEntry"]>

  export type DeviceGroupEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
  }, ExtArgs["result"]["deviceGroupEntry"]>

  export type DeviceGroupEntrySelectScalar = {
    id?: boolean
    name?: boolean
    category_id?: boolean
    image_id?: boolean
    is_internal?: boolean
    legacy_unique_key?: boolean
  }

  export type DeviceGroupEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category_id" | "image_id" | "is_internal" | "legacy_unique_key", ExtArgs["result"]["deviceGroupEntry"]>
  export type DeviceGroupEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupMapDevice?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceArgs<ExtArgs>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs>
    _count?: boolean | DeviceGroupEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceGroupEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceGroupEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceGroupEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceGroupEntry"
    objects: {
      DeviceGroupMapDevice: Prisma.$DeviceGroupMapDevicePayload<ExtArgs>[]
      DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry: Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>[]
      DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry: Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category_id: number | null
      image_id: number | null
      is_internal: boolean | null
      legacy_unique_key: string | null
    }, ExtArgs["result"]["deviceGroupEntry"]>
    composites: {}
  }

  type DeviceGroupEntryGetPayload<S extends boolean | null | undefined | DeviceGroupEntryDefaultArgs> = $Result.GetResult<Prisma.$DeviceGroupEntryPayload, S>

  type DeviceGroupEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceGroupEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceGroupEntryCountAggregateInputType | true
    }

  export interface DeviceGroupEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceGroupEntry'], meta: { name: 'DeviceGroupEntry' } }
    /**
     * Find zero or one DeviceGroupEntry that matches the filter.
     * @param {DeviceGroupEntryFindUniqueArgs} args - Arguments to find a DeviceGroupEntry
     * @example
     * // Get one DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceGroupEntryFindUniqueArgs>(args: SelectSubset<T, DeviceGroupEntryFindUniqueArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceGroupEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceGroupEntryFindUniqueOrThrowArgs} args - Arguments to find a DeviceGroupEntry
     * @example
     * // Get one DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceGroupEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceGroupEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryFindFirstArgs} args - Arguments to find a DeviceGroupEntry
     * @example
     * // Get one DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceGroupEntryFindFirstArgs>(args?: SelectSubset<T, DeviceGroupEntryFindFirstArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryFindFirstOrThrowArgs} args - Arguments to find a DeviceGroupEntry
     * @example
     * // Get one DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceGroupEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceGroupEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceGroupEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceGroupEntries
     * const deviceGroupEntries = await prisma.deviceGroupEntry.findMany()
     * 
     * // Get first 10 DeviceGroupEntries
     * const deviceGroupEntries = await prisma.deviceGroupEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceGroupEntryWithIdOnly = await prisma.deviceGroupEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceGroupEntryFindManyArgs>(args?: SelectSubset<T, DeviceGroupEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceGroupEntry.
     * @param {DeviceGroupEntryCreateArgs} args - Arguments to create a DeviceGroupEntry.
     * @example
     * // Create one DeviceGroupEntry
     * const DeviceGroupEntry = await prisma.deviceGroupEntry.create({
     *   data: {
     *     // ... data to create a DeviceGroupEntry
     *   }
     * })
     * 
     */
    create<T extends DeviceGroupEntryCreateArgs>(args: SelectSubset<T, DeviceGroupEntryCreateArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceGroupEntries.
     * @param {DeviceGroupEntryCreateManyArgs} args - Arguments to create many DeviceGroupEntries.
     * @example
     * // Create many DeviceGroupEntries
     * const deviceGroupEntry = await prisma.deviceGroupEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceGroupEntryCreateManyArgs>(args?: SelectSubset<T, DeviceGroupEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceGroupEntries and returns the data saved in the database.
     * @param {DeviceGroupEntryCreateManyAndReturnArgs} args - Arguments to create many DeviceGroupEntries.
     * @example
     * // Create many DeviceGroupEntries
     * const deviceGroupEntry = await prisma.deviceGroupEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceGroupEntries and only return the `id`
     * const deviceGroupEntryWithIdOnly = await prisma.deviceGroupEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceGroupEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceGroupEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceGroupEntry.
     * @param {DeviceGroupEntryDeleteArgs} args - Arguments to delete one DeviceGroupEntry.
     * @example
     * // Delete one DeviceGroupEntry
     * const DeviceGroupEntry = await prisma.deviceGroupEntry.delete({
     *   where: {
     *     // ... filter to delete one DeviceGroupEntry
     *   }
     * })
     * 
     */
    delete<T extends DeviceGroupEntryDeleteArgs>(args: SelectSubset<T, DeviceGroupEntryDeleteArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceGroupEntry.
     * @param {DeviceGroupEntryUpdateArgs} args - Arguments to update one DeviceGroupEntry.
     * @example
     * // Update one DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceGroupEntryUpdateArgs>(args: SelectSubset<T, DeviceGroupEntryUpdateArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceGroupEntries.
     * @param {DeviceGroupEntryDeleteManyArgs} args - Arguments to filter DeviceGroupEntries to delete.
     * @example
     * // Delete a few DeviceGroupEntries
     * const { count } = await prisma.deviceGroupEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceGroupEntryDeleteManyArgs>(args?: SelectSubset<T, DeviceGroupEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceGroupEntries
     * const deviceGroupEntry = await prisma.deviceGroupEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceGroupEntryUpdateManyArgs>(args: SelectSubset<T, DeviceGroupEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupEntries and returns the data updated in the database.
     * @param {DeviceGroupEntryUpdateManyAndReturnArgs} args - Arguments to update many DeviceGroupEntries.
     * @example
     * // Update many DeviceGroupEntries
     * const deviceGroupEntry = await prisma.deviceGroupEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceGroupEntries and only return the `id`
     * const deviceGroupEntryWithIdOnly = await prisma.deviceGroupEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceGroupEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceGroupEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceGroupEntry.
     * @param {DeviceGroupEntryUpsertArgs} args - Arguments to update or create a DeviceGroupEntry.
     * @example
     * // Update or create a DeviceGroupEntry
     * const deviceGroupEntry = await prisma.deviceGroupEntry.upsert({
     *   create: {
     *     // ... data to create a DeviceGroupEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceGroupEntry we want to update
     *   }
     * })
     */
    upsert<T extends DeviceGroupEntryUpsertArgs>(args: SelectSubset<T, DeviceGroupEntryUpsertArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceGroupEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryCountArgs} args - Arguments to filter DeviceGroupEntries to count.
     * @example
     * // Count the number of DeviceGroupEntries
     * const count = await prisma.deviceGroupEntry.count({
     *   where: {
     *     // ... the filter for the DeviceGroupEntries we want to count
     *   }
     * })
    **/
    count<T extends DeviceGroupEntryCountArgs>(
      args?: Subset<T, DeviceGroupEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceGroupEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceGroupEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceGroupEntryAggregateArgs>(args: Subset<T, DeviceGroupEntryAggregateArgs>): Prisma.PrismaPromise<GetDeviceGroupEntryAggregateType<T>>

    /**
     * Group by DeviceGroupEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupEntryGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceGroupEntry model
   */
  readonly fields: DeviceGroupEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceGroupEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceGroupEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceGroupMapDevice<T extends DeviceGroupEntry$DeviceGroupMapDeviceArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntry$DeviceGroupMapDeviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry<T extends DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry<T extends DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceGroupEntry model
   */
  interface DeviceGroupEntryFieldRefs {
    readonly id: FieldRef<"DeviceGroupEntry", 'Int'>
    readonly name: FieldRef<"DeviceGroupEntry", 'String'>
    readonly category_id: FieldRef<"DeviceGroupEntry", 'Int'>
    readonly image_id: FieldRef<"DeviceGroupEntry", 'Int'>
    readonly is_internal: FieldRef<"DeviceGroupEntry", 'Boolean'>
    readonly legacy_unique_key: FieldRef<"DeviceGroupEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceGroupEntry findUnique
   */
  export type DeviceGroupEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupEntry to fetch.
     */
    where: DeviceGroupEntryWhereUniqueInput
  }

  /**
   * DeviceGroupEntry findUniqueOrThrow
   */
  export type DeviceGroupEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupEntry to fetch.
     */
    where: DeviceGroupEntryWhereUniqueInput
  }

  /**
   * DeviceGroupEntry findFirst
   */
  export type DeviceGroupEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupEntry to fetch.
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupEntries to fetch.
     */
    orderBy?: DeviceGroupEntryOrderByWithRelationInput | DeviceGroupEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupEntries.
     */
    cursor?: DeviceGroupEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupEntries.
     */
    distinct?: DeviceGroupEntryScalarFieldEnum | DeviceGroupEntryScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry findFirstOrThrow
   */
  export type DeviceGroupEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupEntry to fetch.
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupEntries to fetch.
     */
    orderBy?: DeviceGroupEntryOrderByWithRelationInput | DeviceGroupEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupEntries.
     */
    cursor?: DeviceGroupEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupEntries.
     */
    distinct?: DeviceGroupEntryScalarFieldEnum | DeviceGroupEntryScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry findMany
   */
  export type DeviceGroupEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupEntries to fetch.
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupEntries to fetch.
     */
    orderBy?: DeviceGroupEntryOrderByWithRelationInput | DeviceGroupEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceGroupEntries.
     */
    cursor?: DeviceGroupEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupEntries.
     */
    skip?: number
    distinct?: DeviceGroupEntryScalarFieldEnum | DeviceGroupEntryScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry create
   */
  export type DeviceGroupEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceGroupEntry.
     */
    data: XOR<DeviceGroupEntryCreateInput, DeviceGroupEntryUncheckedCreateInput>
  }

  /**
   * DeviceGroupEntry createMany
   */
  export type DeviceGroupEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceGroupEntries.
     */
    data: DeviceGroupEntryCreateManyInput | DeviceGroupEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceGroupEntry createManyAndReturn
   */
  export type DeviceGroupEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceGroupEntries.
     */
    data: DeviceGroupEntryCreateManyInput | DeviceGroupEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceGroupEntry update
   */
  export type DeviceGroupEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceGroupEntry.
     */
    data: XOR<DeviceGroupEntryUpdateInput, DeviceGroupEntryUncheckedUpdateInput>
    /**
     * Choose, which DeviceGroupEntry to update.
     */
    where: DeviceGroupEntryWhereUniqueInput
  }

  /**
   * DeviceGroupEntry updateMany
   */
  export type DeviceGroupEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceGroupEntries.
     */
    data: XOR<DeviceGroupEntryUpdateManyMutationInput, DeviceGroupEntryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupEntries to update
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * Limit how many DeviceGroupEntries to update.
     */
    limit?: number
  }

  /**
   * DeviceGroupEntry updateManyAndReturn
   */
  export type DeviceGroupEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * The data used to update DeviceGroupEntries.
     */
    data: XOR<DeviceGroupEntryUpdateManyMutationInput, DeviceGroupEntryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupEntries to update
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * Limit how many DeviceGroupEntries to update.
     */
    limit?: number
  }

  /**
   * DeviceGroupEntry upsert
   */
  export type DeviceGroupEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceGroupEntry to update in case it exists.
     */
    where: DeviceGroupEntryWhereUniqueInput
    /**
     * In case the DeviceGroupEntry found by the `where` argument doesn't exist, create a new DeviceGroupEntry with this data.
     */
    create: XOR<DeviceGroupEntryCreateInput, DeviceGroupEntryUncheckedCreateInput>
    /**
     * In case the DeviceGroupEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceGroupEntryUpdateInput, DeviceGroupEntryUncheckedUpdateInput>
  }

  /**
   * DeviceGroupEntry delete
   */
  export type DeviceGroupEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
    /**
     * Filter which DeviceGroupEntry to delete.
     */
    where: DeviceGroupEntryWhereUniqueInput
  }

  /**
   * DeviceGroupEntry deleteMany
   */
  export type DeviceGroupEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupEntries to delete
     */
    where?: DeviceGroupEntryWhereInput
    /**
     * Limit how many DeviceGroupEntries to delete.
     */
    limit?: number
  }

  /**
   * DeviceGroupEntry.DeviceGroupMapDevice
   */
  export type DeviceGroupEntry$DeviceGroupMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    where?: DeviceGroupMapDeviceWhereInput
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupMapDeviceScalarFieldEnum | DeviceGroupMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry.DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry
   */
  export type DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    where?: DeviceGroupMapDeviceGroupWhereInput
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupMapDeviceGroupScalarFieldEnum | DeviceGroupMapDeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry.DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry
   */
  export type DeviceGroupEntry$DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    where?: DeviceGroupMapDeviceGroupWhereInput
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceGroupMapDeviceGroupScalarFieldEnum | DeviceGroupMapDeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroupEntry without action
   */
  export type DeviceGroupEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupEntry
     */
    select?: DeviceGroupEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupEntry
     */
    omit?: DeviceGroupEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupEntryInclude<ExtArgs> | null
  }


  /**
   * Model DeviceGroupMapDevice
   */

  export type AggregateDeviceGroupMapDevice = {
    _count: DeviceGroupMapDeviceCountAggregateOutputType | null
    _avg: DeviceGroupMapDeviceAvgAggregateOutputType | null
    _sum: DeviceGroupMapDeviceSumAggregateOutputType | null
    _min: DeviceGroupMapDeviceMinAggregateOutputType | null
    _max: DeviceGroupMapDeviceMaxAggregateOutputType | null
  }

  export type DeviceGroupMapDeviceAvgAggregateOutputType = {
    group_id: number | null
    device_id: number | null
  }

  export type DeviceGroupMapDeviceSumAggregateOutputType = {
    group_id: number | null
    device_id: number | null
  }

  export type DeviceGroupMapDeviceMinAggregateOutputType = {
    group_id: number | null
    device_id: number | null
  }

  export type DeviceGroupMapDeviceMaxAggregateOutputType = {
    group_id: number | null
    device_id: number | null
  }

  export type DeviceGroupMapDeviceCountAggregateOutputType = {
    group_id: number
    device_id: number
    _all: number
  }


  export type DeviceGroupMapDeviceAvgAggregateInputType = {
    group_id?: true
    device_id?: true
  }

  export type DeviceGroupMapDeviceSumAggregateInputType = {
    group_id?: true
    device_id?: true
  }

  export type DeviceGroupMapDeviceMinAggregateInputType = {
    group_id?: true
    device_id?: true
  }

  export type DeviceGroupMapDeviceMaxAggregateInputType = {
    group_id?: true
    device_id?: true
  }

  export type DeviceGroupMapDeviceCountAggregateInputType = {
    group_id?: true
    device_id?: true
    _all?: true
  }

  export type DeviceGroupMapDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupMapDevice to aggregate.
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDevices to fetch.
     */
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceGroupMapDevices
    **/
    _count?: true | DeviceGroupMapDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceGroupMapDeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceGroupMapDeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceGroupMapDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceGroupMapDeviceMaxAggregateInputType
  }

  export type GetDeviceGroupMapDeviceAggregateType<T extends DeviceGroupMapDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceGroupMapDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceGroupMapDevice[P]>
      : GetScalarType<T[P], AggregateDeviceGroupMapDevice[P]>
  }




  export type DeviceGroupMapDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceWhereInput
    orderBy?: DeviceGroupMapDeviceOrderByWithAggregationInput | DeviceGroupMapDeviceOrderByWithAggregationInput[]
    by: DeviceGroupMapDeviceScalarFieldEnum[] | DeviceGroupMapDeviceScalarFieldEnum
    having?: DeviceGroupMapDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceGroupMapDeviceCountAggregateInputType | true
    _avg?: DeviceGroupMapDeviceAvgAggregateInputType
    _sum?: DeviceGroupMapDeviceSumAggregateInputType
    _min?: DeviceGroupMapDeviceMinAggregateInputType
    _max?: DeviceGroupMapDeviceMaxAggregateInputType
  }

  export type DeviceGroupMapDeviceGroupByOutputType = {
    group_id: number
    device_id: number
    _count: DeviceGroupMapDeviceCountAggregateOutputType | null
    _avg: DeviceGroupMapDeviceAvgAggregateOutputType | null
    _sum: DeviceGroupMapDeviceSumAggregateOutputType | null
    _min: DeviceGroupMapDeviceMinAggregateOutputType | null
    _max: DeviceGroupMapDeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupMapDeviceGroupByPayload<T extends DeviceGroupMapDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupMapDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupMapDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupMapDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupMapDeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceGroupMapDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    device_id?: boolean
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDevice"]>

  export type DeviceGroupMapDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    device_id?: boolean
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDevice"]>

  export type DeviceGroupMapDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    group_id?: boolean
    device_id?: boolean
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDevice"]>

  export type DeviceGroupMapDeviceSelectScalar = {
    group_id?: boolean
    device_id?: boolean
  }

  export type DeviceGroupMapDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"group_id" | "device_id", ExtArgs["result"]["deviceGroupMapDevice"]>
  export type DeviceGroupMapDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceGroupMapDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceGroupMapDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }

  export type $DeviceGroupMapDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceGroupMapDevice"
    objects: {
      DeviceGroupEntry: Prisma.$DeviceGroupEntryPayload<ExtArgs>
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      group_id: number
      device_id: number
    }, ExtArgs["result"]["deviceGroupMapDevice"]>
    composites: {}
  }

  type DeviceGroupMapDeviceGetPayload<S extends boolean | null | undefined | DeviceGroupMapDeviceDefaultArgs> = $Result.GetResult<Prisma.$DeviceGroupMapDevicePayload, S>

  type DeviceGroupMapDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceGroupMapDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceGroupMapDeviceCountAggregateInputType | true
    }

  export interface DeviceGroupMapDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceGroupMapDevice'], meta: { name: 'DeviceGroupMapDevice' } }
    /**
     * Find zero or one DeviceGroupMapDevice that matches the filter.
     * @param {DeviceGroupMapDeviceFindUniqueArgs} args - Arguments to find a DeviceGroupMapDevice
     * @example
     * // Get one DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceGroupMapDeviceFindUniqueArgs>(args: SelectSubset<T, DeviceGroupMapDeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceGroupMapDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceGroupMapDeviceFindUniqueOrThrowArgs} args - Arguments to find a DeviceGroupMapDevice
     * @example
     * // Get one DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceGroupMapDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceGroupMapDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupMapDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceFindFirstArgs} args - Arguments to find a DeviceGroupMapDevice
     * @example
     * // Get one DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceGroupMapDeviceFindFirstArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupMapDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceFindFirstOrThrowArgs} args - Arguments to find a DeviceGroupMapDevice
     * @example
     * // Get one DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceGroupMapDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceGroupMapDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceGroupMapDevices
     * const deviceGroupMapDevices = await prisma.deviceGroupMapDevice.findMany()
     * 
     * // Get first 10 DeviceGroupMapDevices
     * const deviceGroupMapDevices = await prisma.deviceGroupMapDevice.findMany({ take: 10 })
     * 
     * // Only select the `group_id`
     * const deviceGroupMapDeviceWithGroup_idOnly = await prisma.deviceGroupMapDevice.findMany({ select: { group_id: true } })
     * 
     */
    findMany<T extends DeviceGroupMapDeviceFindManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceGroupMapDevice.
     * @param {DeviceGroupMapDeviceCreateArgs} args - Arguments to create a DeviceGroupMapDevice.
     * @example
     * // Create one DeviceGroupMapDevice
     * const DeviceGroupMapDevice = await prisma.deviceGroupMapDevice.create({
     *   data: {
     *     // ... data to create a DeviceGroupMapDevice
     *   }
     * })
     * 
     */
    create<T extends DeviceGroupMapDeviceCreateArgs>(args: SelectSubset<T, DeviceGroupMapDeviceCreateArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceGroupMapDevices.
     * @param {DeviceGroupMapDeviceCreateManyArgs} args - Arguments to create many DeviceGroupMapDevices.
     * @example
     * // Create many DeviceGroupMapDevices
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceGroupMapDeviceCreateManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceGroupMapDevices and returns the data saved in the database.
     * @param {DeviceGroupMapDeviceCreateManyAndReturnArgs} args - Arguments to create many DeviceGroupMapDevices.
     * @example
     * // Create many DeviceGroupMapDevices
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceGroupMapDevices and only return the `group_id`
     * const deviceGroupMapDeviceWithGroup_idOnly = await prisma.deviceGroupMapDevice.createManyAndReturn({
     *   select: { group_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceGroupMapDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceGroupMapDevice.
     * @param {DeviceGroupMapDeviceDeleteArgs} args - Arguments to delete one DeviceGroupMapDevice.
     * @example
     * // Delete one DeviceGroupMapDevice
     * const DeviceGroupMapDevice = await prisma.deviceGroupMapDevice.delete({
     *   where: {
     *     // ... filter to delete one DeviceGroupMapDevice
     *   }
     * })
     * 
     */
    delete<T extends DeviceGroupMapDeviceDeleteArgs>(args: SelectSubset<T, DeviceGroupMapDeviceDeleteArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceGroupMapDevice.
     * @param {DeviceGroupMapDeviceUpdateArgs} args - Arguments to update one DeviceGroupMapDevice.
     * @example
     * // Update one DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceGroupMapDeviceUpdateArgs>(args: SelectSubset<T, DeviceGroupMapDeviceUpdateArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceGroupMapDevices.
     * @param {DeviceGroupMapDeviceDeleteManyArgs} args - Arguments to filter DeviceGroupMapDevices to delete.
     * @example
     * // Delete a few DeviceGroupMapDevices
     * const { count } = await prisma.deviceGroupMapDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceGroupMapDeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupMapDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceGroupMapDevices
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceGroupMapDeviceUpdateManyArgs>(args: SelectSubset<T, DeviceGroupMapDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupMapDevices and returns the data updated in the database.
     * @param {DeviceGroupMapDeviceUpdateManyAndReturnArgs} args - Arguments to update many DeviceGroupMapDevices.
     * @example
     * // Update many DeviceGroupMapDevices
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceGroupMapDevices and only return the `group_id`
     * const deviceGroupMapDeviceWithGroup_idOnly = await prisma.deviceGroupMapDevice.updateManyAndReturn({
     *   select: { group_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceGroupMapDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceGroupMapDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceGroupMapDevice.
     * @param {DeviceGroupMapDeviceUpsertArgs} args - Arguments to update or create a DeviceGroupMapDevice.
     * @example
     * // Update or create a DeviceGroupMapDevice
     * const deviceGroupMapDevice = await prisma.deviceGroupMapDevice.upsert({
     *   create: {
     *     // ... data to create a DeviceGroupMapDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceGroupMapDevice we want to update
     *   }
     * })
     */
    upsert<T extends DeviceGroupMapDeviceUpsertArgs>(args: SelectSubset<T, DeviceGroupMapDeviceUpsertArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceClient<$Result.GetResult<Prisma.$DeviceGroupMapDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceGroupMapDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceCountArgs} args - Arguments to filter DeviceGroupMapDevices to count.
     * @example
     * // Count the number of DeviceGroupMapDevices
     * const count = await prisma.deviceGroupMapDevice.count({
     *   where: {
     *     // ... the filter for the DeviceGroupMapDevices we want to count
     *   }
     * })
    **/
    count<T extends DeviceGroupMapDeviceCountArgs>(
      args?: Subset<T, DeviceGroupMapDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceGroupMapDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceGroupMapDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceGroupMapDeviceAggregateArgs>(args: Subset<T, DeviceGroupMapDeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceGroupMapDeviceAggregateType<T>>

    /**
     * Group by DeviceGroupMapDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupMapDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupMapDeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupMapDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupMapDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupMapDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceGroupMapDevice model
   */
  readonly fields: DeviceGroupMapDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceGroupMapDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceGroupMapDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceGroupEntry<T extends DeviceGroupEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntryDefaultArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceGroupMapDevice model
   */
  interface DeviceGroupMapDeviceFieldRefs {
    readonly group_id: FieldRef<"DeviceGroupMapDevice", 'Int'>
    readonly device_id: FieldRef<"DeviceGroupMapDevice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceGroupMapDevice findUnique
   */
  export type DeviceGroupMapDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDevice to fetch.
     */
    where: DeviceGroupMapDeviceWhereUniqueInput
  }

  /**
   * DeviceGroupMapDevice findUniqueOrThrow
   */
  export type DeviceGroupMapDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDevice to fetch.
     */
    where: DeviceGroupMapDeviceWhereUniqueInput
  }

  /**
   * DeviceGroupMapDevice findFirst
   */
  export type DeviceGroupMapDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDevice to fetch.
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDevices to fetch.
     */
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupMapDevices.
     */
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupMapDevices.
     */
    distinct?: DeviceGroupMapDeviceScalarFieldEnum | DeviceGroupMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDevice findFirstOrThrow
   */
  export type DeviceGroupMapDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDevice to fetch.
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDevices to fetch.
     */
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupMapDevices.
     */
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupMapDevices.
     */
    distinct?: DeviceGroupMapDeviceScalarFieldEnum | DeviceGroupMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDevice findMany
   */
  export type DeviceGroupMapDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDevices to fetch.
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDevices to fetch.
     */
    orderBy?: DeviceGroupMapDeviceOrderByWithRelationInput | DeviceGroupMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceGroupMapDevices.
     */
    cursor?: DeviceGroupMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDevices.
     */
    skip?: number
    distinct?: DeviceGroupMapDeviceScalarFieldEnum | DeviceGroupMapDeviceScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDevice create
   */
  export type DeviceGroupMapDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceGroupMapDevice.
     */
    data: XOR<DeviceGroupMapDeviceCreateInput, DeviceGroupMapDeviceUncheckedCreateInput>
  }

  /**
   * DeviceGroupMapDevice createMany
   */
  export type DeviceGroupMapDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceGroupMapDevices.
     */
    data: DeviceGroupMapDeviceCreateManyInput | DeviceGroupMapDeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceGroupMapDevice createManyAndReturn
   */
  export type DeviceGroupMapDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceGroupMapDevices.
     */
    data: DeviceGroupMapDeviceCreateManyInput | DeviceGroupMapDeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceGroupMapDevice update
   */
  export type DeviceGroupMapDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceGroupMapDevice.
     */
    data: XOR<DeviceGroupMapDeviceUpdateInput, DeviceGroupMapDeviceUncheckedUpdateInput>
    /**
     * Choose, which DeviceGroupMapDevice to update.
     */
    where: DeviceGroupMapDeviceWhereUniqueInput
  }

  /**
   * DeviceGroupMapDevice updateMany
   */
  export type DeviceGroupMapDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceGroupMapDevices.
     */
    data: XOR<DeviceGroupMapDeviceUpdateManyMutationInput, DeviceGroupMapDeviceUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupMapDevices to update
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * Limit how many DeviceGroupMapDevices to update.
     */
    limit?: number
  }

  /**
   * DeviceGroupMapDevice updateManyAndReturn
   */
  export type DeviceGroupMapDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * The data used to update DeviceGroupMapDevices.
     */
    data: XOR<DeviceGroupMapDeviceUpdateManyMutationInput, DeviceGroupMapDeviceUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupMapDevices to update
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * Limit how many DeviceGroupMapDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceGroupMapDevice upsert
   */
  export type DeviceGroupMapDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceGroupMapDevice to update in case it exists.
     */
    where: DeviceGroupMapDeviceWhereUniqueInput
    /**
     * In case the DeviceGroupMapDevice found by the `where` argument doesn't exist, create a new DeviceGroupMapDevice with this data.
     */
    create: XOR<DeviceGroupMapDeviceCreateInput, DeviceGroupMapDeviceUncheckedCreateInput>
    /**
     * In case the DeviceGroupMapDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceGroupMapDeviceUpdateInput, DeviceGroupMapDeviceUncheckedUpdateInput>
  }

  /**
   * DeviceGroupMapDevice delete
   */
  export type DeviceGroupMapDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
    /**
     * Filter which DeviceGroupMapDevice to delete.
     */
    where: DeviceGroupMapDeviceWhereUniqueInput
  }

  /**
   * DeviceGroupMapDevice deleteMany
   */
  export type DeviceGroupMapDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupMapDevices to delete
     */
    where?: DeviceGroupMapDeviceWhereInput
    /**
     * Limit how many DeviceGroupMapDevices to delete.
     */
    limit?: number
  }

  /**
   * DeviceGroupMapDevice without action
   */
  export type DeviceGroupMapDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDevice
     */
    select?: DeviceGroupMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDevice
     */
    omit?: DeviceGroupMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceInclude<ExtArgs> | null
  }


  /**
   * Model DeviceGroupMapDeviceGroup
   */

  export type AggregateDeviceGroupMapDeviceGroup = {
    _count: DeviceGroupMapDeviceGroupCountAggregateOutputType | null
    _avg: DeviceGroupMapDeviceGroupAvgAggregateOutputType | null
    _sum: DeviceGroupMapDeviceGroupSumAggregateOutputType | null
    _min: DeviceGroupMapDeviceGroupMinAggregateOutputType | null
    _max: DeviceGroupMapDeviceGroupMaxAggregateOutputType | null
  }

  export type DeviceGroupMapDeviceGroupAvgAggregateOutputType = {
    parent_group_id: number | null
    child_group_id: number | null
  }

  export type DeviceGroupMapDeviceGroupSumAggregateOutputType = {
    parent_group_id: number | null
    child_group_id: number | null
  }

  export type DeviceGroupMapDeviceGroupMinAggregateOutputType = {
    parent_group_id: number | null
    child_group_id: number | null
  }

  export type DeviceGroupMapDeviceGroupMaxAggregateOutputType = {
    parent_group_id: number | null
    child_group_id: number | null
  }

  export type DeviceGroupMapDeviceGroupCountAggregateOutputType = {
    parent_group_id: number
    child_group_id: number
    _all: number
  }


  export type DeviceGroupMapDeviceGroupAvgAggregateInputType = {
    parent_group_id?: true
    child_group_id?: true
  }

  export type DeviceGroupMapDeviceGroupSumAggregateInputType = {
    parent_group_id?: true
    child_group_id?: true
  }

  export type DeviceGroupMapDeviceGroupMinAggregateInputType = {
    parent_group_id?: true
    child_group_id?: true
  }

  export type DeviceGroupMapDeviceGroupMaxAggregateInputType = {
    parent_group_id?: true
    child_group_id?: true
  }

  export type DeviceGroupMapDeviceGroupCountAggregateInputType = {
    parent_group_id?: true
    child_group_id?: true
    _all?: true
  }

  export type DeviceGroupMapDeviceGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupMapDeviceGroup to aggregate.
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDeviceGroups to fetch.
     */
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceGroupMapDeviceGroups
    **/
    _count?: true | DeviceGroupMapDeviceGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceGroupMapDeviceGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceGroupMapDeviceGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceGroupMapDeviceGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceGroupMapDeviceGroupMaxAggregateInputType
  }

  export type GetDeviceGroupMapDeviceGroupAggregateType<T extends DeviceGroupMapDeviceGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceGroupMapDeviceGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceGroupMapDeviceGroup[P]>
      : GetScalarType<T[P], AggregateDeviceGroupMapDeviceGroup[P]>
  }




  export type DeviceGroupMapDeviceGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceGroupMapDeviceGroupWhereInput
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithAggregationInput | DeviceGroupMapDeviceGroupOrderByWithAggregationInput[]
    by: DeviceGroupMapDeviceGroupScalarFieldEnum[] | DeviceGroupMapDeviceGroupScalarFieldEnum
    having?: DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceGroupMapDeviceGroupCountAggregateInputType | true
    _avg?: DeviceGroupMapDeviceGroupAvgAggregateInputType
    _sum?: DeviceGroupMapDeviceGroupSumAggregateInputType
    _min?: DeviceGroupMapDeviceGroupMinAggregateInputType
    _max?: DeviceGroupMapDeviceGroupMaxAggregateInputType
  }

  export type DeviceGroupMapDeviceGroupGroupByOutputType = {
    parent_group_id: number
    child_group_id: number
    _count: DeviceGroupMapDeviceGroupCountAggregateOutputType | null
    _avg: DeviceGroupMapDeviceGroupAvgAggregateOutputType | null
    _sum: DeviceGroupMapDeviceGroupSumAggregateOutputType | null
    _min: DeviceGroupMapDeviceGroupMinAggregateOutputType | null
    _max: DeviceGroupMapDeviceGroupMaxAggregateOutputType | null
  }

  type GetDeviceGroupMapDeviceGroupGroupByPayload<T extends DeviceGroupMapDeviceGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupMapDeviceGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupMapDeviceGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupMapDeviceGroupGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupMapDeviceGroupGroupByOutputType[P]>
        }
      >
    >


  export type DeviceGroupMapDeviceGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parent_group_id?: boolean
    child_group_id?: boolean
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDeviceGroup"]>

  export type DeviceGroupMapDeviceGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parent_group_id?: boolean
    child_group_id?: boolean
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDeviceGroup"]>

  export type DeviceGroupMapDeviceGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parent_group_id?: boolean
    child_group_id?: boolean
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceGroupMapDeviceGroup"]>

  export type DeviceGroupMapDeviceGroupSelectScalar = {
    parent_group_id?: boolean
    child_group_id?: boolean
  }

  export type DeviceGroupMapDeviceGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parent_group_id" | "child_group_id", ExtArgs["result"]["deviceGroupMapDeviceGroup"]>
  export type DeviceGroupMapDeviceGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }
  export type DeviceGroupMapDeviceGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }
  export type DeviceGroupMapDeviceGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: boolean | DeviceGroupEntryDefaultArgs<ExtArgs>
  }

  export type $DeviceGroupMapDeviceGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceGroupMapDeviceGroup"
    objects: {
      DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry: Prisma.$DeviceGroupEntryPayload<ExtArgs>
      DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry: Prisma.$DeviceGroupEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      parent_group_id: number
      child_group_id: number
    }, ExtArgs["result"]["deviceGroupMapDeviceGroup"]>
    composites: {}
  }

  type DeviceGroupMapDeviceGroupGetPayload<S extends boolean | null | undefined | DeviceGroupMapDeviceGroupDefaultArgs> = $Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload, S>

  type DeviceGroupMapDeviceGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceGroupMapDeviceGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceGroupMapDeviceGroupCountAggregateInputType | true
    }

  export interface DeviceGroupMapDeviceGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceGroupMapDeviceGroup'], meta: { name: 'DeviceGroupMapDeviceGroup' } }
    /**
     * Find zero or one DeviceGroupMapDeviceGroup that matches the filter.
     * @param {DeviceGroupMapDeviceGroupFindUniqueArgs} args - Arguments to find a DeviceGroupMapDeviceGroup
     * @example
     * // Get one DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceGroupMapDeviceGroupFindUniqueArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupFindUniqueArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceGroupMapDeviceGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceGroupMapDeviceGroupFindUniqueOrThrowArgs} args - Arguments to find a DeviceGroupMapDeviceGroup
     * @example
     * // Get one DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceGroupMapDeviceGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupMapDeviceGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupFindFirstArgs} args - Arguments to find a DeviceGroupMapDeviceGroup
     * @example
     * // Get one DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceGroupMapDeviceGroupFindFirstArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupFindFirstArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceGroupMapDeviceGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupFindFirstOrThrowArgs} args - Arguments to find a DeviceGroupMapDeviceGroup
     * @example
     * // Get one DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceGroupMapDeviceGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceGroupMapDeviceGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroups = await prisma.deviceGroupMapDeviceGroup.findMany()
     * 
     * // Get first 10 DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroups = await prisma.deviceGroupMapDeviceGroup.findMany({ take: 10 })
     * 
     * // Only select the `parent_group_id`
     * const deviceGroupMapDeviceGroupWithParent_group_idOnly = await prisma.deviceGroupMapDeviceGroup.findMany({ select: { parent_group_id: true } })
     * 
     */
    findMany<T extends DeviceGroupMapDeviceGroupFindManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceGroupMapDeviceGroup.
     * @param {DeviceGroupMapDeviceGroupCreateArgs} args - Arguments to create a DeviceGroupMapDeviceGroup.
     * @example
     * // Create one DeviceGroupMapDeviceGroup
     * const DeviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.create({
     *   data: {
     *     // ... data to create a DeviceGroupMapDeviceGroup
     *   }
     * })
     * 
     */
    create<T extends DeviceGroupMapDeviceGroupCreateArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupCreateArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceGroupMapDeviceGroups.
     * @param {DeviceGroupMapDeviceGroupCreateManyArgs} args - Arguments to create many DeviceGroupMapDeviceGroups.
     * @example
     * // Create many DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceGroupMapDeviceGroupCreateManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceGroupMapDeviceGroups and returns the data saved in the database.
     * @param {DeviceGroupMapDeviceGroupCreateManyAndReturnArgs} args - Arguments to create many DeviceGroupMapDeviceGroups.
     * @example
     * // Create many DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceGroupMapDeviceGroups and only return the `parent_group_id`
     * const deviceGroupMapDeviceGroupWithParent_group_idOnly = await prisma.deviceGroupMapDeviceGroup.createManyAndReturn({
     *   select: { parent_group_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceGroupMapDeviceGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceGroupMapDeviceGroup.
     * @param {DeviceGroupMapDeviceGroupDeleteArgs} args - Arguments to delete one DeviceGroupMapDeviceGroup.
     * @example
     * // Delete one DeviceGroupMapDeviceGroup
     * const DeviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.delete({
     *   where: {
     *     // ... filter to delete one DeviceGroupMapDeviceGroup
     *   }
     * })
     * 
     */
    delete<T extends DeviceGroupMapDeviceGroupDeleteArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupDeleteArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceGroupMapDeviceGroup.
     * @param {DeviceGroupMapDeviceGroupUpdateArgs} args - Arguments to update one DeviceGroupMapDeviceGroup.
     * @example
     * // Update one DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceGroupMapDeviceGroupUpdateArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupUpdateArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceGroupMapDeviceGroups.
     * @param {DeviceGroupMapDeviceGroupDeleteManyArgs} args - Arguments to filter DeviceGroupMapDeviceGroups to delete.
     * @example
     * // Delete a few DeviceGroupMapDeviceGroups
     * const { count } = await prisma.deviceGroupMapDeviceGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceGroupMapDeviceGroupDeleteManyArgs>(args?: SelectSubset<T, DeviceGroupMapDeviceGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupMapDeviceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceGroupMapDeviceGroupUpdateManyArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceGroupMapDeviceGroups and returns the data updated in the database.
     * @param {DeviceGroupMapDeviceGroupUpdateManyAndReturnArgs} args - Arguments to update many DeviceGroupMapDeviceGroups.
     * @example
     * // Update many DeviceGroupMapDeviceGroups
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceGroupMapDeviceGroups and only return the `parent_group_id`
     * const deviceGroupMapDeviceGroupWithParent_group_idOnly = await prisma.deviceGroupMapDeviceGroup.updateManyAndReturn({
     *   select: { parent_group_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceGroupMapDeviceGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceGroupMapDeviceGroup.
     * @param {DeviceGroupMapDeviceGroupUpsertArgs} args - Arguments to update or create a DeviceGroupMapDeviceGroup.
     * @example
     * // Update or create a DeviceGroupMapDeviceGroup
     * const deviceGroupMapDeviceGroup = await prisma.deviceGroupMapDeviceGroup.upsert({
     *   create: {
     *     // ... data to create a DeviceGroupMapDeviceGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceGroupMapDeviceGroup we want to update
     *   }
     * })
     */
    upsert<T extends DeviceGroupMapDeviceGroupUpsertArgs>(args: SelectSubset<T, DeviceGroupMapDeviceGroupUpsertArgs<ExtArgs>>): Prisma__DeviceGroupMapDeviceGroupClient<$Result.GetResult<Prisma.$DeviceGroupMapDeviceGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceGroupMapDeviceGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupCountArgs} args - Arguments to filter DeviceGroupMapDeviceGroups to count.
     * @example
     * // Count the number of DeviceGroupMapDeviceGroups
     * const count = await prisma.deviceGroupMapDeviceGroup.count({
     *   where: {
     *     // ... the filter for the DeviceGroupMapDeviceGroups we want to count
     *   }
     * })
    **/
    count<T extends DeviceGroupMapDeviceGroupCountArgs>(
      args?: Subset<T, DeviceGroupMapDeviceGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceGroupMapDeviceGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceGroupMapDeviceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceGroupMapDeviceGroupAggregateArgs>(args: Subset<T, DeviceGroupMapDeviceGroupAggregateArgs>): Prisma.PrismaPromise<GetDeviceGroupMapDeviceGroupAggregateType<T>>

    /**
     * Group by DeviceGroupMapDeviceGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupMapDeviceGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupMapDeviceGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupMapDeviceGroupGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupMapDeviceGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupMapDeviceGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupMapDeviceGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceGroupMapDeviceGroup model
   */
  readonly fields: DeviceGroupMapDeviceGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceGroupMapDeviceGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceGroupMapDeviceGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry<T extends DeviceGroupEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntryDefaultArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry<T extends DeviceGroupEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceGroupEntryDefaultArgs<ExtArgs>>): Prisma__DeviceGroupEntryClient<$Result.GetResult<Prisma.$DeviceGroupEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceGroupMapDeviceGroup model
   */
  interface DeviceGroupMapDeviceGroupFieldRefs {
    readonly parent_group_id: FieldRef<"DeviceGroupMapDeviceGroup", 'Int'>
    readonly child_group_id: FieldRef<"DeviceGroupMapDeviceGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceGroupMapDeviceGroup findUnique
   */
  export type DeviceGroupMapDeviceGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDeviceGroup to fetch.
     */
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroupMapDeviceGroup findUniqueOrThrow
   */
  export type DeviceGroupMapDeviceGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDeviceGroup to fetch.
     */
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroupMapDeviceGroup findFirst
   */
  export type DeviceGroupMapDeviceGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDeviceGroup to fetch.
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDeviceGroups to fetch.
     */
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupMapDeviceGroups.
     */
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupMapDeviceGroups.
     */
    distinct?: DeviceGroupMapDeviceGroupScalarFieldEnum | DeviceGroupMapDeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDeviceGroup findFirstOrThrow
   */
  export type DeviceGroupMapDeviceGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDeviceGroup to fetch.
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDeviceGroups to fetch.
     */
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceGroupMapDeviceGroups.
     */
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDeviceGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceGroupMapDeviceGroups.
     */
    distinct?: DeviceGroupMapDeviceGroupScalarFieldEnum | DeviceGroupMapDeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDeviceGroup findMany
   */
  export type DeviceGroupMapDeviceGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter, which DeviceGroupMapDeviceGroups to fetch.
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceGroupMapDeviceGroups to fetch.
     */
    orderBy?: DeviceGroupMapDeviceGroupOrderByWithRelationInput | DeviceGroupMapDeviceGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceGroupMapDeviceGroups.
     */
    cursor?: DeviceGroupMapDeviceGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceGroupMapDeviceGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceGroupMapDeviceGroups.
     */
    skip?: number
    distinct?: DeviceGroupMapDeviceGroupScalarFieldEnum | DeviceGroupMapDeviceGroupScalarFieldEnum[]
  }

  /**
   * DeviceGroupMapDeviceGroup create
   */
  export type DeviceGroupMapDeviceGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceGroupMapDeviceGroup.
     */
    data: XOR<DeviceGroupMapDeviceGroupCreateInput, DeviceGroupMapDeviceGroupUncheckedCreateInput>
  }

  /**
   * DeviceGroupMapDeviceGroup createMany
   */
  export type DeviceGroupMapDeviceGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceGroupMapDeviceGroups.
     */
    data: DeviceGroupMapDeviceGroupCreateManyInput | DeviceGroupMapDeviceGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceGroupMapDeviceGroup createManyAndReturn
   */
  export type DeviceGroupMapDeviceGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceGroupMapDeviceGroups.
     */
    data: DeviceGroupMapDeviceGroupCreateManyInput | DeviceGroupMapDeviceGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceGroupMapDeviceGroup update
   */
  export type DeviceGroupMapDeviceGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceGroupMapDeviceGroup.
     */
    data: XOR<DeviceGroupMapDeviceGroupUpdateInput, DeviceGroupMapDeviceGroupUncheckedUpdateInput>
    /**
     * Choose, which DeviceGroupMapDeviceGroup to update.
     */
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroupMapDeviceGroup updateMany
   */
  export type DeviceGroupMapDeviceGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceGroupMapDeviceGroups.
     */
    data: XOR<DeviceGroupMapDeviceGroupUpdateManyMutationInput, DeviceGroupMapDeviceGroupUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupMapDeviceGroups to update
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * Limit how many DeviceGroupMapDeviceGroups to update.
     */
    limit?: number
  }

  /**
   * DeviceGroupMapDeviceGroup updateManyAndReturn
   */
  export type DeviceGroupMapDeviceGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * The data used to update DeviceGroupMapDeviceGroups.
     */
    data: XOR<DeviceGroupMapDeviceGroupUpdateManyMutationInput, DeviceGroupMapDeviceGroupUncheckedUpdateManyInput>
    /**
     * Filter which DeviceGroupMapDeviceGroups to update
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * Limit how many DeviceGroupMapDeviceGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceGroupMapDeviceGroup upsert
   */
  export type DeviceGroupMapDeviceGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceGroupMapDeviceGroup to update in case it exists.
     */
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    /**
     * In case the DeviceGroupMapDeviceGroup found by the `where` argument doesn't exist, create a new DeviceGroupMapDeviceGroup with this data.
     */
    create: XOR<DeviceGroupMapDeviceGroupCreateInput, DeviceGroupMapDeviceGroupUncheckedCreateInput>
    /**
     * In case the DeviceGroupMapDeviceGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceGroupMapDeviceGroupUpdateInput, DeviceGroupMapDeviceGroupUncheckedUpdateInput>
  }

  /**
   * DeviceGroupMapDeviceGroup delete
   */
  export type DeviceGroupMapDeviceGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
    /**
     * Filter which DeviceGroupMapDeviceGroup to delete.
     */
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
  }

  /**
   * DeviceGroupMapDeviceGroup deleteMany
   */
  export type DeviceGroupMapDeviceGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceGroupMapDeviceGroups to delete
     */
    where?: DeviceGroupMapDeviceGroupWhereInput
    /**
     * Limit how many DeviceGroupMapDeviceGroups to delete.
     */
    limit?: number
  }

  /**
   * DeviceGroupMapDeviceGroup without action
   */
  export type DeviceGroupMapDeviceGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceGroupMapDeviceGroup
     */
    select?: DeviceGroupMapDeviceGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceGroupMapDeviceGroup
     */
    omit?: DeviceGroupMapDeviceGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceGroupMapDeviceGroupInclude<ExtArgs> | null
  }


  /**
   * Model DeviceImageColors
   */

  export type AggregateDeviceImageColors = {
    _count: DeviceImageColorsCountAggregateOutputType | null
    _avg: DeviceImageColorsAvgAggregateOutputType | null
    _sum: DeviceImageColorsSumAggregateOutputType | null
    _min: DeviceImageColorsMinAggregateOutputType | null
    _max: DeviceImageColorsMaxAggregateOutputType | null
  }

  export type DeviceImageColorsAvgAggregateOutputType = {
    device_image_id: number | null
    color_id: number | null
  }

  export type DeviceImageColorsSumAggregateOutputType = {
    device_image_id: number | null
    color_id: number | null
  }

  export type DeviceImageColorsMinAggregateOutputType = {
    device_image_id: number | null
    color_id: number | null
    dark_mode: boolean | null
  }

  export type DeviceImageColorsMaxAggregateOutputType = {
    device_image_id: number | null
    color_id: number | null
    dark_mode: boolean | null
  }

  export type DeviceImageColorsCountAggregateOutputType = {
    device_image_id: number
    color_id: number
    dark_mode: number
    _all: number
  }


  export type DeviceImageColorsAvgAggregateInputType = {
    device_image_id?: true
    color_id?: true
  }

  export type DeviceImageColorsSumAggregateInputType = {
    device_image_id?: true
    color_id?: true
  }

  export type DeviceImageColorsMinAggregateInputType = {
    device_image_id?: true
    color_id?: true
    dark_mode?: true
  }

  export type DeviceImageColorsMaxAggregateInputType = {
    device_image_id?: true
    color_id?: true
    dark_mode?: true
  }

  export type DeviceImageColorsCountAggregateInputType = {
    device_image_id?: true
    color_id?: true
    dark_mode?: true
    _all?: true
  }

  export type DeviceImageColorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceImageColors to aggregate.
     */
    where?: DeviceImageColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceImageColors to fetch.
     */
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceImageColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceImageColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceImageColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceImageColors
    **/
    _count?: true | DeviceImageColorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceImageColorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceImageColorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceImageColorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceImageColorsMaxAggregateInputType
  }

  export type GetDeviceImageColorsAggregateType<T extends DeviceImageColorsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceImageColors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceImageColors[P]>
      : GetScalarType<T[P], AggregateDeviceImageColors[P]>
  }




  export type DeviceImageColorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceImageColorsWhereInput
    orderBy?: DeviceImageColorsOrderByWithAggregationInput | DeviceImageColorsOrderByWithAggregationInput[]
    by: DeviceImageColorsScalarFieldEnum[] | DeviceImageColorsScalarFieldEnum
    having?: DeviceImageColorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceImageColorsCountAggregateInputType | true
    _avg?: DeviceImageColorsAvgAggregateInputType
    _sum?: DeviceImageColorsSumAggregateInputType
    _min?: DeviceImageColorsMinAggregateInputType
    _max?: DeviceImageColorsMaxAggregateInputType
  }

  export type DeviceImageColorsGroupByOutputType = {
    device_image_id: number
    color_id: number
    dark_mode: boolean | null
    _count: DeviceImageColorsCountAggregateOutputType | null
    _avg: DeviceImageColorsAvgAggregateOutputType | null
    _sum: DeviceImageColorsSumAggregateOutputType | null
    _min: DeviceImageColorsMinAggregateOutputType | null
    _max: DeviceImageColorsMaxAggregateOutputType | null
  }

  type GetDeviceImageColorsGroupByPayload<T extends DeviceImageColorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceImageColorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceImageColorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceImageColorsGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceImageColorsGroupByOutputType[P]>
        }
      >
    >


  export type DeviceImageColorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_image_id?: boolean
    color_id?: boolean
    dark_mode?: boolean
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceImageColors"]>

  export type DeviceImageColorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_image_id?: boolean
    color_id?: boolean
    dark_mode?: boolean
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceImageColors"]>

  export type DeviceImageColorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_image_id?: boolean
    color_id?: boolean
    dark_mode?: boolean
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceImageColors"]>

  export type DeviceImageColorsSelectScalar = {
    device_image_id?: boolean
    color_id?: boolean
    dark_mode?: boolean
  }

  export type DeviceImageColorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_image_id" | "color_id" | "dark_mode", ExtArgs["result"]["deviceImageColors"]>
  export type DeviceImageColorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }
  export type DeviceImageColorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }
  export type DeviceImageColorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceLookupImage?: boolean | DeviceLookupImageDefaultArgs<ExtArgs>
    ColorLookup?: boolean | ColorLookupDefaultArgs<ExtArgs>
  }

  export type $DeviceImageColorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceImageColors"
    objects: {
      DeviceLookupImage: Prisma.$DeviceLookupImagePayload<ExtArgs>
      ColorLookup: Prisma.$ColorLookupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_image_id: number
      color_id: number
      dark_mode: boolean | null
    }, ExtArgs["result"]["deviceImageColors"]>
    composites: {}
  }

  type DeviceImageColorsGetPayload<S extends boolean | null | undefined | DeviceImageColorsDefaultArgs> = $Result.GetResult<Prisma.$DeviceImageColorsPayload, S>

  type DeviceImageColorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceImageColorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceImageColorsCountAggregateInputType | true
    }

  export interface DeviceImageColorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceImageColors'], meta: { name: 'DeviceImageColors' } }
    /**
     * Find zero or one DeviceImageColors that matches the filter.
     * @param {DeviceImageColorsFindUniqueArgs} args - Arguments to find a DeviceImageColors
     * @example
     * // Get one DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceImageColorsFindUniqueArgs>(args: SelectSubset<T, DeviceImageColorsFindUniqueArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceImageColors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceImageColorsFindUniqueOrThrowArgs} args - Arguments to find a DeviceImageColors
     * @example
     * // Get one DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceImageColorsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceImageColorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceImageColors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsFindFirstArgs} args - Arguments to find a DeviceImageColors
     * @example
     * // Get one DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceImageColorsFindFirstArgs>(args?: SelectSubset<T, DeviceImageColorsFindFirstArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceImageColors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsFindFirstOrThrowArgs} args - Arguments to find a DeviceImageColors
     * @example
     * // Get one DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceImageColorsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceImageColorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceImageColors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findMany()
     * 
     * // Get first 10 DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.findMany({ take: 10 })
     * 
     * // Only select the `device_image_id`
     * const deviceImageColorsWithDevice_image_idOnly = await prisma.deviceImageColors.findMany({ select: { device_image_id: true } })
     * 
     */
    findMany<T extends DeviceImageColorsFindManyArgs>(args?: SelectSubset<T, DeviceImageColorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceImageColors.
     * @param {DeviceImageColorsCreateArgs} args - Arguments to create a DeviceImageColors.
     * @example
     * // Create one DeviceImageColors
     * const DeviceImageColors = await prisma.deviceImageColors.create({
     *   data: {
     *     // ... data to create a DeviceImageColors
     *   }
     * })
     * 
     */
    create<T extends DeviceImageColorsCreateArgs>(args: SelectSubset<T, DeviceImageColorsCreateArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceImageColors.
     * @param {DeviceImageColorsCreateManyArgs} args - Arguments to create many DeviceImageColors.
     * @example
     * // Create many DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceImageColorsCreateManyArgs>(args?: SelectSubset<T, DeviceImageColorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceImageColors and returns the data saved in the database.
     * @param {DeviceImageColorsCreateManyAndReturnArgs} args - Arguments to create many DeviceImageColors.
     * @example
     * // Create many DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceImageColors and only return the `device_image_id`
     * const deviceImageColorsWithDevice_image_idOnly = await prisma.deviceImageColors.createManyAndReturn({
     *   select: { device_image_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceImageColorsCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceImageColorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceImageColors.
     * @param {DeviceImageColorsDeleteArgs} args - Arguments to delete one DeviceImageColors.
     * @example
     * // Delete one DeviceImageColors
     * const DeviceImageColors = await prisma.deviceImageColors.delete({
     *   where: {
     *     // ... filter to delete one DeviceImageColors
     *   }
     * })
     * 
     */
    delete<T extends DeviceImageColorsDeleteArgs>(args: SelectSubset<T, DeviceImageColorsDeleteArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceImageColors.
     * @param {DeviceImageColorsUpdateArgs} args - Arguments to update one DeviceImageColors.
     * @example
     * // Update one DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceImageColorsUpdateArgs>(args: SelectSubset<T, DeviceImageColorsUpdateArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceImageColors.
     * @param {DeviceImageColorsDeleteManyArgs} args - Arguments to filter DeviceImageColors to delete.
     * @example
     * // Delete a few DeviceImageColors
     * const { count } = await prisma.deviceImageColors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceImageColorsDeleteManyArgs>(args?: SelectSubset<T, DeviceImageColorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceImageColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceImageColorsUpdateManyArgs>(args: SelectSubset<T, DeviceImageColorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceImageColors and returns the data updated in the database.
     * @param {DeviceImageColorsUpdateManyAndReturnArgs} args - Arguments to update many DeviceImageColors.
     * @example
     * // Update many DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceImageColors and only return the `device_image_id`
     * const deviceImageColorsWithDevice_image_idOnly = await prisma.deviceImageColors.updateManyAndReturn({
     *   select: { device_image_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceImageColorsUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceImageColorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceImageColors.
     * @param {DeviceImageColorsUpsertArgs} args - Arguments to update or create a DeviceImageColors.
     * @example
     * // Update or create a DeviceImageColors
     * const deviceImageColors = await prisma.deviceImageColors.upsert({
     *   create: {
     *     // ... data to create a DeviceImageColors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceImageColors we want to update
     *   }
     * })
     */
    upsert<T extends DeviceImageColorsUpsertArgs>(args: SelectSubset<T, DeviceImageColorsUpsertArgs<ExtArgs>>): Prisma__DeviceImageColorsClient<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceImageColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsCountArgs} args - Arguments to filter DeviceImageColors to count.
     * @example
     * // Count the number of DeviceImageColors
     * const count = await prisma.deviceImageColors.count({
     *   where: {
     *     // ... the filter for the DeviceImageColors we want to count
     *   }
     * })
    **/
    count<T extends DeviceImageColorsCountArgs>(
      args?: Subset<T, DeviceImageColorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceImageColorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceImageColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceImageColorsAggregateArgs>(args: Subset<T, DeviceImageColorsAggregateArgs>): Prisma.PrismaPromise<GetDeviceImageColorsAggregateType<T>>

    /**
     * Group by DeviceImageColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceImageColorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceImageColorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceImageColorsGroupByArgs['orderBy'] }
        : { orderBy?: DeviceImageColorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceImageColorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceImageColorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceImageColors model
   */
  readonly fields: DeviceImageColorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceImageColors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceImageColorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceLookupImage<T extends DeviceLookupImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupImageDefaultArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ColorLookup<T extends ColorLookupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ColorLookupDefaultArgs<ExtArgs>>): Prisma__ColorLookupClient<$Result.GetResult<Prisma.$ColorLookupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceImageColors model
   */
  interface DeviceImageColorsFieldRefs {
    readonly device_image_id: FieldRef<"DeviceImageColors", 'Int'>
    readonly color_id: FieldRef<"DeviceImageColors", 'Int'>
    readonly dark_mode: FieldRef<"DeviceImageColors", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DeviceImageColors findUnique
   */
  export type DeviceImageColorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter, which DeviceImageColors to fetch.
     */
    where: DeviceImageColorsWhereUniqueInput
  }

  /**
   * DeviceImageColors findUniqueOrThrow
   */
  export type DeviceImageColorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter, which DeviceImageColors to fetch.
     */
    where: DeviceImageColorsWhereUniqueInput
  }

  /**
   * DeviceImageColors findFirst
   */
  export type DeviceImageColorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter, which DeviceImageColors to fetch.
     */
    where?: DeviceImageColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceImageColors to fetch.
     */
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceImageColors.
     */
    cursor?: DeviceImageColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceImageColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceImageColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceImageColors.
     */
    distinct?: DeviceImageColorsScalarFieldEnum | DeviceImageColorsScalarFieldEnum[]
  }

  /**
   * DeviceImageColors findFirstOrThrow
   */
  export type DeviceImageColorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter, which DeviceImageColors to fetch.
     */
    where?: DeviceImageColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceImageColors to fetch.
     */
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceImageColors.
     */
    cursor?: DeviceImageColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceImageColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceImageColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceImageColors.
     */
    distinct?: DeviceImageColorsScalarFieldEnum | DeviceImageColorsScalarFieldEnum[]
  }

  /**
   * DeviceImageColors findMany
   */
  export type DeviceImageColorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter, which DeviceImageColors to fetch.
     */
    where?: DeviceImageColorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceImageColors to fetch.
     */
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceImageColors.
     */
    cursor?: DeviceImageColorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceImageColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceImageColors.
     */
    skip?: number
    distinct?: DeviceImageColorsScalarFieldEnum | DeviceImageColorsScalarFieldEnum[]
  }

  /**
   * DeviceImageColors create
   */
  export type DeviceImageColorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceImageColors.
     */
    data: XOR<DeviceImageColorsCreateInput, DeviceImageColorsUncheckedCreateInput>
  }

  /**
   * DeviceImageColors createMany
   */
  export type DeviceImageColorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceImageColors.
     */
    data: DeviceImageColorsCreateManyInput | DeviceImageColorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceImageColors createManyAndReturn
   */
  export type DeviceImageColorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceImageColors.
     */
    data: DeviceImageColorsCreateManyInput | DeviceImageColorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceImageColors update
   */
  export type DeviceImageColorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceImageColors.
     */
    data: XOR<DeviceImageColorsUpdateInput, DeviceImageColorsUncheckedUpdateInput>
    /**
     * Choose, which DeviceImageColors to update.
     */
    where: DeviceImageColorsWhereUniqueInput
  }

  /**
   * DeviceImageColors updateMany
   */
  export type DeviceImageColorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceImageColors.
     */
    data: XOR<DeviceImageColorsUpdateManyMutationInput, DeviceImageColorsUncheckedUpdateManyInput>
    /**
     * Filter which DeviceImageColors to update
     */
    where?: DeviceImageColorsWhereInput
    /**
     * Limit how many DeviceImageColors to update.
     */
    limit?: number
  }

  /**
   * DeviceImageColors updateManyAndReturn
   */
  export type DeviceImageColorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * The data used to update DeviceImageColors.
     */
    data: XOR<DeviceImageColorsUpdateManyMutationInput, DeviceImageColorsUncheckedUpdateManyInput>
    /**
     * Filter which DeviceImageColors to update
     */
    where?: DeviceImageColorsWhereInput
    /**
     * Limit how many DeviceImageColors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceImageColors upsert
   */
  export type DeviceImageColorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceImageColors to update in case it exists.
     */
    where: DeviceImageColorsWhereUniqueInput
    /**
     * In case the DeviceImageColors found by the `where` argument doesn't exist, create a new DeviceImageColors with this data.
     */
    create: XOR<DeviceImageColorsCreateInput, DeviceImageColorsUncheckedCreateInput>
    /**
     * In case the DeviceImageColors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceImageColorsUpdateInput, DeviceImageColorsUncheckedUpdateInput>
  }

  /**
   * DeviceImageColors delete
   */
  export type DeviceImageColorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    /**
     * Filter which DeviceImageColors to delete.
     */
    where: DeviceImageColorsWhereUniqueInput
  }

  /**
   * DeviceImageColors deleteMany
   */
  export type DeviceImageColorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceImageColors to delete
     */
    where?: DeviceImageColorsWhereInput
    /**
     * Limit how many DeviceImageColors to delete.
     */
    limit?: number
  }

  /**
   * DeviceImageColors without action
   */
  export type DeviceImageColorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
  }


  /**
   * Model DeviceLookupArchitecture
   */

  export type AggregateDeviceLookupArchitecture = {
    _count: DeviceLookupArchitectureCountAggregateOutputType | null
    _avg: DeviceLookupArchitectureAvgAggregateOutputType | null
    _sum: DeviceLookupArchitectureSumAggregateOutputType | null
    _min: DeviceLookupArchitectureMinAggregateOutputType | null
    _max: DeviceLookupArchitectureMaxAggregateOutputType | null
  }

  export type DeviceLookupArchitectureAvgAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupArchitectureSumAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupArchitectureMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupArchitectureMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupArchitectureCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeviceLookupArchitectureAvgAggregateInputType = {
    id?: true
  }

  export type DeviceLookupArchitectureSumAggregateInputType = {
    id?: true
  }

  export type DeviceLookupArchitectureMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupArchitectureMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupArchitectureCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeviceLookupArchitectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupArchitecture to aggregate.
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupArchitectures to fetch.
     */
    orderBy?: DeviceLookupArchitectureOrderByWithRelationInput | DeviceLookupArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceLookupArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceLookupArchitectures
    **/
    _count?: true | DeviceLookupArchitectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceLookupArchitectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceLookupArchitectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceLookupArchitectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceLookupArchitectureMaxAggregateInputType
  }

  export type GetDeviceLookupArchitectureAggregateType<T extends DeviceLookupArchitectureAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceLookupArchitecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceLookupArchitecture[P]>
      : GetScalarType<T[P], AggregateDeviceLookupArchitecture[P]>
  }




  export type DeviceLookupArchitectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLookupArchitectureWhereInput
    orderBy?: DeviceLookupArchitectureOrderByWithAggregationInput | DeviceLookupArchitectureOrderByWithAggregationInput[]
    by: DeviceLookupArchitectureScalarFieldEnum[] | DeviceLookupArchitectureScalarFieldEnum
    having?: DeviceLookupArchitectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceLookupArchitectureCountAggregateInputType | true
    _avg?: DeviceLookupArchitectureAvgAggregateInputType
    _sum?: DeviceLookupArchitectureSumAggregateInputType
    _min?: DeviceLookupArchitectureMinAggregateInputType
    _max?: DeviceLookupArchitectureMaxAggregateInputType
  }

  export type DeviceLookupArchitectureGroupByOutputType = {
    id: number
    name: string
    _count: DeviceLookupArchitectureCountAggregateOutputType | null
    _avg: DeviceLookupArchitectureAvgAggregateOutputType | null
    _sum: DeviceLookupArchitectureSumAggregateOutputType | null
    _min: DeviceLookupArchitectureMinAggregateOutputType | null
    _max: DeviceLookupArchitectureMaxAggregateOutputType | null
  }

  type GetDeviceLookupArchitectureGroupByPayload<T extends DeviceLookupArchitectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceLookupArchitectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceLookupArchitectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceLookupArchitectureGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceLookupArchitectureGroupByOutputType[P]>
        }
      >
    >


  export type DeviceLookupArchitectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DeviceMapArchitecture?: boolean | DeviceLookupArchitecture$DeviceMapArchitectureArgs<ExtArgs>
    _count?: boolean | DeviceLookupArchitectureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceLookupArchitecture"]>

  export type DeviceLookupArchitectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupArchitecture"]>

  export type DeviceLookupArchitectureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupArchitecture"]>

  export type DeviceLookupArchitectureSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeviceLookupArchitectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["deviceLookupArchitecture"]>
  export type DeviceLookupArchitectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceMapArchitecture?: boolean | DeviceLookupArchitecture$DeviceMapArchitectureArgs<ExtArgs>
    _count?: boolean | DeviceLookupArchitectureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceLookupArchitectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceLookupArchitectureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceLookupArchitecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceLookupArchitecture"
    objects: {
      DeviceMapArchitecture: Prisma.$DeviceMapArchitecturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["deviceLookupArchitecture"]>
    composites: {}
  }

  type DeviceLookupArchitectureGetPayload<S extends boolean | null | undefined | DeviceLookupArchitectureDefaultArgs> = $Result.GetResult<Prisma.$DeviceLookupArchitecturePayload, S>

  type DeviceLookupArchitectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceLookupArchitectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceLookupArchitectureCountAggregateInputType | true
    }

  export interface DeviceLookupArchitectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceLookupArchitecture'], meta: { name: 'DeviceLookupArchitecture' } }
    /**
     * Find zero or one DeviceLookupArchitecture that matches the filter.
     * @param {DeviceLookupArchitectureFindUniqueArgs} args - Arguments to find a DeviceLookupArchitecture
     * @example
     * // Get one DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceLookupArchitectureFindUniqueArgs>(args: SelectSubset<T, DeviceLookupArchitectureFindUniqueArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceLookupArchitecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceLookupArchitectureFindUniqueOrThrowArgs} args - Arguments to find a DeviceLookupArchitecture
     * @example
     * // Get one DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceLookupArchitectureFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceLookupArchitectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupArchitecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureFindFirstArgs} args - Arguments to find a DeviceLookupArchitecture
     * @example
     * // Get one DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceLookupArchitectureFindFirstArgs>(args?: SelectSubset<T, DeviceLookupArchitectureFindFirstArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupArchitecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureFindFirstOrThrowArgs} args - Arguments to find a DeviceLookupArchitecture
     * @example
     * // Get one DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceLookupArchitectureFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceLookupArchitectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceLookupArchitectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceLookupArchitectures
     * const deviceLookupArchitectures = await prisma.deviceLookupArchitecture.findMany()
     * 
     * // Get first 10 DeviceLookupArchitectures
     * const deviceLookupArchitectures = await prisma.deviceLookupArchitecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceLookupArchitectureWithIdOnly = await prisma.deviceLookupArchitecture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceLookupArchitectureFindManyArgs>(args?: SelectSubset<T, DeviceLookupArchitectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceLookupArchitecture.
     * @param {DeviceLookupArchitectureCreateArgs} args - Arguments to create a DeviceLookupArchitecture.
     * @example
     * // Create one DeviceLookupArchitecture
     * const DeviceLookupArchitecture = await prisma.deviceLookupArchitecture.create({
     *   data: {
     *     // ... data to create a DeviceLookupArchitecture
     *   }
     * })
     * 
     */
    create<T extends DeviceLookupArchitectureCreateArgs>(args: SelectSubset<T, DeviceLookupArchitectureCreateArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceLookupArchitectures.
     * @param {DeviceLookupArchitectureCreateManyArgs} args - Arguments to create many DeviceLookupArchitectures.
     * @example
     * // Create many DeviceLookupArchitectures
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceLookupArchitectureCreateManyArgs>(args?: SelectSubset<T, DeviceLookupArchitectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceLookupArchitectures and returns the data saved in the database.
     * @param {DeviceLookupArchitectureCreateManyAndReturnArgs} args - Arguments to create many DeviceLookupArchitectures.
     * @example
     * // Create many DeviceLookupArchitectures
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceLookupArchitectures and only return the `id`
     * const deviceLookupArchitectureWithIdOnly = await prisma.deviceLookupArchitecture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceLookupArchitectureCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceLookupArchitectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceLookupArchitecture.
     * @param {DeviceLookupArchitectureDeleteArgs} args - Arguments to delete one DeviceLookupArchitecture.
     * @example
     * // Delete one DeviceLookupArchitecture
     * const DeviceLookupArchitecture = await prisma.deviceLookupArchitecture.delete({
     *   where: {
     *     // ... filter to delete one DeviceLookupArchitecture
     *   }
     * })
     * 
     */
    delete<T extends DeviceLookupArchitectureDeleteArgs>(args: SelectSubset<T, DeviceLookupArchitectureDeleteArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceLookupArchitecture.
     * @param {DeviceLookupArchitectureUpdateArgs} args - Arguments to update one DeviceLookupArchitecture.
     * @example
     * // Update one DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceLookupArchitectureUpdateArgs>(args: SelectSubset<T, DeviceLookupArchitectureUpdateArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceLookupArchitectures.
     * @param {DeviceLookupArchitectureDeleteManyArgs} args - Arguments to filter DeviceLookupArchitectures to delete.
     * @example
     * // Delete a few DeviceLookupArchitectures
     * const { count } = await prisma.deviceLookupArchitecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceLookupArchitectureDeleteManyArgs>(args?: SelectSubset<T, DeviceLookupArchitectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceLookupArchitectures
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceLookupArchitectureUpdateManyArgs>(args: SelectSubset<T, DeviceLookupArchitectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupArchitectures and returns the data updated in the database.
     * @param {DeviceLookupArchitectureUpdateManyAndReturnArgs} args - Arguments to update many DeviceLookupArchitectures.
     * @example
     * // Update many DeviceLookupArchitectures
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceLookupArchitectures and only return the `id`
     * const deviceLookupArchitectureWithIdOnly = await prisma.deviceLookupArchitecture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceLookupArchitectureUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceLookupArchitectureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceLookupArchitecture.
     * @param {DeviceLookupArchitectureUpsertArgs} args - Arguments to update or create a DeviceLookupArchitecture.
     * @example
     * // Update or create a DeviceLookupArchitecture
     * const deviceLookupArchitecture = await prisma.deviceLookupArchitecture.upsert({
     *   create: {
     *     // ... data to create a DeviceLookupArchitecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceLookupArchitecture we want to update
     *   }
     * })
     */
    upsert<T extends DeviceLookupArchitectureUpsertArgs>(args: SelectSubset<T, DeviceLookupArchitectureUpsertArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceLookupArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureCountArgs} args - Arguments to filter DeviceLookupArchitectures to count.
     * @example
     * // Count the number of DeviceLookupArchitectures
     * const count = await prisma.deviceLookupArchitecture.count({
     *   where: {
     *     // ... the filter for the DeviceLookupArchitectures we want to count
     *   }
     * })
    **/
    count<T extends DeviceLookupArchitectureCountArgs>(
      args?: Subset<T, DeviceLookupArchitectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceLookupArchitectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceLookupArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceLookupArchitectureAggregateArgs>(args: Subset<T, DeviceLookupArchitectureAggregateArgs>): Prisma.PrismaPromise<GetDeviceLookupArchitectureAggregateType<T>>

    /**
     * Group by DeviceLookupArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupArchitectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceLookupArchitectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceLookupArchitectureGroupByArgs['orderBy'] }
        : { orderBy?: DeviceLookupArchitectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceLookupArchitectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceLookupArchitectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceLookupArchitecture model
   */
  readonly fields: DeviceLookupArchitectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceLookupArchitecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceLookupArchitectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceMapArchitecture<T extends DeviceLookupArchitecture$DeviceMapArchitectureArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupArchitecture$DeviceMapArchitectureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceLookupArchitecture model
   */
  interface DeviceLookupArchitectureFieldRefs {
    readonly id: FieldRef<"DeviceLookupArchitecture", 'Int'>
    readonly name: FieldRef<"DeviceLookupArchitecture", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceLookupArchitecture findUnique
   */
  export type DeviceLookupArchitectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupArchitecture to fetch.
     */
    where: DeviceLookupArchitectureWhereUniqueInput
  }

  /**
   * DeviceLookupArchitecture findUniqueOrThrow
   */
  export type DeviceLookupArchitectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupArchitecture to fetch.
     */
    where: DeviceLookupArchitectureWhereUniqueInput
  }

  /**
   * DeviceLookupArchitecture findFirst
   */
  export type DeviceLookupArchitectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupArchitecture to fetch.
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupArchitectures to fetch.
     */
    orderBy?: DeviceLookupArchitectureOrderByWithRelationInput | DeviceLookupArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupArchitectures.
     */
    cursor?: DeviceLookupArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupArchitectures.
     */
    distinct?: DeviceLookupArchitectureScalarFieldEnum | DeviceLookupArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceLookupArchitecture findFirstOrThrow
   */
  export type DeviceLookupArchitectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupArchitecture to fetch.
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupArchitectures to fetch.
     */
    orderBy?: DeviceLookupArchitectureOrderByWithRelationInput | DeviceLookupArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupArchitectures.
     */
    cursor?: DeviceLookupArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupArchitectures.
     */
    distinct?: DeviceLookupArchitectureScalarFieldEnum | DeviceLookupArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceLookupArchitecture findMany
   */
  export type DeviceLookupArchitectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupArchitectures to fetch.
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupArchitectures to fetch.
     */
    orderBy?: DeviceLookupArchitectureOrderByWithRelationInput | DeviceLookupArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceLookupArchitectures.
     */
    cursor?: DeviceLookupArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupArchitectures.
     */
    skip?: number
    distinct?: DeviceLookupArchitectureScalarFieldEnum | DeviceLookupArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceLookupArchitecture create
   */
  export type DeviceLookupArchitectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceLookupArchitecture.
     */
    data: XOR<DeviceLookupArchitectureCreateInput, DeviceLookupArchitectureUncheckedCreateInput>
  }

  /**
   * DeviceLookupArchitecture createMany
   */
  export type DeviceLookupArchitectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceLookupArchitectures.
     */
    data: DeviceLookupArchitectureCreateManyInput | DeviceLookupArchitectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupArchitecture createManyAndReturn
   */
  export type DeviceLookupArchitectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceLookupArchitectures.
     */
    data: DeviceLookupArchitectureCreateManyInput | DeviceLookupArchitectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupArchitecture update
   */
  export type DeviceLookupArchitectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceLookupArchitecture.
     */
    data: XOR<DeviceLookupArchitectureUpdateInput, DeviceLookupArchitectureUncheckedUpdateInput>
    /**
     * Choose, which DeviceLookupArchitecture to update.
     */
    where: DeviceLookupArchitectureWhereUniqueInput
  }

  /**
   * DeviceLookupArchitecture updateMany
   */
  export type DeviceLookupArchitectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceLookupArchitectures.
     */
    data: XOR<DeviceLookupArchitectureUpdateManyMutationInput, DeviceLookupArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupArchitectures to update
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * Limit how many DeviceLookupArchitectures to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupArchitecture updateManyAndReturn
   */
  export type DeviceLookupArchitectureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * The data used to update DeviceLookupArchitectures.
     */
    data: XOR<DeviceLookupArchitectureUpdateManyMutationInput, DeviceLookupArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupArchitectures to update
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * Limit how many DeviceLookupArchitectures to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupArchitecture upsert
   */
  export type DeviceLookupArchitectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceLookupArchitecture to update in case it exists.
     */
    where: DeviceLookupArchitectureWhereUniqueInput
    /**
     * In case the DeviceLookupArchitecture found by the `where` argument doesn't exist, create a new DeviceLookupArchitecture with this data.
     */
    create: XOR<DeviceLookupArchitectureCreateInput, DeviceLookupArchitectureUncheckedCreateInput>
    /**
     * In case the DeviceLookupArchitecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceLookupArchitectureUpdateInput, DeviceLookupArchitectureUncheckedUpdateInput>
  }

  /**
   * DeviceLookupArchitecture delete
   */
  export type DeviceLookupArchitectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
    /**
     * Filter which DeviceLookupArchitecture to delete.
     */
    where: DeviceLookupArchitectureWhereUniqueInput
  }

  /**
   * DeviceLookupArchitecture deleteMany
   */
  export type DeviceLookupArchitectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupArchitectures to delete
     */
    where?: DeviceLookupArchitectureWhereInput
    /**
     * Limit how many DeviceLookupArchitectures to delete.
     */
    limit?: number
  }

  /**
   * DeviceLookupArchitecture.DeviceMapArchitecture
   */
  export type DeviceLookupArchitecture$DeviceMapArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    where?: DeviceMapArchitectureWhereInput
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    cursor?: DeviceMapArchitectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapArchitectureScalarFieldEnum | DeviceMapArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceLookupArchitecture without action
   */
  export type DeviceLookupArchitectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupArchitecture
     */
    select?: DeviceLookupArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupArchitecture
     */
    omit?: DeviceLookupArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupArchitectureInclude<ExtArgs> | null
  }


  /**
   * Model DeviceLookupCategory
   */

  export type AggregateDeviceLookupCategory = {
    _count: DeviceLookupCategoryCountAggregateOutputType | null
    _avg: DeviceLookupCategoryAvgAggregateOutputType | null
    _sum: DeviceLookupCategorySumAggregateOutputType | null
    _min: DeviceLookupCategoryMinAggregateOutputType | null
    _max: DeviceLookupCategoryMaxAggregateOutputType | null
  }

  export type DeviceLookupCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupCategorySumAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeviceLookupCategoryAvgAggregateInputType = {
    id?: true
  }

  export type DeviceLookupCategorySumAggregateInputType = {
    id?: true
  }

  export type DeviceLookupCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeviceLookupCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupCategory to aggregate.
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupCategories to fetch.
     */
    orderBy?: DeviceLookupCategoryOrderByWithRelationInput | DeviceLookupCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceLookupCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceLookupCategories
    **/
    _count?: true | DeviceLookupCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceLookupCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceLookupCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceLookupCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceLookupCategoryMaxAggregateInputType
  }

  export type GetDeviceLookupCategoryAggregateType<T extends DeviceLookupCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceLookupCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceLookupCategory[P]>
      : GetScalarType<T[P], AggregateDeviceLookupCategory[P]>
  }




  export type DeviceLookupCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLookupCategoryWhereInput
    orderBy?: DeviceLookupCategoryOrderByWithAggregationInput | DeviceLookupCategoryOrderByWithAggregationInput[]
    by: DeviceLookupCategoryScalarFieldEnum[] | DeviceLookupCategoryScalarFieldEnum
    having?: DeviceLookupCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceLookupCategoryCountAggregateInputType | true
    _avg?: DeviceLookupCategoryAvgAggregateInputType
    _sum?: DeviceLookupCategorySumAggregateInputType
    _min?: DeviceLookupCategoryMinAggregateInputType
    _max?: DeviceLookupCategoryMaxAggregateInputType
  }

  export type DeviceLookupCategoryGroupByOutputType = {
    id: number
    name: string
    _count: DeviceLookupCategoryCountAggregateOutputType | null
    _avg: DeviceLookupCategoryAvgAggregateOutputType | null
    _sum: DeviceLookupCategorySumAggregateOutputType | null
    _min: DeviceLookupCategoryMinAggregateOutputType | null
    _max: DeviceLookupCategoryMaxAggregateOutputType | null
  }

  type GetDeviceLookupCategoryGroupByPayload<T extends DeviceLookupCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceLookupCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceLookupCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceLookupCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceLookupCategoryGroupByOutputType[P]>
        }
      >
    >


  export type DeviceLookupCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DeviceEntry?: boolean | DeviceLookupCategory$DeviceEntryArgs<ExtArgs>
    _count?: boolean | DeviceLookupCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceLookupCategory"]>

  export type DeviceLookupCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupCategory"]>

  export type DeviceLookupCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupCategory"]>

  export type DeviceLookupCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeviceLookupCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["deviceLookupCategory"]>
  export type DeviceLookupCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceLookupCategory$DeviceEntryArgs<ExtArgs>
    _count?: boolean | DeviceLookupCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceLookupCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceLookupCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceLookupCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceLookupCategory"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["deviceLookupCategory"]>
    composites: {}
  }

  type DeviceLookupCategoryGetPayload<S extends boolean | null | undefined | DeviceLookupCategoryDefaultArgs> = $Result.GetResult<Prisma.$DeviceLookupCategoryPayload, S>

  type DeviceLookupCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceLookupCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceLookupCategoryCountAggregateInputType | true
    }

  export interface DeviceLookupCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceLookupCategory'], meta: { name: 'DeviceLookupCategory' } }
    /**
     * Find zero or one DeviceLookupCategory that matches the filter.
     * @param {DeviceLookupCategoryFindUniqueArgs} args - Arguments to find a DeviceLookupCategory
     * @example
     * // Get one DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceLookupCategoryFindUniqueArgs>(args: SelectSubset<T, DeviceLookupCategoryFindUniqueArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceLookupCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceLookupCategoryFindUniqueOrThrowArgs} args - Arguments to find a DeviceLookupCategory
     * @example
     * // Get one DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceLookupCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceLookupCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryFindFirstArgs} args - Arguments to find a DeviceLookupCategory
     * @example
     * // Get one DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceLookupCategoryFindFirstArgs>(args?: SelectSubset<T, DeviceLookupCategoryFindFirstArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryFindFirstOrThrowArgs} args - Arguments to find a DeviceLookupCategory
     * @example
     * // Get one DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceLookupCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceLookupCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceLookupCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceLookupCategories
     * const deviceLookupCategories = await prisma.deviceLookupCategory.findMany()
     * 
     * // Get first 10 DeviceLookupCategories
     * const deviceLookupCategories = await prisma.deviceLookupCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceLookupCategoryWithIdOnly = await prisma.deviceLookupCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceLookupCategoryFindManyArgs>(args?: SelectSubset<T, DeviceLookupCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceLookupCategory.
     * @param {DeviceLookupCategoryCreateArgs} args - Arguments to create a DeviceLookupCategory.
     * @example
     * // Create one DeviceLookupCategory
     * const DeviceLookupCategory = await prisma.deviceLookupCategory.create({
     *   data: {
     *     // ... data to create a DeviceLookupCategory
     *   }
     * })
     * 
     */
    create<T extends DeviceLookupCategoryCreateArgs>(args: SelectSubset<T, DeviceLookupCategoryCreateArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceLookupCategories.
     * @param {DeviceLookupCategoryCreateManyArgs} args - Arguments to create many DeviceLookupCategories.
     * @example
     * // Create many DeviceLookupCategories
     * const deviceLookupCategory = await prisma.deviceLookupCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceLookupCategoryCreateManyArgs>(args?: SelectSubset<T, DeviceLookupCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceLookupCategories and returns the data saved in the database.
     * @param {DeviceLookupCategoryCreateManyAndReturnArgs} args - Arguments to create many DeviceLookupCategories.
     * @example
     * // Create many DeviceLookupCategories
     * const deviceLookupCategory = await prisma.deviceLookupCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceLookupCategories and only return the `id`
     * const deviceLookupCategoryWithIdOnly = await prisma.deviceLookupCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceLookupCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceLookupCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceLookupCategory.
     * @param {DeviceLookupCategoryDeleteArgs} args - Arguments to delete one DeviceLookupCategory.
     * @example
     * // Delete one DeviceLookupCategory
     * const DeviceLookupCategory = await prisma.deviceLookupCategory.delete({
     *   where: {
     *     // ... filter to delete one DeviceLookupCategory
     *   }
     * })
     * 
     */
    delete<T extends DeviceLookupCategoryDeleteArgs>(args: SelectSubset<T, DeviceLookupCategoryDeleteArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceLookupCategory.
     * @param {DeviceLookupCategoryUpdateArgs} args - Arguments to update one DeviceLookupCategory.
     * @example
     * // Update one DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceLookupCategoryUpdateArgs>(args: SelectSubset<T, DeviceLookupCategoryUpdateArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceLookupCategories.
     * @param {DeviceLookupCategoryDeleteManyArgs} args - Arguments to filter DeviceLookupCategories to delete.
     * @example
     * // Delete a few DeviceLookupCategories
     * const { count } = await prisma.deviceLookupCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceLookupCategoryDeleteManyArgs>(args?: SelectSubset<T, DeviceLookupCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceLookupCategories
     * const deviceLookupCategory = await prisma.deviceLookupCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceLookupCategoryUpdateManyArgs>(args: SelectSubset<T, DeviceLookupCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupCategories and returns the data updated in the database.
     * @param {DeviceLookupCategoryUpdateManyAndReturnArgs} args - Arguments to update many DeviceLookupCategories.
     * @example
     * // Update many DeviceLookupCategories
     * const deviceLookupCategory = await prisma.deviceLookupCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceLookupCategories and only return the `id`
     * const deviceLookupCategoryWithIdOnly = await prisma.deviceLookupCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceLookupCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceLookupCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceLookupCategory.
     * @param {DeviceLookupCategoryUpsertArgs} args - Arguments to update or create a DeviceLookupCategory.
     * @example
     * // Update or create a DeviceLookupCategory
     * const deviceLookupCategory = await prisma.deviceLookupCategory.upsert({
     *   create: {
     *     // ... data to create a DeviceLookupCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceLookupCategory we want to update
     *   }
     * })
     */
    upsert<T extends DeviceLookupCategoryUpsertArgs>(args: SelectSubset<T, DeviceLookupCategoryUpsertArgs<ExtArgs>>): Prisma__DeviceLookupCategoryClient<$Result.GetResult<Prisma.$DeviceLookupCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceLookupCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryCountArgs} args - Arguments to filter DeviceLookupCategories to count.
     * @example
     * // Count the number of DeviceLookupCategories
     * const count = await prisma.deviceLookupCategory.count({
     *   where: {
     *     // ... the filter for the DeviceLookupCategories we want to count
     *   }
     * })
    **/
    count<T extends DeviceLookupCategoryCountArgs>(
      args?: Subset<T, DeviceLookupCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceLookupCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceLookupCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceLookupCategoryAggregateArgs>(args: Subset<T, DeviceLookupCategoryAggregateArgs>): Prisma.PrismaPromise<GetDeviceLookupCategoryAggregateType<T>>

    /**
     * Group by DeviceLookupCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceLookupCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceLookupCategoryGroupByArgs['orderBy'] }
        : { orderBy?: DeviceLookupCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceLookupCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceLookupCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceLookupCategory model
   */
  readonly fields: DeviceLookupCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceLookupCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceLookupCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceLookupCategory$DeviceEntryArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupCategory$DeviceEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceLookupCategory model
   */
  interface DeviceLookupCategoryFieldRefs {
    readonly id: FieldRef<"DeviceLookupCategory", 'Int'>
    readonly name: FieldRef<"DeviceLookupCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceLookupCategory findUnique
   */
  export type DeviceLookupCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupCategory to fetch.
     */
    where: DeviceLookupCategoryWhereUniqueInput
  }

  /**
   * DeviceLookupCategory findUniqueOrThrow
   */
  export type DeviceLookupCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupCategory to fetch.
     */
    where: DeviceLookupCategoryWhereUniqueInput
  }

  /**
   * DeviceLookupCategory findFirst
   */
  export type DeviceLookupCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupCategory to fetch.
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupCategories to fetch.
     */
    orderBy?: DeviceLookupCategoryOrderByWithRelationInput | DeviceLookupCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupCategories.
     */
    cursor?: DeviceLookupCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupCategories.
     */
    distinct?: DeviceLookupCategoryScalarFieldEnum | DeviceLookupCategoryScalarFieldEnum[]
  }

  /**
   * DeviceLookupCategory findFirstOrThrow
   */
  export type DeviceLookupCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupCategory to fetch.
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupCategories to fetch.
     */
    orderBy?: DeviceLookupCategoryOrderByWithRelationInput | DeviceLookupCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupCategories.
     */
    cursor?: DeviceLookupCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupCategories.
     */
    distinct?: DeviceLookupCategoryScalarFieldEnum | DeviceLookupCategoryScalarFieldEnum[]
  }

  /**
   * DeviceLookupCategory findMany
   */
  export type DeviceLookupCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupCategories to fetch.
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupCategories to fetch.
     */
    orderBy?: DeviceLookupCategoryOrderByWithRelationInput | DeviceLookupCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceLookupCategories.
     */
    cursor?: DeviceLookupCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupCategories.
     */
    skip?: number
    distinct?: DeviceLookupCategoryScalarFieldEnum | DeviceLookupCategoryScalarFieldEnum[]
  }

  /**
   * DeviceLookupCategory create
   */
  export type DeviceLookupCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceLookupCategory.
     */
    data: XOR<DeviceLookupCategoryCreateInput, DeviceLookupCategoryUncheckedCreateInput>
  }

  /**
   * DeviceLookupCategory createMany
   */
  export type DeviceLookupCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceLookupCategories.
     */
    data: DeviceLookupCategoryCreateManyInput | DeviceLookupCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupCategory createManyAndReturn
   */
  export type DeviceLookupCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceLookupCategories.
     */
    data: DeviceLookupCategoryCreateManyInput | DeviceLookupCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupCategory update
   */
  export type DeviceLookupCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceLookupCategory.
     */
    data: XOR<DeviceLookupCategoryUpdateInput, DeviceLookupCategoryUncheckedUpdateInput>
    /**
     * Choose, which DeviceLookupCategory to update.
     */
    where: DeviceLookupCategoryWhereUniqueInput
  }

  /**
   * DeviceLookupCategory updateMany
   */
  export type DeviceLookupCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceLookupCategories.
     */
    data: XOR<DeviceLookupCategoryUpdateManyMutationInput, DeviceLookupCategoryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupCategories to update
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * Limit how many DeviceLookupCategories to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupCategory updateManyAndReturn
   */
  export type DeviceLookupCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * The data used to update DeviceLookupCategories.
     */
    data: XOR<DeviceLookupCategoryUpdateManyMutationInput, DeviceLookupCategoryUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupCategories to update
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * Limit how many DeviceLookupCategories to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupCategory upsert
   */
  export type DeviceLookupCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceLookupCategory to update in case it exists.
     */
    where: DeviceLookupCategoryWhereUniqueInput
    /**
     * In case the DeviceLookupCategory found by the `where` argument doesn't exist, create a new DeviceLookupCategory with this data.
     */
    create: XOR<DeviceLookupCategoryCreateInput, DeviceLookupCategoryUncheckedCreateInput>
    /**
     * In case the DeviceLookupCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceLookupCategoryUpdateInput, DeviceLookupCategoryUncheckedUpdateInput>
  }

  /**
   * DeviceLookupCategory delete
   */
  export type DeviceLookupCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
    /**
     * Filter which DeviceLookupCategory to delete.
     */
    where: DeviceLookupCategoryWhereUniqueInput
  }

  /**
   * DeviceLookupCategory deleteMany
   */
  export type DeviceLookupCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupCategories to delete
     */
    where?: DeviceLookupCategoryWhereInput
    /**
     * Limit how many DeviceLookupCategories to delete.
     */
    limit?: number
  }

  /**
   * DeviceLookupCategory.DeviceEntry
   */
  export type DeviceLookupCategory$DeviceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    where?: DeviceEntryWhereInput
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    cursor?: DeviceEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceEntryScalarFieldEnum | DeviceEntryScalarFieldEnum[]
  }

  /**
   * DeviceLookupCategory without action
   */
  export type DeviceLookupCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupCategory
     */
    select?: DeviceLookupCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupCategory
     */
    omit?: DeviceLookupCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupCategoryInclude<ExtArgs> | null
  }


  /**
   * Model DeviceLookupImage
   */

  export type AggregateDeviceLookupImage = {
    _count: DeviceLookupImageCountAggregateOutputType | null
    _avg: DeviceLookupImageAvgAggregateOutputType | null
    _sum: DeviceLookupImageSumAggregateOutputType | null
    _min: DeviceLookupImageMinAggregateOutputType | null
    _max: DeviceLookupImageMaxAggregateOutputType | null
  }

  export type DeviceLookupImageAvgAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupImageSumAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupImageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupImageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupImageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeviceLookupImageAvgAggregateInputType = {
    id?: true
  }

  export type DeviceLookupImageSumAggregateInputType = {
    id?: true
  }

  export type DeviceLookupImageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupImageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupImageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeviceLookupImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupImage to aggregate.
     */
    where?: DeviceLookupImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupImages to fetch.
     */
    orderBy?: DeviceLookupImageOrderByWithRelationInput | DeviceLookupImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceLookupImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceLookupImages
    **/
    _count?: true | DeviceLookupImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceLookupImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceLookupImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceLookupImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceLookupImageMaxAggregateInputType
  }

  export type GetDeviceLookupImageAggregateType<T extends DeviceLookupImageAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceLookupImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceLookupImage[P]>
      : GetScalarType<T[P], AggregateDeviceLookupImage[P]>
  }




  export type DeviceLookupImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLookupImageWhereInput
    orderBy?: DeviceLookupImageOrderByWithAggregationInput | DeviceLookupImageOrderByWithAggregationInput[]
    by: DeviceLookupImageScalarFieldEnum[] | DeviceLookupImageScalarFieldEnum
    having?: DeviceLookupImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceLookupImageCountAggregateInputType | true
    _avg?: DeviceLookupImageAvgAggregateInputType
    _sum?: DeviceLookupImageSumAggregateInputType
    _min?: DeviceLookupImageMinAggregateInputType
    _max?: DeviceLookupImageMaxAggregateInputType
  }

  export type DeviceLookupImageGroupByOutputType = {
    id: number
    name: string
    _count: DeviceLookupImageCountAggregateOutputType | null
    _avg: DeviceLookupImageAvgAggregateOutputType | null
    _sum: DeviceLookupImageSumAggregateOutputType | null
    _min: DeviceLookupImageMinAggregateOutputType | null
    _max: DeviceLookupImageMaxAggregateOutputType | null
  }

  type GetDeviceLookupImageGroupByPayload<T extends DeviceLookupImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceLookupImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceLookupImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceLookupImageGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceLookupImageGroupByOutputType[P]>
        }
      >
    >


  export type DeviceLookupImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DeviceEntry?: boolean | DeviceLookupImage$DeviceEntryArgs<ExtArgs>
    DeviceImageColors?: boolean | DeviceLookupImage$DeviceImageColorsArgs<ExtArgs>
    _count?: boolean | DeviceLookupImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceLookupImage"]>

  export type DeviceLookupImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupImage"]>

  export type DeviceLookupImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupImage"]>

  export type DeviceLookupImageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeviceLookupImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["deviceLookupImage"]>
  export type DeviceLookupImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceLookupImage$DeviceEntryArgs<ExtArgs>
    DeviceImageColors?: boolean | DeviceLookupImage$DeviceImageColorsArgs<ExtArgs>
    _count?: boolean | DeviceLookupImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceLookupImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceLookupImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceLookupImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceLookupImage"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>[]
      DeviceImageColors: Prisma.$DeviceImageColorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["deviceLookupImage"]>
    composites: {}
  }

  type DeviceLookupImageGetPayload<S extends boolean | null | undefined | DeviceLookupImageDefaultArgs> = $Result.GetResult<Prisma.$DeviceLookupImagePayload, S>

  type DeviceLookupImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceLookupImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceLookupImageCountAggregateInputType | true
    }

  export interface DeviceLookupImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceLookupImage'], meta: { name: 'DeviceLookupImage' } }
    /**
     * Find zero or one DeviceLookupImage that matches the filter.
     * @param {DeviceLookupImageFindUniqueArgs} args - Arguments to find a DeviceLookupImage
     * @example
     * // Get one DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceLookupImageFindUniqueArgs>(args: SelectSubset<T, DeviceLookupImageFindUniqueArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceLookupImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceLookupImageFindUniqueOrThrowArgs} args - Arguments to find a DeviceLookupImage
     * @example
     * // Get one DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceLookupImageFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceLookupImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageFindFirstArgs} args - Arguments to find a DeviceLookupImage
     * @example
     * // Get one DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceLookupImageFindFirstArgs>(args?: SelectSubset<T, DeviceLookupImageFindFirstArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageFindFirstOrThrowArgs} args - Arguments to find a DeviceLookupImage
     * @example
     * // Get one DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceLookupImageFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceLookupImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceLookupImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceLookupImages
     * const deviceLookupImages = await prisma.deviceLookupImage.findMany()
     * 
     * // Get first 10 DeviceLookupImages
     * const deviceLookupImages = await prisma.deviceLookupImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceLookupImageWithIdOnly = await prisma.deviceLookupImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceLookupImageFindManyArgs>(args?: SelectSubset<T, DeviceLookupImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceLookupImage.
     * @param {DeviceLookupImageCreateArgs} args - Arguments to create a DeviceLookupImage.
     * @example
     * // Create one DeviceLookupImage
     * const DeviceLookupImage = await prisma.deviceLookupImage.create({
     *   data: {
     *     // ... data to create a DeviceLookupImage
     *   }
     * })
     * 
     */
    create<T extends DeviceLookupImageCreateArgs>(args: SelectSubset<T, DeviceLookupImageCreateArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceLookupImages.
     * @param {DeviceLookupImageCreateManyArgs} args - Arguments to create many DeviceLookupImages.
     * @example
     * // Create many DeviceLookupImages
     * const deviceLookupImage = await prisma.deviceLookupImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceLookupImageCreateManyArgs>(args?: SelectSubset<T, DeviceLookupImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceLookupImages and returns the data saved in the database.
     * @param {DeviceLookupImageCreateManyAndReturnArgs} args - Arguments to create many DeviceLookupImages.
     * @example
     * // Create many DeviceLookupImages
     * const deviceLookupImage = await prisma.deviceLookupImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceLookupImages and only return the `id`
     * const deviceLookupImageWithIdOnly = await prisma.deviceLookupImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceLookupImageCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceLookupImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceLookupImage.
     * @param {DeviceLookupImageDeleteArgs} args - Arguments to delete one DeviceLookupImage.
     * @example
     * // Delete one DeviceLookupImage
     * const DeviceLookupImage = await prisma.deviceLookupImage.delete({
     *   where: {
     *     // ... filter to delete one DeviceLookupImage
     *   }
     * })
     * 
     */
    delete<T extends DeviceLookupImageDeleteArgs>(args: SelectSubset<T, DeviceLookupImageDeleteArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceLookupImage.
     * @param {DeviceLookupImageUpdateArgs} args - Arguments to update one DeviceLookupImage.
     * @example
     * // Update one DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceLookupImageUpdateArgs>(args: SelectSubset<T, DeviceLookupImageUpdateArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceLookupImages.
     * @param {DeviceLookupImageDeleteManyArgs} args - Arguments to filter DeviceLookupImages to delete.
     * @example
     * // Delete a few DeviceLookupImages
     * const { count } = await prisma.deviceLookupImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceLookupImageDeleteManyArgs>(args?: SelectSubset<T, DeviceLookupImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceLookupImages
     * const deviceLookupImage = await prisma.deviceLookupImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceLookupImageUpdateManyArgs>(args: SelectSubset<T, DeviceLookupImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupImages and returns the data updated in the database.
     * @param {DeviceLookupImageUpdateManyAndReturnArgs} args - Arguments to update many DeviceLookupImages.
     * @example
     * // Update many DeviceLookupImages
     * const deviceLookupImage = await prisma.deviceLookupImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceLookupImages and only return the `id`
     * const deviceLookupImageWithIdOnly = await prisma.deviceLookupImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceLookupImageUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceLookupImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceLookupImage.
     * @param {DeviceLookupImageUpsertArgs} args - Arguments to update or create a DeviceLookupImage.
     * @example
     * // Update or create a DeviceLookupImage
     * const deviceLookupImage = await prisma.deviceLookupImage.upsert({
     *   create: {
     *     // ... data to create a DeviceLookupImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceLookupImage we want to update
     *   }
     * })
     */
    upsert<T extends DeviceLookupImageUpsertArgs>(args: SelectSubset<T, DeviceLookupImageUpsertArgs<ExtArgs>>): Prisma__DeviceLookupImageClient<$Result.GetResult<Prisma.$DeviceLookupImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceLookupImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageCountArgs} args - Arguments to filter DeviceLookupImages to count.
     * @example
     * // Count the number of DeviceLookupImages
     * const count = await prisma.deviceLookupImage.count({
     *   where: {
     *     // ... the filter for the DeviceLookupImages we want to count
     *   }
     * })
    **/
    count<T extends DeviceLookupImageCountArgs>(
      args?: Subset<T, DeviceLookupImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceLookupImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceLookupImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceLookupImageAggregateArgs>(args: Subset<T, DeviceLookupImageAggregateArgs>): Prisma.PrismaPromise<GetDeviceLookupImageAggregateType<T>>

    /**
     * Group by DeviceLookupImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceLookupImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceLookupImageGroupByArgs['orderBy'] }
        : { orderBy?: DeviceLookupImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceLookupImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceLookupImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceLookupImage model
   */
  readonly fields: DeviceLookupImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceLookupImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceLookupImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceLookupImage$DeviceEntryArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupImage$DeviceEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeviceImageColors<T extends DeviceLookupImage$DeviceImageColorsArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupImage$DeviceImageColorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceImageColorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceLookupImage model
   */
  interface DeviceLookupImageFieldRefs {
    readonly id: FieldRef<"DeviceLookupImage", 'Int'>
    readonly name: FieldRef<"DeviceLookupImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceLookupImage findUnique
   */
  export type DeviceLookupImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupImage to fetch.
     */
    where: DeviceLookupImageWhereUniqueInput
  }

  /**
   * DeviceLookupImage findUniqueOrThrow
   */
  export type DeviceLookupImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupImage to fetch.
     */
    where: DeviceLookupImageWhereUniqueInput
  }

  /**
   * DeviceLookupImage findFirst
   */
  export type DeviceLookupImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupImage to fetch.
     */
    where?: DeviceLookupImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupImages to fetch.
     */
    orderBy?: DeviceLookupImageOrderByWithRelationInput | DeviceLookupImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupImages.
     */
    cursor?: DeviceLookupImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupImages.
     */
    distinct?: DeviceLookupImageScalarFieldEnum | DeviceLookupImageScalarFieldEnum[]
  }

  /**
   * DeviceLookupImage findFirstOrThrow
   */
  export type DeviceLookupImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupImage to fetch.
     */
    where?: DeviceLookupImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupImages to fetch.
     */
    orderBy?: DeviceLookupImageOrderByWithRelationInput | DeviceLookupImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupImages.
     */
    cursor?: DeviceLookupImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupImages.
     */
    distinct?: DeviceLookupImageScalarFieldEnum | DeviceLookupImageScalarFieldEnum[]
  }

  /**
   * DeviceLookupImage findMany
   */
  export type DeviceLookupImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupImages to fetch.
     */
    where?: DeviceLookupImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupImages to fetch.
     */
    orderBy?: DeviceLookupImageOrderByWithRelationInput | DeviceLookupImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceLookupImages.
     */
    cursor?: DeviceLookupImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupImages.
     */
    skip?: number
    distinct?: DeviceLookupImageScalarFieldEnum | DeviceLookupImageScalarFieldEnum[]
  }

  /**
   * DeviceLookupImage create
   */
  export type DeviceLookupImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceLookupImage.
     */
    data: XOR<DeviceLookupImageCreateInput, DeviceLookupImageUncheckedCreateInput>
  }

  /**
   * DeviceLookupImage createMany
   */
  export type DeviceLookupImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceLookupImages.
     */
    data: DeviceLookupImageCreateManyInput | DeviceLookupImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupImage createManyAndReturn
   */
  export type DeviceLookupImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceLookupImages.
     */
    data: DeviceLookupImageCreateManyInput | DeviceLookupImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupImage update
   */
  export type DeviceLookupImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceLookupImage.
     */
    data: XOR<DeviceLookupImageUpdateInput, DeviceLookupImageUncheckedUpdateInput>
    /**
     * Choose, which DeviceLookupImage to update.
     */
    where: DeviceLookupImageWhereUniqueInput
  }

  /**
   * DeviceLookupImage updateMany
   */
  export type DeviceLookupImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceLookupImages.
     */
    data: XOR<DeviceLookupImageUpdateManyMutationInput, DeviceLookupImageUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupImages to update
     */
    where?: DeviceLookupImageWhereInput
    /**
     * Limit how many DeviceLookupImages to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupImage updateManyAndReturn
   */
  export type DeviceLookupImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * The data used to update DeviceLookupImages.
     */
    data: XOR<DeviceLookupImageUpdateManyMutationInput, DeviceLookupImageUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupImages to update
     */
    where?: DeviceLookupImageWhereInput
    /**
     * Limit how many DeviceLookupImages to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupImage upsert
   */
  export type DeviceLookupImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceLookupImage to update in case it exists.
     */
    where: DeviceLookupImageWhereUniqueInput
    /**
     * In case the DeviceLookupImage found by the `where` argument doesn't exist, create a new DeviceLookupImage with this data.
     */
    create: XOR<DeviceLookupImageCreateInput, DeviceLookupImageUncheckedCreateInput>
    /**
     * In case the DeviceLookupImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceLookupImageUpdateInput, DeviceLookupImageUncheckedUpdateInput>
  }

  /**
   * DeviceLookupImage delete
   */
  export type DeviceLookupImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
    /**
     * Filter which DeviceLookupImage to delete.
     */
    where: DeviceLookupImageWhereUniqueInput
  }

  /**
   * DeviceLookupImage deleteMany
   */
  export type DeviceLookupImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupImages to delete
     */
    where?: DeviceLookupImageWhereInput
    /**
     * Limit how many DeviceLookupImages to delete.
     */
    limit?: number
  }

  /**
   * DeviceLookupImage.DeviceEntry
   */
  export type DeviceLookupImage$DeviceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    where?: DeviceEntryWhereInput
    orderBy?: DeviceEntryOrderByWithRelationInput | DeviceEntryOrderByWithRelationInput[]
    cursor?: DeviceEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceEntryScalarFieldEnum | DeviceEntryScalarFieldEnum[]
  }

  /**
   * DeviceLookupImage.DeviceImageColors
   */
  export type DeviceLookupImage$DeviceImageColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceImageColors
     */
    select?: DeviceImageColorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceImageColors
     */
    omit?: DeviceImageColorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceImageColorsInclude<ExtArgs> | null
    where?: DeviceImageColorsWhereInput
    orderBy?: DeviceImageColorsOrderByWithRelationInput | DeviceImageColorsOrderByWithRelationInput[]
    cursor?: DeviceImageColorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceImageColorsScalarFieldEnum | DeviceImageColorsScalarFieldEnum[]
  }

  /**
   * DeviceLookupImage without action
   */
  export type DeviceLookupImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupImage
     */
    select?: DeviceLookupImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupImage
     */
    omit?: DeviceLookupImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupImageInclude<ExtArgs> | null
  }


  /**
   * Model DeviceLookupSoc
   */

  export type AggregateDeviceLookupSoc = {
    _count: DeviceLookupSocCountAggregateOutputType | null
    _avg: DeviceLookupSocAvgAggregateOutputType | null
    _sum: DeviceLookupSocSumAggregateOutputType | null
    _min: DeviceLookupSocMinAggregateOutputType | null
    _max: DeviceLookupSocMaxAggregateOutputType | null
  }

  export type DeviceLookupSocAvgAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupSocSumAggregateOutputType = {
    id: number | null
  }

  export type DeviceLookupSocMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupSocMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DeviceLookupSocCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DeviceLookupSocAvgAggregateInputType = {
    id?: true
  }

  export type DeviceLookupSocSumAggregateInputType = {
    id?: true
  }

  export type DeviceLookupSocMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupSocMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DeviceLookupSocCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DeviceLookupSocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupSoc to aggregate.
     */
    where?: DeviceLookupSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupSocs to fetch.
     */
    orderBy?: DeviceLookupSocOrderByWithRelationInput | DeviceLookupSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceLookupSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceLookupSocs
    **/
    _count?: true | DeviceLookupSocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceLookupSocAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceLookupSocSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceLookupSocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceLookupSocMaxAggregateInputType
  }

  export type GetDeviceLookupSocAggregateType<T extends DeviceLookupSocAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceLookupSoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceLookupSoc[P]>
      : GetScalarType<T[P], AggregateDeviceLookupSoc[P]>
  }




  export type DeviceLookupSocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceLookupSocWhereInput
    orderBy?: DeviceLookupSocOrderByWithAggregationInput | DeviceLookupSocOrderByWithAggregationInput[]
    by: DeviceLookupSocScalarFieldEnum[] | DeviceLookupSocScalarFieldEnum
    having?: DeviceLookupSocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceLookupSocCountAggregateInputType | true
    _avg?: DeviceLookupSocAvgAggregateInputType
    _sum?: DeviceLookupSocSumAggregateInputType
    _min?: DeviceLookupSocMinAggregateInputType
    _max?: DeviceLookupSocMaxAggregateInputType
  }

  export type DeviceLookupSocGroupByOutputType = {
    id: number
    name: string
    _count: DeviceLookupSocCountAggregateOutputType | null
    _avg: DeviceLookupSocAvgAggregateOutputType | null
    _sum: DeviceLookupSocSumAggregateOutputType | null
    _min: DeviceLookupSocMinAggregateOutputType | null
    _max: DeviceLookupSocMaxAggregateOutputType | null
  }

  type GetDeviceLookupSocGroupByPayload<T extends DeviceLookupSocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceLookupSocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceLookupSocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceLookupSocGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceLookupSocGroupByOutputType[P]>
        }
      >
    >


  export type DeviceLookupSocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DeviceMapSoc?: boolean | DeviceLookupSoc$DeviceMapSocArgs<ExtArgs>
    _count?: boolean | DeviceLookupSocCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceLookupSoc"]>

  export type DeviceLookupSocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupSoc"]>

  export type DeviceLookupSocSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["deviceLookupSoc"]>

  export type DeviceLookupSocSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DeviceLookupSocOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["deviceLookupSoc"]>
  export type DeviceLookupSocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceMapSoc?: boolean | DeviceLookupSoc$DeviceMapSocArgs<ExtArgs>
    _count?: boolean | DeviceLookupSocCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviceLookupSocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeviceLookupSocIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeviceLookupSocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceLookupSoc"
    objects: {
      DeviceMapSoc: Prisma.$DeviceMapSocPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["deviceLookupSoc"]>
    composites: {}
  }

  type DeviceLookupSocGetPayload<S extends boolean | null | undefined | DeviceLookupSocDefaultArgs> = $Result.GetResult<Prisma.$DeviceLookupSocPayload, S>

  type DeviceLookupSocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceLookupSocFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceLookupSocCountAggregateInputType | true
    }

  export interface DeviceLookupSocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceLookupSoc'], meta: { name: 'DeviceLookupSoc' } }
    /**
     * Find zero or one DeviceLookupSoc that matches the filter.
     * @param {DeviceLookupSocFindUniqueArgs} args - Arguments to find a DeviceLookupSoc
     * @example
     * // Get one DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceLookupSocFindUniqueArgs>(args: SelectSubset<T, DeviceLookupSocFindUniqueArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceLookupSoc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceLookupSocFindUniqueOrThrowArgs} args - Arguments to find a DeviceLookupSoc
     * @example
     * // Get one DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceLookupSocFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceLookupSocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupSoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocFindFirstArgs} args - Arguments to find a DeviceLookupSoc
     * @example
     * // Get one DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceLookupSocFindFirstArgs>(args?: SelectSubset<T, DeviceLookupSocFindFirstArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceLookupSoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocFindFirstOrThrowArgs} args - Arguments to find a DeviceLookupSoc
     * @example
     * // Get one DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceLookupSocFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceLookupSocFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceLookupSocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceLookupSocs
     * const deviceLookupSocs = await prisma.deviceLookupSoc.findMany()
     * 
     * // Get first 10 DeviceLookupSocs
     * const deviceLookupSocs = await prisma.deviceLookupSoc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceLookupSocWithIdOnly = await prisma.deviceLookupSoc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceLookupSocFindManyArgs>(args?: SelectSubset<T, DeviceLookupSocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceLookupSoc.
     * @param {DeviceLookupSocCreateArgs} args - Arguments to create a DeviceLookupSoc.
     * @example
     * // Create one DeviceLookupSoc
     * const DeviceLookupSoc = await prisma.deviceLookupSoc.create({
     *   data: {
     *     // ... data to create a DeviceLookupSoc
     *   }
     * })
     * 
     */
    create<T extends DeviceLookupSocCreateArgs>(args: SelectSubset<T, DeviceLookupSocCreateArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceLookupSocs.
     * @param {DeviceLookupSocCreateManyArgs} args - Arguments to create many DeviceLookupSocs.
     * @example
     * // Create many DeviceLookupSocs
     * const deviceLookupSoc = await prisma.deviceLookupSoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceLookupSocCreateManyArgs>(args?: SelectSubset<T, DeviceLookupSocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceLookupSocs and returns the data saved in the database.
     * @param {DeviceLookupSocCreateManyAndReturnArgs} args - Arguments to create many DeviceLookupSocs.
     * @example
     * // Create many DeviceLookupSocs
     * const deviceLookupSoc = await prisma.deviceLookupSoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceLookupSocs and only return the `id`
     * const deviceLookupSocWithIdOnly = await prisma.deviceLookupSoc.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceLookupSocCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceLookupSocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceLookupSoc.
     * @param {DeviceLookupSocDeleteArgs} args - Arguments to delete one DeviceLookupSoc.
     * @example
     * // Delete one DeviceLookupSoc
     * const DeviceLookupSoc = await prisma.deviceLookupSoc.delete({
     *   where: {
     *     // ... filter to delete one DeviceLookupSoc
     *   }
     * })
     * 
     */
    delete<T extends DeviceLookupSocDeleteArgs>(args: SelectSubset<T, DeviceLookupSocDeleteArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceLookupSoc.
     * @param {DeviceLookupSocUpdateArgs} args - Arguments to update one DeviceLookupSoc.
     * @example
     * // Update one DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceLookupSocUpdateArgs>(args: SelectSubset<T, DeviceLookupSocUpdateArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceLookupSocs.
     * @param {DeviceLookupSocDeleteManyArgs} args - Arguments to filter DeviceLookupSocs to delete.
     * @example
     * // Delete a few DeviceLookupSocs
     * const { count } = await prisma.deviceLookupSoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceLookupSocDeleteManyArgs>(args?: SelectSubset<T, DeviceLookupSocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupSocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceLookupSocs
     * const deviceLookupSoc = await prisma.deviceLookupSoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceLookupSocUpdateManyArgs>(args: SelectSubset<T, DeviceLookupSocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceLookupSocs and returns the data updated in the database.
     * @param {DeviceLookupSocUpdateManyAndReturnArgs} args - Arguments to update many DeviceLookupSocs.
     * @example
     * // Update many DeviceLookupSocs
     * const deviceLookupSoc = await prisma.deviceLookupSoc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceLookupSocs and only return the `id`
     * const deviceLookupSocWithIdOnly = await prisma.deviceLookupSoc.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceLookupSocUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceLookupSocUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceLookupSoc.
     * @param {DeviceLookupSocUpsertArgs} args - Arguments to update or create a DeviceLookupSoc.
     * @example
     * // Update or create a DeviceLookupSoc
     * const deviceLookupSoc = await prisma.deviceLookupSoc.upsert({
     *   create: {
     *     // ... data to create a DeviceLookupSoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceLookupSoc we want to update
     *   }
     * })
     */
    upsert<T extends DeviceLookupSocUpsertArgs>(args: SelectSubset<T, DeviceLookupSocUpsertArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceLookupSocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocCountArgs} args - Arguments to filter DeviceLookupSocs to count.
     * @example
     * // Count the number of DeviceLookupSocs
     * const count = await prisma.deviceLookupSoc.count({
     *   where: {
     *     // ... the filter for the DeviceLookupSocs we want to count
     *   }
     * })
    **/
    count<T extends DeviceLookupSocCountArgs>(
      args?: Subset<T, DeviceLookupSocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceLookupSocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceLookupSoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceLookupSocAggregateArgs>(args: Subset<T, DeviceLookupSocAggregateArgs>): Prisma.PrismaPromise<GetDeviceLookupSocAggregateType<T>>

    /**
     * Group by DeviceLookupSoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceLookupSocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceLookupSocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceLookupSocGroupByArgs['orderBy'] }
        : { orderBy?: DeviceLookupSocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceLookupSocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceLookupSocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceLookupSoc model
   */
  readonly fields: DeviceLookupSocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceLookupSoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceLookupSocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceMapSoc<T extends DeviceLookupSoc$DeviceMapSocArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupSoc$DeviceMapSocArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceLookupSoc model
   */
  interface DeviceLookupSocFieldRefs {
    readonly id: FieldRef<"DeviceLookupSoc", 'Int'>
    readonly name: FieldRef<"DeviceLookupSoc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceLookupSoc findUnique
   */
  export type DeviceLookupSocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupSoc to fetch.
     */
    where: DeviceLookupSocWhereUniqueInput
  }

  /**
   * DeviceLookupSoc findUniqueOrThrow
   */
  export type DeviceLookupSocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupSoc to fetch.
     */
    where: DeviceLookupSocWhereUniqueInput
  }

  /**
   * DeviceLookupSoc findFirst
   */
  export type DeviceLookupSocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupSoc to fetch.
     */
    where?: DeviceLookupSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupSocs to fetch.
     */
    orderBy?: DeviceLookupSocOrderByWithRelationInput | DeviceLookupSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupSocs.
     */
    cursor?: DeviceLookupSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupSocs.
     */
    distinct?: DeviceLookupSocScalarFieldEnum | DeviceLookupSocScalarFieldEnum[]
  }

  /**
   * DeviceLookupSoc findFirstOrThrow
   */
  export type DeviceLookupSocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupSoc to fetch.
     */
    where?: DeviceLookupSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupSocs to fetch.
     */
    orderBy?: DeviceLookupSocOrderByWithRelationInput | DeviceLookupSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceLookupSocs.
     */
    cursor?: DeviceLookupSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceLookupSocs.
     */
    distinct?: DeviceLookupSocScalarFieldEnum | DeviceLookupSocScalarFieldEnum[]
  }

  /**
   * DeviceLookupSoc findMany
   */
  export type DeviceLookupSocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceLookupSocs to fetch.
     */
    where?: DeviceLookupSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceLookupSocs to fetch.
     */
    orderBy?: DeviceLookupSocOrderByWithRelationInput | DeviceLookupSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceLookupSocs.
     */
    cursor?: DeviceLookupSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceLookupSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceLookupSocs.
     */
    skip?: number
    distinct?: DeviceLookupSocScalarFieldEnum | DeviceLookupSocScalarFieldEnum[]
  }

  /**
   * DeviceLookupSoc create
   */
  export type DeviceLookupSocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceLookupSoc.
     */
    data: XOR<DeviceLookupSocCreateInput, DeviceLookupSocUncheckedCreateInput>
  }

  /**
   * DeviceLookupSoc createMany
   */
  export type DeviceLookupSocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceLookupSocs.
     */
    data: DeviceLookupSocCreateManyInput | DeviceLookupSocCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupSoc createManyAndReturn
   */
  export type DeviceLookupSocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceLookupSocs.
     */
    data: DeviceLookupSocCreateManyInput | DeviceLookupSocCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceLookupSoc update
   */
  export type DeviceLookupSocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceLookupSoc.
     */
    data: XOR<DeviceLookupSocUpdateInput, DeviceLookupSocUncheckedUpdateInput>
    /**
     * Choose, which DeviceLookupSoc to update.
     */
    where: DeviceLookupSocWhereUniqueInput
  }

  /**
   * DeviceLookupSoc updateMany
   */
  export type DeviceLookupSocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceLookupSocs.
     */
    data: XOR<DeviceLookupSocUpdateManyMutationInput, DeviceLookupSocUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupSocs to update
     */
    where?: DeviceLookupSocWhereInput
    /**
     * Limit how many DeviceLookupSocs to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupSoc updateManyAndReturn
   */
  export type DeviceLookupSocUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * The data used to update DeviceLookupSocs.
     */
    data: XOR<DeviceLookupSocUpdateManyMutationInput, DeviceLookupSocUncheckedUpdateManyInput>
    /**
     * Filter which DeviceLookupSocs to update
     */
    where?: DeviceLookupSocWhereInput
    /**
     * Limit how many DeviceLookupSocs to update.
     */
    limit?: number
  }

  /**
   * DeviceLookupSoc upsert
   */
  export type DeviceLookupSocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceLookupSoc to update in case it exists.
     */
    where: DeviceLookupSocWhereUniqueInput
    /**
     * In case the DeviceLookupSoc found by the `where` argument doesn't exist, create a new DeviceLookupSoc with this data.
     */
    create: XOR<DeviceLookupSocCreateInput, DeviceLookupSocUncheckedCreateInput>
    /**
     * In case the DeviceLookupSoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceLookupSocUpdateInput, DeviceLookupSocUncheckedUpdateInput>
  }

  /**
   * DeviceLookupSoc delete
   */
  export type DeviceLookupSocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
    /**
     * Filter which DeviceLookupSoc to delete.
     */
    where: DeviceLookupSocWhereUniqueInput
  }

  /**
   * DeviceLookupSoc deleteMany
   */
  export type DeviceLookupSocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceLookupSocs to delete
     */
    where?: DeviceLookupSocWhereInput
    /**
     * Limit how many DeviceLookupSocs to delete.
     */
    limit?: number
  }

  /**
   * DeviceLookupSoc.DeviceMapSoc
   */
  export type DeviceLookupSoc$DeviceMapSocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    where?: DeviceMapSocWhereInput
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    cursor?: DeviceMapSocWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceMapSocScalarFieldEnum | DeviceMapSocScalarFieldEnum[]
  }

  /**
   * DeviceLookupSoc without action
   */
  export type DeviceLookupSocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceLookupSoc
     */
    select?: DeviceLookupSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceLookupSoc
     */
    omit?: DeviceLookupSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceLookupSocInclude<ExtArgs> | null
  }


  /**
   * Model DeviceMapArchitecture
   */

  export type AggregateDeviceMapArchitecture = {
    _count: DeviceMapArchitectureCountAggregateOutputType | null
    _avg: DeviceMapArchitectureAvgAggregateOutputType | null
    _sum: DeviceMapArchitectureSumAggregateOutputType | null
    _min: DeviceMapArchitectureMinAggregateOutputType | null
    _max: DeviceMapArchitectureMaxAggregateOutputType | null
  }

  export type DeviceMapArchitectureAvgAggregateOutputType = {
    device_id: number | null
    architecture_id: number | null
  }

  export type DeviceMapArchitectureSumAggregateOutputType = {
    device_id: number | null
    architecture_id: number | null
  }

  export type DeviceMapArchitectureMinAggregateOutputType = {
    device_id: number | null
    architecture_id: number | null
  }

  export type DeviceMapArchitectureMaxAggregateOutputType = {
    device_id: number | null
    architecture_id: number | null
  }

  export type DeviceMapArchitectureCountAggregateOutputType = {
    device_id: number
    architecture_id: number
    _all: number
  }


  export type DeviceMapArchitectureAvgAggregateInputType = {
    device_id?: true
    architecture_id?: true
  }

  export type DeviceMapArchitectureSumAggregateInputType = {
    device_id?: true
    architecture_id?: true
  }

  export type DeviceMapArchitectureMinAggregateInputType = {
    device_id?: true
    architecture_id?: true
  }

  export type DeviceMapArchitectureMaxAggregateInputType = {
    device_id?: true
    architecture_id?: true
  }

  export type DeviceMapArchitectureCountAggregateInputType = {
    device_id?: true
    architecture_id?: true
    _all?: true
  }

  export type DeviceMapArchitectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapArchitecture to aggregate.
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapArchitectures to fetch.
     */
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceMapArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceMapArchitectures
    **/
    _count?: true | DeviceMapArchitectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceMapArchitectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceMapArchitectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMapArchitectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMapArchitectureMaxAggregateInputType
  }

  export type GetDeviceMapArchitectureAggregateType<T extends DeviceMapArchitectureAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceMapArchitecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceMapArchitecture[P]>
      : GetScalarType<T[P], AggregateDeviceMapArchitecture[P]>
  }




  export type DeviceMapArchitectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapArchitectureWhereInput
    orderBy?: DeviceMapArchitectureOrderByWithAggregationInput | DeviceMapArchitectureOrderByWithAggregationInput[]
    by: DeviceMapArchitectureScalarFieldEnum[] | DeviceMapArchitectureScalarFieldEnum
    having?: DeviceMapArchitectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceMapArchitectureCountAggregateInputType | true
    _avg?: DeviceMapArchitectureAvgAggregateInputType
    _sum?: DeviceMapArchitectureSumAggregateInputType
    _min?: DeviceMapArchitectureMinAggregateInputType
    _max?: DeviceMapArchitectureMaxAggregateInputType
  }

  export type DeviceMapArchitectureGroupByOutputType = {
    device_id: number
    architecture_id: number
    _count: DeviceMapArchitectureCountAggregateOutputType | null
    _avg: DeviceMapArchitectureAvgAggregateOutputType | null
    _sum: DeviceMapArchitectureSumAggregateOutputType | null
    _min: DeviceMapArchitectureMinAggregateOutputType | null
    _max: DeviceMapArchitectureMaxAggregateOutputType | null
  }

  type GetDeviceMapArchitectureGroupByPayload<T extends DeviceMapArchitectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceMapArchitectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceMapArchitectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceMapArchitectureGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceMapArchitectureGroupByOutputType[P]>
        }
      >
    >


  export type DeviceMapArchitectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    architecture_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapArchitecture"]>

  export type DeviceMapArchitectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    architecture_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapArchitecture"]>

  export type DeviceMapArchitectureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    architecture_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapArchitecture"]>

  export type DeviceMapArchitectureSelectScalar = {
    device_id?: boolean
    architecture_id?: boolean
  }

  export type DeviceMapArchitectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_id" | "architecture_id", ExtArgs["result"]["deviceMapArchitecture"]>
  export type DeviceMapArchitectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }
  export type DeviceMapArchitectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }
  export type DeviceMapArchitectureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupArchitecture?: boolean | DeviceLookupArchitectureDefaultArgs<ExtArgs>
  }

  export type $DeviceMapArchitecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceMapArchitecture"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
      DeviceLookupArchitecture: Prisma.$DeviceLookupArchitecturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_id: number
      architecture_id: number
    }, ExtArgs["result"]["deviceMapArchitecture"]>
    composites: {}
  }

  type DeviceMapArchitectureGetPayload<S extends boolean | null | undefined | DeviceMapArchitectureDefaultArgs> = $Result.GetResult<Prisma.$DeviceMapArchitecturePayload, S>

  type DeviceMapArchitectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceMapArchitectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceMapArchitectureCountAggregateInputType | true
    }

  export interface DeviceMapArchitectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceMapArchitecture'], meta: { name: 'DeviceMapArchitecture' } }
    /**
     * Find zero or one DeviceMapArchitecture that matches the filter.
     * @param {DeviceMapArchitectureFindUniqueArgs} args - Arguments to find a DeviceMapArchitecture
     * @example
     * // Get one DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceMapArchitectureFindUniqueArgs>(args: SelectSubset<T, DeviceMapArchitectureFindUniqueArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceMapArchitecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceMapArchitectureFindUniqueOrThrowArgs} args - Arguments to find a DeviceMapArchitecture
     * @example
     * // Get one DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceMapArchitectureFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceMapArchitectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapArchitecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureFindFirstArgs} args - Arguments to find a DeviceMapArchitecture
     * @example
     * // Get one DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceMapArchitectureFindFirstArgs>(args?: SelectSubset<T, DeviceMapArchitectureFindFirstArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapArchitecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureFindFirstOrThrowArgs} args - Arguments to find a DeviceMapArchitecture
     * @example
     * // Get one DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceMapArchitectureFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceMapArchitectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceMapArchitectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceMapArchitectures
     * const deviceMapArchitectures = await prisma.deviceMapArchitecture.findMany()
     * 
     * // Get first 10 DeviceMapArchitectures
     * const deviceMapArchitectures = await prisma.deviceMapArchitecture.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceMapArchitectureWithDevice_idOnly = await prisma.deviceMapArchitecture.findMany({ select: { device_id: true } })
     * 
     */
    findMany<T extends DeviceMapArchitectureFindManyArgs>(args?: SelectSubset<T, DeviceMapArchitectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceMapArchitecture.
     * @param {DeviceMapArchitectureCreateArgs} args - Arguments to create a DeviceMapArchitecture.
     * @example
     * // Create one DeviceMapArchitecture
     * const DeviceMapArchitecture = await prisma.deviceMapArchitecture.create({
     *   data: {
     *     // ... data to create a DeviceMapArchitecture
     *   }
     * })
     * 
     */
    create<T extends DeviceMapArchitectureCreateArgs>(args: SelectSubset<T, DeviceMapArchitectureCreateArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceMapArchitectures.
     * @param {DeviceMapArchitectureCreateManyArgs} args - Arguments to create many DeviceMapArchitectures.
     * @example
     * // Create many DeviceMapArchitectures
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceMapArchitectureCreateManyArgs>(args?: SelectSubset<T, DeviceMapArchitectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceMapArchitectures and returns the data saved in the database.
     * @param {DeviceMapArchitectureCreateManyAndReturnArgs} args - Arguments to create many DeviceMapArchitectures.
     * @example
     * // Create many DeviceMapArchitectures
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceMapArchitectures and only return the `device_id`
     * const deviceMapArchitectureWithDevice_idOnly = await prisma.deviceMapArchitecture.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceMapArchitectureCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceMapArchitectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceMapArchitecture.
     * @param {DeviceMapArchitectureDeleteArgs} args - Arguments to delete one DeviceMapArchitecture.
     * @example
     * // Delete one DeviceMapArchitecture
     * const DeviceMapArchitecture = await prisma.deviceMapArchitecture.delete({
     *   where: {
     *     // ... filter to delete one DeviceMapArchitecture
     *   }
     * })
     * 
     */
    delete<T extends DeviceMapArchitectureDeleteArgs>(args: SelectSubset<T, DeviceMapArchitectureDeleteArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceMapArchitecture.
     * @param {DeviceMapArchitectureUpdateArgs} args - Arguments to update one DeviceMapArchitecture.
     * @example
     * // Update one DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceMapArchitectureUpdateArgs>(args: SelectSubset<T, DeviceMapArchitectureUpdateArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceMapArchitectures.
     * @param {DeviceMapArchitectureDeleteManyArgs} args - Arguments to filter DeviceMapArchitectures to delete.
     * @example
     * // Delete a few DeviceMapArchitectures
     * const { count } = await prisma.deviceMapArchitecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceMapArchitectureDeleteManyArgs>(args?: SelectSubset<T, DeviceMapArchitectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceMapArchitectures
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceMapArchitectureUpdateManyArgs>(args: SelectSubset<T, DeviceMapArchitectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapArchitectures and returns the data updated in the database.
     * @param {DeviceMapArchitectureUpdateManyAndReturnArgs} args - Arguments to update many DeviceMapArchitectures.
     * @example
     * // Update many DeviceMapArchitectures
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceMapArchitectures and only return the `device_id`
     * const deviceMapArchitectureWithDevice_idOnly = await prisma.deviceMapArchitecture.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceMapArchitectureUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceMapArchitectureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceMapArchitecture.
     * @param {DeviceMapArchitectureUpsertArgs} args - Arguments to update or create a DeviceMapArchitecture.
     * @example
     * // Update or create a DeviceMapArchitecture
     * const deviceMapArchitecture = await prisma.deviceMapArchitecture.upsert({
     *   create: {
     *     // ... data to create a DeviceMapArchitecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceMapArchitecture we want to update
     *   }
     * })
     */
    upsert<T extends DeviceMapArchitectureUpsertArgs>(args: SelectSubset<T, DeviceMapArchitectureUpsertArgs<ExtArgs>>): Prisma__DeviceMapArchitectureClient<$Result.GetResult<Prisma.$DeviceMapArchitecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceMapArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureCountArgs} args - Arguments to filter DeviceMapArchitectures to count.
     * @example
     * // Count the number of DeviceMapArchitectures
     * const count = await prisma.deviceMapArchitecture.count({
     *   where: {
     *     // ... the filter for the DeviceMapArchitectures we want to count
     *   }
     * })
    **/
    count<T extends DeviceMapArchitectureCountArgs>(
      args?: Subset<T, DeviceMapArchitectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceMapArchitectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceMapArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceMapArchitectureAggregateArgs>(args: Subset<T, DeviceMapArchitectureAggregateArgs>): Prisma.PrismaPromise<GetDeviceMapArchitectureAggregateType<T>>

    /**
     * Group by DeviceMapArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapArchitectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceMapArchitectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceMapArchitectureGroupByArgs['orderBy'] }
        : { orderBy?: DeviceMapArchitectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceMapArchitectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceMapArchitectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceMapArchitecture model
   */
  readonly fields: DeviceMapArchitectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceMapArchitecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceMapArchitectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceLookupArchitecture<T extends DeviceLookupArchitectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupArchitectureDefaultArgs<ExtArgs>>): Prisma__DeviceLookupArchitectureClient<$Result.GetResult<Prisma.$DeviceLookupArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceMapArchitecture model
   */
  interface DeviceMapArchitectureFieldRefs {
    readonly device_id: FieldRef<"DeviceMapArchitecture", 'Int'>
    readonly architecture_id: FieldRef<"DeviceMapArchitecture", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceMapArchitecture findUnique
   */
  export type DeviceMapArchitectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapArchitecture to fetch.
     */
    where: DeviceMapArchitectureWhereUniqueInput
  }

  /**
   * DeviceMapArchitecture findUniqueOrThrow
   */
  export type DeviceMapArchitectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapArchitecture to fetch.
     */
    where: DeviceMapArchitectureWhereUniqueInput
  }

  /**
   * DeviceMapArchitecture findFirst
   */
  export type DeviceMapArchitectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapArchitecture to fetch.
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapArchitectures to fetch.
     */
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapArchitectures.
     */
    cursor?: DeviceMapArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapArchitectures.
     */
    distinct?: DeviceMapArchitectureScalarFieldEnum | DeviceMapArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceMapArchitecture findFirstOrThrow
   */
  export type DeviceMapArchitectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapArchitecture to fetch.
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapArchitectures to fetch.
     */
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapArchitectures.
     */
    cursor?: DeviceMapArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapArchitectures.
     */
    distinct?: DeviceMapArchitectureScalarFieldEnum | DeviceMapArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceMapArchitecture findMany
   */
  export type DeviceMapArchitectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapArchitectures to fetch.
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapArchitectures to fetch.
     */
    orderBy?: DeviceMapArchitectureOrderByWithRelationInput | DeviceMapArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceMapArchitectures.
     */
    cursor?: DeviceMapArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapArchitectures.
     */
    skip?: number
    distinct?: DeviceMapArchitectureScalarFieldEnum | DeviceMapArchitectureScalarFieldEnum[]
  }

  /**
   * DeviceMapArchitecture create
   */
  export type DeviceMapArchitectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceMapArchitecture.
     */
    data: XOR<DeviceMapArchitectureCreateInput, DeviceMapArchitectureUncheckedCreateInput>
  }

  /**
   * DeviceMapArchitecture createMany
   */
  export type DeviceMapArchitectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceMapArchitectures.
     */
    data: DeviceMapArchitectureCreateManyInput | DeviceMapArchitectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceMapArchitecture createManyAndReturn
   */
  export type DeviceMapArchitectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceMapArchitectures.
     */
    data: DeviceMapArchitectureCreateManyInput | DeviceMapArchitectureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapArchitecture update
   */
  export type DeviceMapArchitectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceMapArchitecture.
     */
    data: XOR<DeviceMapArchitectureUpdateInput, DeviceMapArchitectureUncheckedUpdateInput>
    /**
     * Choose, which DeviceMapArchitecture to update.
     */
    where: DeviceMapArchitectureWhereUniqueInput
  }

  /**
   * DeviceMapArchitecture updateMany
   */
  export type DeviceMapArchitectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceMapArchitectures.
     */
    data: XOR<DeviceMapArchitectureUpdateManyMutationInput, DeviceMapArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapArchitectures to update
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * Limit how many DeviceMapArchitectures to update.
     */
    limit?: number
  }

  /**
   * DeviceMapArchitecture updateManyAndReturn
   */
  export type DeviceMapArchitectureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * The data used to update DeviceMapArchitectures.
     */
    data: XOR<DeviceMapArchitectureUpdateManyMutationInput, DeviceMapArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapArchitectures to update
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * Limit how many DeviceMapArchitectures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapArchitecture upsert
   */
  export type DeviceMapArchitectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceMapArchitecture to update in case it exists.
     */
    where: DeviceMapArchitectureWhereUniqueInput
    /**
     * In case the DeviceMapArchitecture found by the `where` argument doesn't exist, create a new DeviceMapArchitecture with this data.
     */
    create: XOR<DeviceMapArchitectureCreateInput, DeviceMapArchitectureUncheckedCreateInput>
    /**
     * In case the DeviceMapArchitecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceMapArchitectureUpdateInput, DeviceMapArchitectureUncheckedUpdateInput>
  }

  /**
   * DeviceMapArchitecture delete
   */
  export type DeviceMapArchitectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
    /**
     * Filter which DeviceMapArchitecture to delete.
     */
    where: DeviceMapArchitectureWhereUniqueInput
  }

  /**
   * DeviceMapArchitecture deleteMany
   */
  export type DeviceMapArchitectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapArchitectures to delete
     */
    where?: DeviceMapArchitectureWhereInput
    /**
     * Limit how many DeviceMapArchitectures to delete.
     */
    limit?: number
  }

  /**
   * DeviceMapArchitecture without action
   */
  export type DeviceMapArchitectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapArchitecture
     */
    select?: DeviceMapArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapArchitecture
     */
    omit?: DeviceMapArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapArchitectureInclude<ExtArgs> | null
  }


  /**
   * Model DeviceMapIdentifier
   */

  export type AggregateDeviceMapIdentifier = {
    _count: DeviceMapIdentifierCountAggregateOutputType | null
    _avg: DeviceMapIdentifierAvgAggregateOutputType | null
    _sum: DeviceMapIdentifierSumAggregateOutputType | null
    _min: DeviceMapIdentifierMinAggregateOutputType | null
    _max: DeviceMapIdentifierMaxAggregateOutputType | null
  }

  export type DeviceMapIdentifierAvgAggregateOutputType = {
    device_id: number | null
  }

  export type DeviceMapIdentifierSumAggregateOutputType = {
    device_id: number | null
  }

  export type DeviceMapIdentifierMinAggregateOutputType = {
    device_id: number | null
    identifier: string | null
  }

  export type DeviceMapIdentifierMaxAggregateOutputType = {
    device_id: number | null
    identifier: string | null
  }

  export type DeviceMapIdentifierCountAggregateOutputType = {
    device_id: number
    identifier: number
    _all: number
  }


  export type DeviceMapIdentifierAvgAggregateInputType = {
    device_id?: true
  }

  export type DeviceMapIdentifierSumAggregateInputType = {
    device_id?: true
  }

  export type DeviceMapIdentifierMinAggregateInputType = {
    device_id?: true
    identifier?: true
  }

  export type DeviceMapIdentifierMaxAggregateInputType = {
    device_id?: true
    identifier?: true
  }

  export type DeviceMapIdentifierCountAggregateInputType = {
    device_id?: true
    identifier?: true
    _all?: true
  }

  export type DeviceMapIdentifierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapIdentifier to aggregate.
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapIdentifiers to fetch.
     */
    orderBy?: DeviceMapIdentifierOrderByWithRelationInput | DeviceMapIdentifierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceMapIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapIdentifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapIdentifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceMapIdentifiers
    **/
    _count?: true | DeviceMapIdentifierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceMapIdentifierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceMapIdentifierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMapIdentifierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMapIdentifierMaxAggregateInputType
  }

  export type GetDeviceMapIdentifierAggregateType<T extends DeviceMapIdentifierAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceMapIdentifier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceMapIdentifier[P]>
      : GetScalarType<T[P], AggregateDeviceMapIdentifier[P]>
  }




  export type DeviceMapIdentifierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapIdentifierWhereInput
    orderBy?: DeviceMapIdentifierOrderByWithAggregationInput | DeviceMapIdentifierOrderByWithAggregationInput[]
    by: DeviceMapIdentifierScalarFieldEnum[] | DeviceMapIdentifierScalarFieldEnum
    having?: DeviceMapIdentifierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceMapIdentifierCountAggregateInputType | true
    _avg?: DeviceMapIdentifierAvgAggregateInputType
    _sum?: DeviceMapIdentifierSumAggregateInputType
    _min?: DeviceMapIdentifierMinAggregateInputType
    _max?: DeviceMapIdentifierMaxAggregateInputType
  }

  export type DeviceMapIdentifierGroupByOutputType = {
    device_id: number
    identifier: string
    _count: DeviceMapIdentifierCountAggregateOutputType | null
    _avg: DeviceMapIdentifierAvgAggregateOutputType | null
    _sum: DeviceMapIdentifierSumAggregateOutputType | null
    _min: DeviceMapIdentifierMinAggregateOutputType | null
    _max: DeviceMapIdentifierMaxAggregateOutputType | null
  }

  type GetDeviceMapIdentifierGroupByPayload<T extends DeviceMapIdentifierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceMapIdentifierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceMapIdentifierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceMapIdentifierGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceMapIdentifierGroupByOutputType[P]>
        }
      >
    >


  export type DeviceMapIdentifierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    identifier?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapIdentifier"]>

  export type DeviceMapIdentifierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    identifier?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapIdentifier"]>

  export type DeviceMapIdentifierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    identifier?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapIdentifier"]>

  export type DeviceMapIdentifierSelectScalar = {
    device_id?: boolean
    identifier?: boolean
  }

  export type DeviceMapIdentifierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_id" | "identifier", ExtArgs["result"]["deviceMapIdentifier"]>
  export type DeviceMapIdentifierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceMapIdentifierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceMapIdentifierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }

  export type $DeviceMapIdentifierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceMapIdentifier"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_id: number
      identifier: string
    }, ExtArgs["result"]["deviceMapIdentifier"]>
    composites: {}
  }

  type DeviceMapIdentifierGetPayload<S extends boolean | null | undefined | DeviceMapIdentifierDefaultArgs> = $Result.GetResult<Prisma.$DeviceMapIdentifierPayload, S>

  type DeviceMapIdentifierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceMapIdentifierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceMapIdentifierCountAggregateInputType | true
    }

  export interface DeviceMapIdentifierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceMapIdentifier'], meta: { name: 'DeviceMapIdentifier' } }
    /**
     * Find zero or one DeviceMapIdentifier that matches the filter.
     * @param {DeviceMapIdentifierFindUniqueArgs} args - Arguments to find a DeviceMapIdentifier
     * @example
     * // Get one DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceMapIdentifierFindUniqueArgs>(args: SelectSubset<T, DeviceMapIdentifierFindUniqueArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceMapIdentifier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceMapIdentifierFindUniqueOrThrowArgs} args - Arguments to find a DeviceMapIdentifier
     * @example
     * // Get one DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceMapIdentifierFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceMapIdentifierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapIdentifier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierFindFirstArgs} args - Arguments to find a DeviceMapIdentifier
     * @example
     * // Get one DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceMapIdentifierFindFirstArgs>(args?: SelectSubset<T, DeviceMapIdentifierFindFirstArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapIdentifier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierFindFirstOrThrowArgs} args - Arguments to find a DeviceMapIdentifier
     * @example
     * // Get one DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceMapIdentifierFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceMapIdentifierFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceMapIdentifiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceMapIdentifiers
     * const deviceMapIdentifiers = await prisma.deviceMapIdentifier.findMany()
     * 
     * // Get first 10 DeviceMapIdentifiers
     * const deviceMapIdentifiers = await prisma.deviceMapIdentifier.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceMapIdentifierWithDevice_idOnly = await prisma.deviceMapIdentifier.findMany({ select: { device_id: true } })
     * 
     */
    findMany<T extends DeviceMapIdentifierFindManyArgs>(args?: SelectSubset<T, DeviceMapIdentifierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceMapIdentifier.
     * @param {DeviceMapIdentifierCreateArgs} args - Arguments to create a DeviceMapIdentifier.
     * @example
     * // Create one DeviceMapIdentifier
     * const DeviceMapIdentifier = await prisma.deviceMapIdentifier.create({
     *   data: {
     *     // ... data to create a DeviceMapIdentifier
     *   }
     * })
     * 
     */
    create<T extends DeviceMapIdentifierCreateArgs>(args: SelectSubset<T, DeviceMapIdentifierCreateArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceMapIdentifiers.
     * @param {DeviceMapIdentifierCreateManyArgs} args - Arguments to create many DeviceMapIdentifiers.
     * @example
     * // Create many DeviceMapIdentifiers
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceMapIdentifierCreateManyArgs>(args?: SelectSubset<T, DeviceMapIdentifierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceMapIdentifiers and returns the data saved in the database.
     * @param {DeviceMapIdentifierCreateManyAndReturnArgs} args - Arguments to create many DeviceMapIdentifiers.
     * @example
     * // Create many DeviceMapIdentifiers
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceMapIdentifiers and only return the `device_id`
     * const deviceMapIdentifierWithDevice_idOnly = await prisma.deviceMapIdentifier.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceMapIdentifierCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceMapIdentifierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceMapIdentifier.
     * @param {DeviceMapIdentifierDeleteArgs} args - Arguments to delete one DeviceMapIdentifier.
     * @example
     * // Delete one DeviceMapIdentifier
     * const DeviceMapIdentifier = await prisma.deviceMapIdentifier.delete({
     *   where: {
     *     // ... filter to delete one DeviceMapIdentifier
     *   }
     * })
     * 
     */
    delete<T extends DeviceMapIdentifierDeleteArgs>(args: SelectSubset<T, DeviceMapIdentifierDeleteArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceMapIdentifier.
     * @param {DeviceMapIdentifierUpdateArgs} args - Arguments to update one DeviceMapIdentifier.
     * @example
     * // Update one DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceMapIdentifierUpdateArgs>(args: SelectSubset<T, DeviceMapIdentifierUpdateArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceMapIdentifiers.
     * @param {DeviceMapIdentifierDeleteManyArgs} args - Arguments to filter DeviceMapIdentifiers to delete.
     * @example
     * // Delete a few DeviceMapIdentifiers
     * const { count } = await prisma.deviceMapIdentifier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceMapIdentifierDeleteManyArgs>(args?: SelectSubset<T, DeviceMapIdentifierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapIdentifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceMapIdentifiers
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceMapIdentifierUpdateManyArgs>(args: SelectSubset<T, DeviceMapIdentifierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapIdentifiers and returns the data updated in the database.
     * @param {DeviceMapIdentifierUpdateManyAndReturnArgs} args - Arguments to update many DeviceMapIdentifiers.
     * @example
     * // Update many DeviceMapIdentifiers
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceMapIdentifiers and only return the `device_id`
     * const deviceMapIdentifierWithDevice_idOnly = await prisma.deviceMapIdentifier.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceMapIdentifierUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceMapIdentifierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceMapIdentifier.
     * @param {DeviceMapIdentifierUpsertArgs} args - Arguments to update or create a DeviceMapIdentifier.
     * @example
     * // Update or create a DeviceMapIdentifier
     * const deviceMapIdentifier = await prisma.deviceMapIdentifier.upsert({
     *   create: {
     *     // ... data to create a DeviceMapIdentifier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceMapIdentifier we want to update
     *   }
     * })
     */
    upsert<T extends DeviceMapIdentifierUpsertArgs>(args: SelectSubset<T, DeviceMapIdentifierUpsertArgs<ExtArgs>>): Prisma__DeviceMapIdentifierClient<$Result.GetResult<Prisma.$DeviceMapIdentifierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceMapIdentifiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierCountArgs} args - Arguments to filter DeviceMapIdentifiers to count.
     * @example
     * // Count the number of DeviceMapIdentifiers
     * const count = await prisma.deviceMapIdentifier.count({
     *   where: {
     *     // ... the filter for the DeviceMapIdentifiers we want to count
     *   }
     * })
    **/
    count<T extends DeviceMapIdentifierCountArgs>(
      args?: Subset<T, DeviceMapIdentifierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceMapIdentifierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceMapIdentifier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceMapIdentifierAggregateArgs>(args: Subset<T, DeviceMapIdentifierAggregateArgs>): Prisma.PrismaPromise<GetDeviceMapIdentifierAggregateType<T>>

    /**
     * Group by DeviceMapIdentifier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapIdentifierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceMapIdentifierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceMapIdentifierGroupByArgs['orderBy'] }
        : { orderBy?: DeviceMapIdentifierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceMapIdentifierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceMapIdentifierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceMapIdentifier model
   */
  readonly fields: DeviceMapIdentifierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceMapIdentifier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceMapIdentifierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceMapIdentifier model
   */
  interface DeviceMapIdentifierFieldRefs {
    readonly device_id: FieldRef<"DeviceMapIdentifier", 'Int'>
    readonly identifier: FieldRef<"DeviceMapIdentifier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceMapIdentifier findUnique
   */
  export type DeviceMapIdentifierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapIdentifier to fetch.
     */
    where: DeviceMapIdentifierWhereUniqueInput
  }

  /**
   * DeviceMapIdentifier findUniqueOrThrow
   */
  export type DeviceMapIdentifierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapIdentifier to fetch.
     */
    where: DeviceMapIdentifierWhereUniqueInput
  }

  /**
   * DeviceMapIdentifier findFirst
   */
  export type DeviceMapIdentifierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapIdentifier to fetch.
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapIdentifiers to fetch.
     */
    orderBy?: DeviceMapIdentifierOrderByWithRelationInput | DeviceMapIdentifierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapIdentifiers.
     */
    cursor?: DeviceMapIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapIdentifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapIdentifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapIdentifiers.
     */
    distinct?: DeviceMapIdentifierScalarFieldEnum | DeviceMapIdentifierScalarFieldEnum[]
  }

  /**
   * DeviceMapIdentifier findFirstOrThrow
   */
  export type DeviceMapIdentifierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapIdentifier to fetch.
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapIdentifiers to fetch.
     */
    orderBy?: DeviceMapIdentifierOrderByWithRelationInput | DeviceMapIdentifierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapIdentifiers.
     */
    cursor?: DeviceMapIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapIdentifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapIdentifiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapIdentifiers.
     */
    distinct?: DeviceMapIdentifierScalarFieldEnum | DeviceMapIdentifierScalarFieldEnum[]
  }

  /**
   * DeviceMapIdentifier findMany
   */
  export type DeviceMapIdentifierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapIdentifiers to fetch.
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapIdentifiers to fetch.
     */
    orderBy?: DeviceMapIdentifierOrderByWithRelationInput | DeviceMapIdentifierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceMapIdentifiers.
     */
    cursor?: DeviceMapIdentifierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapIdentifiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapIdentifiers.
     */
    skip?: number
    distinct?: DeviceMapIdentifierScalarFieldEnum | DeviceMapIdentifierScalarFieldEnum[]
  }

  /**
   * DeviceMapIdentifier create
   */
  export type DeviceMapIdentifierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceMapIdentifier.
     */
    data: XOR<DeviceMapIdentifierCreateInput, DeviceMapIdentifierUncheckedCreateInput>
  }

  /**
   * DeviceMapIdentifier createMany
   */
  export type DeviceMapIdentifierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceMapIdentifiers.
     */
    data: DeviceMapIdentifierCreateManyInput | DeviceMapIdentifierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceMapIdentifier createManyAndReturn
   */
  export type DeviceMapIdentifierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceMapIdentifiers.
     */
    data: DeviceMapIdentifierCreateManyInput | DeviceMapIdentifierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapIdentifier update
   */
  export type DeviceMapIdentifierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceMapIdentifier.
     */
    data: XOR<DeviceMapIdentifierUpdateInput, DeviceMapIdentifierUncheckedUpdateInput>
    /**
     * Choose, which DeviceMapIdentifier to update.
     */
    where: DeviceMapIdentifierWhereUniqueInput
  }

  /**
   * DeviceMapIdentifier updateMany
   */
  export type DeviceMapIdentifierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceMapIdentifiers.
     */
    data: XOR<DeviceMapIdentifierUpdateManyMutationInput, DeviceMapIdentifierUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapIdentifiers to update
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * Limit how many DeviceMapIdentifiers to update.
     */
    limit?: number
  }

  /**
   * DeviceMapIdentifier updateManyAndReturn
   */
  export type DeviceMapIdentifierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * The data used to update DeviceMapIdentifiers.
     */
    data: XOR<DeviceMapIdentifierUpdateManyMutationInput, DeviceMapIdentifierUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapIdentifiers to update
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * Limit how many DeviceMapIdentifiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapIdentifier upsert
   */
  export type DeviceMapIdentifierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceMapIdentifier to update in case it exists.
     */
    where: DeviceMapIdentifierWhereUniqueInput
    /**
     * In case the DeviceMapIdentifier found by the `where` argument doesn't exist, create a new DeviceMapIdentifier with this data.
     */
    create: XOR<DeviceMapIdentifierCreateInput, DeviceMapIdentifierUncheckedCreateInput>
    /**
     * In case the DeviceMapIdentifier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceMapIdentifierUpdateInput, DeviceMapIdentifierUncheckedUpdateInput>
  }

  /**
   * DeviceMapIdentifier delete
   */
  export type DeviceMapIdentifierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
    /**
     * Filter which DeviceMapIdentifier to delete.
     */
    where: DeviceMapIdentifierWhereUniqueInput
  }

  /**
   * DeviceMapIdentifier deleteMany
   */
  export type DeviceMapIdentifierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapIdentifiers to delete
     */
    where?: DeviceMapIdentifierWhereInput
    /**
     * Limit how many DeviceMapIdentifiers to delete.
     */
    limit?: number
  }

  /**
   * DeviceMapIdentifier without action
   */
  export type DeviceMapIdentifierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapIdentifier
     */
    select?: DeviceMapIdentifierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapIdentifier
     */
    omit?: DeviceMapIdentifierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapIdentifierInclude<ExtArgs> | null
  }


  /**
   * Model DeviceMapModel
   */

  export type AggregateDeviceMapModel = {
    _count: DeviceMapModelCountAggregateOutputType | null
    _avg: DeviceMapModelAvgAggregateOutputType | null
    _sum: DeviceMapModelSumAggregateOutputType | null
    _min: DeviceMapModelMinAggregateOutputType | null
    _max: DeviceMapModelMaxAggregateOutputType | null
  }

  export type DeviceMapModelAvgAggregateOutputType = {
    device_id: number | null
  }

  export type DeviceMapModelSumAggregateOutputType = {
    device_id: number | null
  }

  export type DeviceMapModelMinAggregateOutputType = {
    device_id: number | null
    model: string | null
  }

  export type DeviceMapModelMaxAggregateOutputType = {
    device_id: number | null
    model: string | null
  }

  export type DeviceMapModelCountAggregateOutputType = {
    device_id: number
    model: number
    _all: number
  }


  export type DeviceMapModelAvgAggregateInputType = {
    device_id?: true
  }

  export type DeviceMapModelSumAggregateInputType = {
    device_id?: true
  }

  export type DeviceMapModelMinAggregateInputType = {
    device_id?: true
    model?: true
  }

  export type DeviceMapModelMaxAggregateInputType = {
    device_id?: true
    model?: true
  }

  export type DeviceMapModelCountAggregateInputType = {
    device_id?: true
    model?: true
    _all?: true
  }

  export type DeviceMapModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapModel to aggregate.
     */
    where?: DeviceMapModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapModels to fetch.
     */
    orderBy?: DeviceMapModelOrderByWithRelationInput | DeviceMapModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceMapModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceMapModels
    **/
    _count?: true | DeviceMapModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceMapModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceMapModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMapModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMapModelMaxAggregateInputType
  }

  export type GetDeviceMapModelAggregateType<T extends DeviceMapModelAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceMapModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceMapModel[P]>
      : GetScalarType<T[P], AggregateDeviceMapModel[P]>
  }




  export type DeviceMapModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapModelWhereInput
    orderBy?: DeviceMapModelOrderByWithAggregationInput | DeviceMapModelOrderByWithAggregationInput[]
    by: DeviceMapModelScalarFieldEnum[] | DeviceMapModelScalarFieldEnum
    having?: DeviceMapModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceMapModelCountAggregateInputType | true
    _avg?: DeviceMapModelAvgAggregateInputType
    _sum?: DeviceMapModelSumAggregateInputType
    _min?: DeviceMapModelMinAggregateInputType
    _max?: DeviceMapModelMaxAggregateInputType
  }

  export type DeviceMapModelGroupByOutputType = {
    device_id: number
    model: string
    _count: DeviceMapModelCountAggregateOutputType | null
    _avg: DeviceMapModelAvgAggregateOutputType | null
    _sum: DeviceMapModelSumAggregateOutputType | null
    _min: DeviceMapModelMinAggregateOutputType | null
    _max: DeviceMapModelMaxAggregateOutputType | null
  }

  type GetDeviceMapModelGroupByPayload<T extends DeviceMapModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceMapModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceMapModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceMapModelGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceMapModelGroupByOutputType[P]>
        }
      >
    >


  export type DeviceMapModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    model?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapModel"]>

  export type DeviceMapModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    model?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapModel"]>

  export type DeviceMapModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    model?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapModel"]>

  export type DeviceMapModelSelectScalar = {
    device_id?: boolean
    model?: boolean
  }

  export type DeviceMapModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_id" | "model", ExtArgs["result"]["deviceMapModel"]>
  export type DeviceMapModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceMapModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type DeviceMapModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }

  export type $DeviceMapModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceMapModel"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_id: number
      model: string
    }, ExtArgs["result"]["deviceMapModel"]>
    composites: {}
  }

  type DeviceMapModelGetPayload<S extends boolean | null | undefined | DeviceMapModelDefaultArgs> = $Result.GetResult<Prisma.$DeviceMapModelPayload, S>

  type DeviceMapModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceMapModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceMapModelCountAggregateInputType | true
    }

  export interface DeviceMapModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceMapModel'], meta: { name: 'DeviceMapModel' } }
    /**
     * Find zero or one DeviceMapModel that matches the filter.
     * @param {DeviceMapModelFindUniqueArgs} args - Arguments to find a DeviceMapModel
     * @example
     * // Get one DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceMapModelFindUniqueArgs>(args: SelectSubset<T, DeviceMapModelFindUniqueArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceMapModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceMapModelFindUniqueOrThrowArgs} args - Arguments to find a DeviceMapModel
     * @example
     * // Get one DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceMapModelFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceMapModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelFindFirstArgs} args - Arguments to find a DeviceMapModel
     * @example
     * // Get one DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceMapModelFindFirstArgs>(args?: SelectSubset<T, DeviceMapModelFindFirstArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelFindFirstOrThrowArgs} args - Arguments to find a DeviceMapModel
     * @example
     * // Get one DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceMapModelFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceMapModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceMapModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceMapModels
     * const deviceMapModels = await prisma.deviceMapModel.findMany()
     * 
     * // Get first 10 DeviceMapModels
     * const deviceMapModels = await prisma.deviceMapModel.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceMapModelWithDevice_idOnly = await prisma.deviceMapModel.findMany({ select: { device_id: true } })
     * 
     */
    findMany<T extends DeviceMapModelFindManyArgs>(args?: SelectSubset<T, DeviceMapModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceMapModel.
     * @param {DeviceMapModelCreateArgs} args - Arguments to create a DeviceMapModel.
     * @example
     * // Create one DeviceMapModel
     * const DeviceMapModel = await prisma.deviceMapModel.create({
     *   data: {
     *     // ... data to create a DeviceMapModel
     *   }
     * })
     * 
     */
    create<T extends DeviceMapModelCreateArgs>(args: SelectSubset<T, DeviceMapModelCreateArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceMapModels.
     * @param {DeviceMapModelCreateManyArgs} args - Arguments to create many DeviceMapModels.
     * @example
     * // Create many DeviceMapModels
     * const deviceMapModel = await prisma.deviceMapModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceMapModelCreateManyArgs>(args?: SelectSubset<T, DeviceMapModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceMapModels and returns the data saved in the database.
     * @param {DeviceMapModelCreateManyAndReturnArgs} args - Arguments to create many DeviceMapModels.
     * @example
     * // Create many DeviceMapModels
     * const deviceMapModel = await prisma.deviceMapModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceMapModels and only return the `device_id`
     * const deviceMapModelWithDevice_idOnly = await prisma.deviceMapModel.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceMapModelCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceMapModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceMapModel.
     * @param {DeviceMapModelDeleteArgs} args - Arguments to delete one DeviceMapModel.
     * @example
     * // Delete one DeviceMapModel
     * const DeviceMapModel = await prisma.deviceMapModel.delete({
     *   where: {
     *     // ... filter to delete one DeviceMapModel
     *   }
     * })
     * 
     */
    delete<T extends DeviceMapModelDeleteArgs>(args: SelectSubset<T, DeviceMapModelDeleteArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceMapModel.
     * @param {DeviceMapModelUpdateArgs} args - Arguments to update one DeviceMapModel.
     * @example
     * // Update one DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceMapModelUpdateArgs>(args: SelectSubset<T, DeviceMapModelUpdateArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceMapModels.
     * @param {DeviceMapModelDeleteManyArgs} args - Arguments to filter DeviceMapModels to delete.
     * @example
     * // Delete a few DeviceMapModels
     * const { count } = await prisma.deviceMapModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceMapModelDeleteManyArgs>(args?: SelectSubset<T, DeviceMapModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceMapModels
     * const deviceMapModel = await prisma.deviceMapModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceMapModelUpdateManyArgs>(args: SelectSubset<T, DeviceMapModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapModels and returns the data updated in the database.
     * @param {DeviceMapModelUpdateManyAndReturnArgs} args - Arguments to update many DeviceMapModels.
     * @example
     * // Update many DeviceMapModels
     * const deviceMapModel = await prisma.deviceMapModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceMapModels and only return the `device_id`
     * const deviceMapModelWithDevice_idOnly = await prisma.deviceMapModel.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceMapModelUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceMapModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceMapModel.
     * @param {DeviceMapModelUpsertArgs} args - Arguments to update or create a DeviceMapModel.
     * @example
     * // Update or create a DeviceMapModel
     * const deviceMapModel = await prisma.deviceMapModel.upsert({
     *   create: {
     *     // ... data to create a DeviceMapModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceMapModel we want to update
     *   }
     * })
     */
    upsert<T extends DeviceMapModelUpsertArgs>(args: SelectSubset<T, DeviceMapModelUpsertArgs<ExtArgs>>): Prisma__DeviceMapModelClient<$Result.GetResult<Prisma.$DeviceMapModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceMapModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelCountArgs} args - Arguments to filter DeviceMapModels to count.
     * @example
     * // Count the number of DeviceMapModels
     * const count = await prisma.deviceMapModel.count({
     *   where: {
     *     // ... the filter for the DeviceMapModels we want to count
     *   }
     * })
    **/
    count<T extends DeviceMapModelCountArgs>(
      args?: Subset<T, DeviceMapModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceMapModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceMapModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceMapModelAggregateArgs>(args: Subset<T, DeviceMapModelAggregateArgs>): Prisma.PrismaPromise<GetDeviceMapModelAggregateType<T>>

    /**
     * Group by DeviceMapModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceMapModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceMapModelGroupByArgs['orderBy'] }
        : { orderBy?: DeviceMapModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceMapModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceMapModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceMapModel model
   */
  readonly fields: DeviceMapModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceMapModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceMapModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceMapModel model
   */
  interface DeviceMapModelFieldRefs {
    readonly device_id: FieldRef<"DeviceMapModel", 'Int'>
    readonly model: FieldRef<"DeviceMapModel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceMapModel findUnique
   */
  export type DeviceMapModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapModel to fetch.
     */
    where: DeviceMapModelWhereUniqueInput
  }

  /**
   * DeviceMapModel findUniqueOrThrow
   */
  export type DeviceMapModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapModel to fetch.
     */
    where: DeviceMapModelWhereUniqueInput
  }

  /**
   * DeviceMapModel findFirst
   */
  export type DeviceMapModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapModel to fetch.
     */
    where?: DeviceMapModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapModels to fetch.
     */
    orderBy?: DeviceMapModelOrderByWithRelationInput | DeviceMapModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapModels.
     */
    cursor?: DeviceMapModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapModels.
     */
    distinct?: DeviceMapModelScalarFieldEnum | DeviceMapModelScalarFieldEnum[]
  }

  /**
   * DeviceMapModel findFirstOrThrow
   */
  export type DeviceMapModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapModel to fetch.
     */
    where?: DeviceMapModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapModels to fetch.
     */
    orderBy?: DeviceMapModelOrderByWithRelationInput | DeviceMapModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapModels.
     */
    cursor?: DeviceMapModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapModels.
     */
    distinct?: DeviceMapModelScalarFieldEnum | DeviceMapModelScalarFieldEnum[]
  }

  /**
   * DeviceMapModel findMany
   */
  export type DeviceMapModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapModels to fetch.
     */
    where?: DeviceMapModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapModels to fetch.
     */
    orderBy?: DeviceMapModelOrderByWithRelationInput | DeviceMapModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceMapModels.
     */
    cursor?: DeviceMapModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapModels.
     */
    skip?: number
    distinct?: DeviceMapModelScalarFieldEnum | DeviceMapModelScalarFieldEnum[]
  }

  /**
   * DeviceMapModel create
   */
  export type DeviceMapModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceMapModel.
     */
    data: XOR<DeviceMapModelCreateInput, DeviceMapModelUncheckedCreateInput>
  }

  /**
   * DeviceMapModel createMany
   */
  export type DeviceMapModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceMapModels.
     */
    data: DeviceMapModelCreateManyInput | DeviceMapModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceMapModel createManyAndReturn
   */
  export type DeviceMapModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceMapModels.
     */
    data: DeviceMapModelCreateManyInput | DeviceMapModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapModel update
   */
  export type DeviceMapModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceMapModel.
     */
    data: XOR<DeviceMapModelUpdateInput, DeviceMapModelUncheckedUpdateInput>
    /**
     * Choose, which DeviceMapModel to update.
     */
    where: DeviceMapModelWhereUniqueInput
  }

  /**
   * DeviceMapModel updateMany
   */
  export type DeviceMapModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceMapModels.
     */
    data: XOR<DeviceMapModelUpdateManyMutationInput, DeviceMapModelUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapModels to update
     */
    where?: DeviceMapModelWhereInput
    /**
     * Limit how many DeviceMapModels to update.
     */
    limit?: number
  }

  /**
   * DeviceMapModel updateManyAndReturn
   */
  export type DeviceMapModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * The data used to update DeviceMapModels.
     */
    data: XOR<DeviceMapModelUpdateManyMutationInput, DeviceMapModelUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapModels to update
     */
    where?: DeviceMapModelWhereInput
    /**
     * Limit how many DeviceMapModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapModel upsert
   */
  export type DeviceMapModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceMapModel to update in case it exists.
     */
    where: DeviceMapModelWhereUniqueInput
    /**
     * In case the DeviceMapModel found by the `where` argument doesn't exist, create a new DeviceMapModel with this data.
     */
    create: XOR<DeviceMapModelCreateInput, DeviceMapModelUncheckedCreateInput>
    /**
     * In case the DeviceMapModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceMapModelUpdateInput, DeviceMapModelUncheckedUpdateInput>
  }

  /**
   * DeviceMapModel delete
   */
  export type DeviceMapModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
    /**
     * Filter which DeviceMapModel to delete.
     */
    where: DeviceMapModelWhereUniqueInput
  }

  /**
   * DeviceMapModel deleteMany
   */
  export type DeviceMapModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapModels to delete
     */
    where?: DeviceMapModelWhereInput
    /**
     * Limit how many DeviceMapModels to delete.
     */
    limit?: number
  }

  /**
   * DeviceMapModel without action
   */
  export type DeviceMapModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapModel
     */
    select?: DeviceMapModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapModel
     */
    omit?: DeviceMapModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapModelInclude<ExtArgs> | null
  }


  /**
   * Model DeviceMapRelease
   */

  export type AggregateDeviceMapRelease = {
    _count: DeviceMapReleaseCountAggregateOutputType | null
    _avg: DeviceMapReleaseAvgAggregateOutputType | null
    _sum: DeviceMapReleaseSumAggregateOutputType | null
    _min: DeviceMapReleaseMinAggregateOutputType | null
    _max: DeviceMapReleaseMaxAggregateOutputType | null
  }

  export type DeviceMapReleaseAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
    depth: number | null
  }

  export type DeviceMapReleaseSumAggregateOutputType = {
    id: number | null
    device_id: number | null
    depth: number | null
  }

  export type DeviceMapReleaseMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    datetime: Date | null
    depth: number | null
  }

  export type DeviceMapReleaseMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    datetime: Date | null
    depth: number | null
  }

  export type DeviceMapReleaseCountAggregateOutputType = {
    id: number
    device_id: number
    datetime: number
    depth: number
    _all: number
  }


  export type DeviceMapReleaseAvgAggregateInputType = {
    id?: true
    device_id?: true
    depth?: true
  }

  export type DeviceMapReleaseSumAggregateInputType = {
    id?: true
    device_id?: true
    depth?: true
  }

  export type DeviceMapReleaseMinAggregateInputType = {
    id?: true
    device_id?: true
    datetime?: true
    depth?: true
  }

  export type DeviceMapReleaseMaxAggregateInputType = {
    id?: true
    device_id?: true
    datetime?: true
    depth?: true
  }

  export type DeviceMapReleaseCountAggregateInputType = {
    id?: true
    device_id?: true
    datetime?: true
    depth?: true
    _all?: true
  }

  export type DeviceMapReleaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapRelease to aggregate.
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapReleases to fetch.
     */
    orderBy?: DeviceMapReleaseOrderByWithRelationInput | DeviceMapReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceMapReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapReleases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapReleases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceMapReleases
    **/
    _count?: true | DeviceMapReleaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceMapReleaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceMapReleaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMapReleaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMapReleaseMaxAggregateInputType
  }

  export type GetDeviceMapReleaseAggregateType<T extends DeviceMapReleaseAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceMapRelease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceMapRelease[P]>
      : GetScalarType<T[P], AggregateDeviceMapRelease[P]>
  }




  export type DeviceMapReleaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapReleaseWhereInput
    orderBy?: DeviceMapReleaseOrderByWithAggregationInput | DeviceMapReleaseOrderByWithAggregationInput[]
    by: DeviceMapReleaseScalarFieldEnum[] | DeviceMapReleaseScalarFieldEnum
    having?: DeviceMapReleaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceMapReleaseCountAggregateInputType | true
    _avg?: DeviceMapReleaseAvgAggregateInputType
    _sum?: DeviceMapReleaseSumAggregateInputType
    _min?: DeviceMapReleaseMinAggregateInputType
    _max?: DeviceMapReleaseMaxAggregateInputType
  }

  export type DeviceMapReleaseGroupByOutputType = {
    id: number
    device_id: number | null
    datetime: Date | null
    depth: number | null
    _count: DeviceMapReleaseCountAggregateOutputType | null
    _avg: DeviceMapReleaseAvgAggregateOutputType | null
    _sum: DeviceMapReleaseSumAggregateOutputType | null
    _min: DeviceMapReleaseMinAggregateOutputType | null
    _max: DeviceMapReleaseMaxAggregateOutputType | null
  }

  type GetDeviceMapReleaseGroupByPayload<T extends DeviceMapReleaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceMapReleaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceMapReleaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceMapReleaseGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceMapReleaseGroupByOutputType[P]>
        }
      >
    >


  export type DeviceMapReleaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    datetime?: boolean
    depth?: boolean
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapRelease"]>

  export type DeviceMapReleaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    datetime?: boolean
    depth?: boolean
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapRelease"]>

  export type DeviceMapReleaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    datetime?: boolean
    depth?: boolean
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapRelease"]>

  export type DeviceMapReleaseSelectScalar = {
    id?: boolean
    device_id?: boolean
    datetime?: boolean
    depth?: boolean
  }

  export type DeviceMapReleaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "datetime" | "depth", ExtArgs["result"]["deviceMapRelease"]>
  export type DeviceMapReleaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }
  export type DeviceMapReleaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }
  export type DeviceMapReleaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceMapRelease$DeviceEntryArgs<ExtArgs>
  }

  export type $DeviceMapReleasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceMapRelease"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number | null
      datetime: Date | null
      depth: number | null
    }, ExtArgs["result"]["deviceMapRelease"]>
    composites: {}
  }

  type DeviceMapReleaseGetPayload<S extends boolean | null | undefined | DeviceMapReleaseDefaultArgs> = $Result.GetResult<Prisma.$DeviceMapReleasePayload, S>

  type DeviceMapReleaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceMapReleaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceMapReleaseCountAggregateInputType | true
    }

  export interface DeviceMapReleaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceMapRelease'], meta: { name: 'DeviceMapRelease' } }
    /**
     * Find zero or one DeviceMapRelease that matches the filter.
     * @param {DeviceMapReleaseFindUniqueArgs} args - Arguments to find a DeviceMapRelease
     * @example
     * // Get one DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceMapReleaseFindUniqueArgs>(args: SelectSubset<T, DeviceMapReleaseFindUniqueArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceMapRelease that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceMapReleaseFindUniqueOrThrowArgs} args - Arguments to find a DeviceMapRelease
     * @example
     * // Get one DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceMapReleaseFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceMapReleaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapRelease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseFindFirstArgs} args - Arguments to find a DeviceMapRelease
     * @example
     * // Get one DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceMapReleaseFindFirstArgs>(args?: SelectSubset<T, DeviceMapReleaseFindFirstArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapRelease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseFindFirstOrThrowArgs} args - Arguments to find a DeviceMapRelease
     * @example
     * // Get one DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceMapReleaseFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceMapReleaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceMapReleases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceMapReleases
     * const deviceMapReleases = await prisma.deviceMapRelease.findMany()
     * 
     * // Get first 10 DeviceMapReleases
     * const deviceMapReleases = await prisma.deviceMapRelease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceMapReleaseWithIdOnly = await prisma.deviceMapRelease.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceMapReleaseFindManyArgs>(args?: SelectSubset<T, DeviceMapReleaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceMapRelease.
     * @param {DeviceMapReleaseCreateArgs} args - Arguments to create a DeviceMapRelease.
     * @example
     * // Create one DeviceMapRelease
     * const DeviceMapRelease = await prisma.deviceMapRelease.create({
     *   data: {
     *     // ... data to create a DeviceMapRelease
     *   }
     * })
     * 
     */
    create<T extends DeviceMapReleaseCreateArgs>(args: SelectSubset<T, DeviceMapReleaseCreateArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceMapReleases.
     * @param {DeviceMapReleaseCreateManyArgs} args - Arguments to create many DeviceMapReleases.
     * @example
     * // Create many DeviceMapReleases
     * const deviceMapRelease = await prisma.deviceMapRelease.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceMapReleaseCreateManyArgs>(args?: SelectSubset<T, DeviceMapReleaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceMapReleases and returns the data saved in the database.
     * @param {DeviceMapReleaseCreateManyAndReturnArgs} args - Arguments to create many DeviceMapReleases.
     * @example
     * // Create many DeviceMapReleases
     * const deviceMapRelease = await prisma.deviceMapRelease.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceMapReleases and only return the `id`
     * const deviceMapReleaseWithIdOnly = await prisma.deviceMapRelease.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceMapReleaseCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceMapReleaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceMapRelease.
     * @param {DeviceMapReleaseDeleteArgs} args - Arguments to delete one DeviceMapRelease.
     * @example
     * // Delete one DeviceMapRelease
     * const DeviceMapRelease = await prisma.deviceMapRelease.delete({
     *   where: {
     *     // ... filter to delete one DeviceMapRelease
     *   }
     * })
     * 
     */
    delete<T extends DeviceMapReleaseDeleteArgs>(args: SelectSubset<T, DeviceMapReleaseDeleteArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceMapRelease.
     * @param {DeviceMapReleaseUpdateArgs} args - Arguments to update one DeviceMapRelease.
     * @example
     * // Update one DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceMapReleaseUpdateArgs>(args: SelectSubset<T, DeviceMapReleaseUpdateArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceMapReleases.
     * @param {DeviceMapReleaseDeleteManyArgs} args - Arguments to filter DeviceMapReleases to delete.
     * @example
     * // Delete a few DeviceMapReleases
     * const { count } = await prisma.deviceMapRelease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceMapReleaseDeleteManyArgs>(args?: SelectSubset<T, DeviceMapReleaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapReleases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceMapReleases
     * const deviceMapRelease = await prisma.deviceMapRelease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceMapReleaseUpdateManyArgs>(args: SelectSubset<T, DeviceMapReleaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapReleases and returns the data updated in the database.
     * @param {DeviceMapReleaseUpdateManyAndReturnArgs} args - Arguments to update many DeviceMapReleases.
     * @example
     * // Update many DeviceMapReleases
     * const deviceMapRelease = await prisma.deviceMapRelease.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceMapReleases and only return the `id`
     * const deviceMapReleaseWithIdOnly = await prisma.deviceMapRelease.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceMapReleaseUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceMapReleaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceMapRelease.
     * @param {DeviceMapReleaseUpsertArgs} args - Arguments to update or create a DeviceMapRelease.
     * @example
     * // Update or create a DeviceMapRelease
     * const deviceMapRelease = await prisma.deviceMapRelease.upsert({
     *   create: {
     *     // ... data to create a DeviceMapRelease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceMapRelease we want to update
     *   }
     * })
     */
    upsert<T extends DeviceMapReleaseUpsertArgs>(args: SelectSubset<T, DeviceMapReleaseUpsertArgs<ExtArgs>>): Prisma__DeviceMapReleaseClient<$Result.GetResult<Prisma.$DeviceMapReleasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceMapReleases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseCountArgs} args - Arguments to filter DeviceMapReleases to count.
     * @example
     * // Count the number of DeviceMapReleases
     * const count = await prisma.deviceMapRelease.count({
     *   where: {
     *     // ... the filter for the DeviceMapReleases we want to count
     *   }
     * })
    **/
    count<T extends DeviceMapReleaseCountArgs>(
      args?: Subset<T, DeviceMapReleaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceMapReleaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceMapRelease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceMapReleaseAggregateArgs>(args: Subset<T, DeviceMapReleaseAggregateArgs>): Prisma.PrismaPromise<GetDeviceMapReleaseAggregateType<T>>

    /**
     * Group by DeviceMapRelease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapReleaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceMapReleaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceMapReleaseGroupByArgs['orderBy'] }
        : { orderBy?: DeviceMapReleaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceMapReleaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceMapReleaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceMapRelease model
   */
  readonly fields: DeviceMapReleaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceMapRelease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceMapReleaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceMapRelease$DeviceEntryArgs<ExtArgs> = {}>(args?: Subset<T, DeviceMapRelease$DeviceEntryArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceMapRelease model
   */
  interface DeviceMapReleaseFieldRefs {
    readonly id: FieldRef<"DeviceMapRelease", 'Int'>
    readonly device_id: FieldRef<"DeviceMapRelease", 'Int'>
    readonly datetime: FieldRef<"DeviceMapRelease", 'DateTime'>
    readonly depth: FieldRef<"DeviceMapRelease", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceMapRelease findUnique
   */
  export type DeviceMapReleaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapRelease to fetch.
     */
    where: DeviceMapReleaseWhereUniqueInput
  }

  /**
   * DeviceMapRelease findUniqueOrThrow
   */
  export type DeviceMapReleaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapRelease to fetch.
     */
    where: DeviceMapReleaseWhereUniqueInput
  }

  /**
   * DeviceMapRelease findFirst
   */
  export type DeviceMapReleaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapRelease to fetch.
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapReleases to fetch.
     */
    orderBy?: DeviceMapReleaseOrderByWithRelationInput | DeviceMapReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapReleases.
     */
    cursor?: DeviceMapReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapReleases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapReleases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapReleases.
     */
    distinct?: DeviceMapReleaseScalarFieldEnum | DeviceMapReleaseScalarFieldEnum[]
  }

  /**
   * DeviceMapRelease findFirstOrThrow
   */
  export type DeviceMapReleaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapRelease to fetch.
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapReleases to fetch.
     */
    orderBy?: DeviceMapReleaseOrderByWithRelationInput | DeviceMapReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapReleases.
     */
    cursor?: DeviceMapReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapReleases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapReleases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapReleases.
     */
    distinct?: DeviceMapReleaseScalarFieldEnum | DeviceMapReleaseScalarFieldEnum[]
  }

  /**
   * DeviceMapRelease findMany
   */
  export type DeviceMapReleaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapReleases to fetch.
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapReleases to fetch.
     */
    orderBy?: DeviceMapReleaseOrderByWithRelationInput | DeviceMapReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceMapReleases.
     */
    cursor?: DeviceMapReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapReleases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapReleases.
     */
    skip?: number
    distinct?: DeviceMapReleaseScalarFieldEnum | DeviceMapReleaseScalarFieldEnum[]
  }

  /**
   * DeviceMapRelease create
   */
  export type DeviceMapReleaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceMapRelease.
     */
    data?: XOR<DeviceMapReleaseCreateInput, DeviceMapReleaseUncheckedCreateInput>
  }

  /**
   * DeviceMapRelease createMany
   */
  export type DeviceMapReleaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceMapReleases.
     */
    data: DeviceMapReleaseCreateManyInput | DeviceMapReleaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceMapRelease createManyAndReturn
   */
  export type DeviceMapReleaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceMapReleases.
     */
    data: DeviceMapReleaseCreateManyInput | DeviceMapReleaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapRelease update
   */
  export type DeviceMapReleaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceMapRelease.
     */
    data: XOR<DeviceMapReleaseUpdateInput, DeviceMapReleaseUncheckedUpdateInput>
    /**
     * Choose, which DeviceMapRelease to update.
     */
    where: DeviceMapReleaseWhereUniqueInput
  }

  /**
   * DeviceMapRelease updateMany
   */
  export type DeviceMapReleaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceMapReleases.
     */
    data: XOR<DeviceMapReleaseUpdateManyMutationInput, DeviceMapReleaseUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapReleases to update
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * Limit how many DeviceMapReleases to update.
     */
    limit?: number
  }

  /**
   * DeviceMapRelease updateManyAndReturn
   */
  export type DeviceMapReleaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * The data used to update DeviceMapReleases.
     */
    data: XOR<DeviceMapReleaseUpdateManyMutationInput, DeviceMapReleaseUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapReleases to update
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * Limit how many DeviceMapReleases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapRelease upsert
   */
  export type DeviceMapReleaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceMapRelease to update in case it exists.
     */
    where: DeviceMapReleaseWhereUniqueInput
    /**
     * In case the DeviceMapRelease found by the `where` argument doesn't exist, create a new DeviceMapRelease with this data.
     */
    create: XOR<DeviceMapReleaseCreateInput, DeviceMapReleaseUncheckedCreateInput>
    /**
     * In case the DeviceMapRelease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceMapReleaseUpdateInput, DeviceMapReleaseUncheckedUpdateInput>
  }

  /**
   * DeviceMapRelease delete
   */
  export type DeviceMapReleaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
    /**
     * Filter which DeviceMapRelease to delete.
     */
    where: DeviceMapReleaseWhereUniqueInput
  }

  /**
   * DeviceMapRelease deleteMany
   */
  export type DeviceMapReleaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapReleases to delete
     */
    where?: DeviceMapReleaseWhereInput
    /**
     * Limit how many DeviceMapReleases to delete.
     */
    limit?: number
  }

  /**
   * DeviceMapRelease.DeviceEntry
   */
  export type DeviceMapRelease$DeviceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceEntry
     */
    select?: DeviceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceEntry
     */
    omit?: DeviceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceEntryInclude<ExtArgs> | null
    where?: DeviceEntryWhereInput
  }

  /**
   * DeviceMapRelease without action
   */
  export type DeviceMapReleaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapRelease
     */
    select?: DeviceMapReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapRelease
     */
    omit?: DeviceMapReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapReleaseInclude<ExtArgs> | null
  }


  /**
   * Model DeviceMapSoc
   */

  export type AggregateDeviceMapSoc = {
    _count: DeviceMapSocCountAggregateOutputType | null
    _avg: DeviceMapSocAvgAggregateOutputType | null
    _sum: DeviceMapSocSumAggregateOutputType | null
    _min: DeviceMapSocMinAggregateOutputType | null
    _max: DeviceMapSocMaxAggregateOutputType | null
  }

  export type DeviceMapSocAvgAggregateOutputType = {
    device_id: number | null
    soc_id: number | null
  }

  export type DeviceMapSocSumAggregateOutputType = {
    device_id: number | null
    soc_id: number | null
  }

  export type DeviceMapSocMinAggregateOutputType = {
    device_id: number | null
    soc_id: number | null
  }

  export type DeviceMapSocMaxAggregateOutputType = {
    device_id: number | null
    soc_id: number | null
  }

  export type DeviceMapSocCountAggregateOutputType = {
    device_id: number
    soc_id: number
    _all: number
  }


  export type DeviceMapSocAvgAggregateInputType = {
    device_id?: true
    soc_id?: true
  }

  export type DeviceMapSocSumAggregateInputType = {
    device_id?: true
    soc_id?: true
  }

  export type DeviceMapSocMinAggregateInputType = {
    device_id?: true
    soc_id?: true
  }

  export type DeviceMapSocMaxAggregateInputType = {
    device_id?: true
    soc_id?: true
  }

  export type DeviceMapSocCountAggregateInputType = {
    device_id?: true
    soc_id?: true
    _all?: true
  }

  export type DeviceMapSocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapSoc to aggregate.
     */
    where?: DeviceMapSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapSocs to fetch.
     */
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceMapSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceMapSocs
    **/
    _count?: true | DeviceMapSocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceMapSocAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceMapSocSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMapSocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMapSocMaxAggregateInputType
  }

  export type GetDeviceMapSocAggregateType<T extends DeviceMapSocAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceMapSoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceMapSoc[P]>
      : GetScalarType<T[P], AggregateDeviceMapSoc[P]>
  }




  export type DeviceMapSocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceMapSocWhereInput
    orderBy?: DeviceMapSocOrderByWithAggregationInput | DeviceMapSocOrderByWithAggregationInput[]
    by: DeviceMapSocScalarFieldEnum[] | DeviceMapSocScalarFieldEnum
    having?: DeviceMapSocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceMapSocCountAggregateInputType | true
    _avg?: DeviceMapSocAvgAggregateInputType
    _sum?: DeviceMapSocSumAggregateInputType
    _min?: DeviceMapSocMinAggregateInputType
    _max?: DeviceMapSocMaxAggregateInputType
  }

  export type DeviceMapSocGroupByOutputType = {
    device_id: number
    soc_id: number
    _count: DeviceMapSocCountAggregateOutputType | null
    _avg: DeviceMapSocAvgAggregateOutputType | null
    _sum: DeviceMapSocSumAggregateOutputType | null
    _min: DeviceMapSocMinAggregateOutputType | null
    _max: DeviceMapSocMaxAggregateOutputType | null
  }

  type GetDeviceMapSocGroupByPayload<T extends DeviceMapSocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceMapSocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceMapSocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceMapSocGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceMapSocGroupByOutputType[P]>
        }
      >
    >


  export type DeviceMapSocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    soc_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapSoc"]>

  export type DeviceMapSocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    soc_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapSoc"]>

  export type DeviceMapSocSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    soc_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceMapSoc"]>

  export type DeviceMapSocSelectScalar = {
    device_id?: boolean
    soc_id?: boolean
  }

  export type DeviceMapSocOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_id" | "soc_id", ExtArgs["result"]["deviceMapSoc"]>
  export type DeviceMapSocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }
  export type DeviceMapSocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }
  export type DeviceMapSocIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    DeviceLookupSoc?: boolean | DeviceLookupSocDefaultArgs<ExtArgs>
  }

  export type $DeviceMapSocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceMapSoc"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
      DeviceLookupSoc: Prisma.$DeviceLookupSocPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_id: number
      soc_id: number
    }, ExtArgs["result"]["deviceMapSoc"]>
    composites: {}
  }

  type DeviceMapSocGetPayload<S extends boolean | null | undefined | DeviceMapSocDefaultArgs> = $Result.GetResult<Prisma.$DeviceMapSocPayload, S>

  type DeviceMapSocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceMapSocFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceMapSocCountAggregateInputType | true
    }

  export interface DeviceMapSocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceMapSoc'], meta: { name: 'DeviceMapSoc' } }
    /**
     * Find zero or one DeviceMapSoc that matches the filter.
     * @param {DeviceMapSocFindUniqueArgs} args - Arguments to find a DeviceMapSoc
     * @example
     * // Get one DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceMapSocFindUniqueArgs>(args: SelectSubset<T, DeviceMapSocFindUniqueArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceMapSoc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceMapSocFindUniqueOrThrowArgs} args - Arguments to find a DeviceMapSoc
     * @example
     * // Get one DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceMapSocFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceMapSocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapSoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocFindFirstArgs} args - Arguments to find a DeviceMapSoc
     * @example
     * // Get one DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceMapSocFindFirstArgs>(args?: SelectSubset<T, DeviceMapSocFindFirstArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceMapSoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocFindFirstOrThrowArgs} args - Arguments to find a DeviceMapSoc
     * @example
     * // Get one DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceMapSocFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceMapSocFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceMapSocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceMapSocs
     * const deviceMapSocs = await prisma.deviceMapSoc.findMany()
     * 
     * // Get first 10 DeviceMapSocs
     * const deviceMapSocs = await prisma.deviceMapSoc.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const deviceMapSocWithDevice_idOnly = await prisma.deviceMapSoc.findMany({ select: { device_id: true } })
     * 
     */
    findMany<T extends DeviceMapSocFindManyArgs>(args?: SelectSubset<T, DeviceMapSocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceMapSoc.
     * @param {DeviceMapSocCreateArgs} args - Arguments to create a DeviceMapSoc.
     * @example
     * // Create one DeviceMapSoc
     * const DeviceMapSoc = await prisma.deviceMapSoc.create({
     *   data: {
     *     // ... data to create a DeviceMapSoc
     *   }
     * })
     * 
     */
    create<T extends DeviceMapSocCreateArgs>(args: SelectSubset<T, DeviceMapSocCreateArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceMapSocs.
     * @param {DeviceMapSocCreateManyArgs} args - Arguments to create many DeviceMapSocs.
     * @example
     * // Create many DeviceMapSocs
     * const deviceMapSoc = await prisma.deviceMapSoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceMapSocCreateManyArgs>(args?: SelectSubset<T, DeviceMapSocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceMapSocs and returns the data saved in the database.
     * @param {DeviceMapSocCreateManyAndReturnArgs} args - Arguments to create many DeviceMapSocs.
     * @example
     * // Create many DeviceMapSocs
     * const deviceMapSoc = await prisma.deviceMapSoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceMapSocs and only return the `device_id`
     * const deviceMapSocWithDevice_idOnly = await prisma.deviceMapSoc.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceMapSocCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceMapSocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceMapSoc.
     * @param {DeviceMapSocDeleteArgs} args - Arguments to delete one DeviceMapSoc.
     * @example
     * // Delete one DeviceMapSoc
     * const DeviceMapSoc = await prisma.deviceMapSoc.delete({
     *   where: {
     *     // ... filter to delete one DeviceMapSoc
     *   }
     * })
     * 
     */
    delete<T extends DeviceMapSocDeleteArgs>(args: SelectSubset<T, DeviceMapSocDeleteArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceMapSoc.
     * @param {DeviceMapSocUpdateArgs} args - Arguments to update one DeviceMapSoc.
     * @example
     * // Update one DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceMapSocUpdateArgs>(args: SelectSubset<T, DeviceMapSocUpdateArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceMapSocs.
     * @param {DeviceMapSocDeleteManyArgs} args - Arguments to filter DeviceMapSocs to delete.
     * @example
     * // Delete a few DeviceMapSocs
     * const { count } = await prisma.deviceMapSoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceMapSocDeleteManyArgs>(args?: SelectSubset<T, DeviceMapSocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapSocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceMapSocs
     * const deviceMapSoc = await prisma.deviceMapSoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceMapSocUpdateManyArgs>(args: SelectSubset<T, DeviceMapSocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceMapSocs and returns the data updated in the database.
     * @param {DeviceMapSocUpdateManyAndReturnArgs} args - Arguments to update many DeviceMapSocs.
     * @example
     * // Update many DeviceMapSocs
     * const deviceMapSoc = await prisma.deviceMapSoc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceMapSocs and only return the `device_id`
     * const deviceMapSocWithDevice_idOnly = await prisma.deviceMapSoc.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceMapSocUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceMapSocUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceMapSoc.
     * @param {DeviceMapSocUpsertArgs} args - Arguments to update or create a DeviceMapSoc.
     * @example
     * // Update or create a DeviceMapSoc
     * const deviceMapSoc = await prisma.deviceMapSoc.upsert({
     *   create: {
     *     // ... data to create a DeviceMapSoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceMapSoc we want to update
     *   }
     * })
     */
    upsert<T extends DeviceMapSocUpsertArgs>(args: SelectSubset<T, DeviceMapSocUpsertArgs<ExtArgs>>): Prisma__DeviceMapSocClient<$Result.GetResult<Prisma.$DeviceMapSocPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceMapSocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocCountArgs} args - Arguments to filter DeviceMapSocs to count.
     * @example
     * // Count the number of DeviceMapSocs
     * const count = await prisma.deviceMapSoc.count({
     *   where: {
     *     // ... the filter for the DeviceMapSocs we want to count
     *   }
     * })
    **/
    count<T extends DeviceMapSocCountArgs>(
      args?: Subset<T, DeviceMapSocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceMapSocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceMapSoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceMapSocAggregateArgs>(args: Subset<T, DeviceMapSocAggregateArgs>): Prisma.PrismaPromise<GetDeviceMapSocAggregateType<T>>

    /**
     * Group by DeviceMapSoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceMapSocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceMapSocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceMapSocGroupByArgs['orderBy'] }
        : { orderBy?: DeviceMapSocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceMapSocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceMapSocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceMapSoc model
   */
  readonly fields: DeviceMapSocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceMapSoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceMapSocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceLookupSoc<T extends DeviceLookupSocDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceLookupSocDefaultArgs<ExtArgs>>): Prisma__DeviceLookupSocClient<$Result.GetResult<Prisma.$DeviceLookupSocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceMapSoc model
   */
  interface DeviceMapSocFieldRefs {
    readonly device_id: FieldRef<"DeviceMapSoc", 'Int'>
    readonly soc_id: FieldRef<"DeviceMapSoc", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeviceMapSoc findUnique
   */
  export type DeviceMapSocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapSoc to fetch.
     */
    where: DeviceMapSocWhereUniqueInput
  }

  /**
   * DeviceMapSoc findUniqueOrThrow
   */
  export type DeviceMapSocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapSoc to fetch.
     */
    where: DeviceMapSocWhereUniqueInput
  }

  /**
   * DeviceMapSoc findFirst
   */
  export type DeviceMapSocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapSoc to fetch.
     */
    where?: DeviceMapSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapSocs to fetch.
     */
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapSocs.
     */
    cursor?: DeviceMapSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapSocs.
     */
    distinct?: DeviceMapSocScalarFieldEnum | DeviceMapSocScalarFieldEnum[]
  }

  /**
   * DeviceMapSoc findFirstOrThrow
   */
  export type DeviceMapSocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapSoc to fetch.
     */
    where?: DeviceMapSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapSocs to fetch.
     */
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceMapSocs.
     */
    cursor?: DeviceMapSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapSocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceMapSocs.
     */
    distinct?: DeviceMapSocScalarFieldEnum | DeviceMapSocScalarFieldEnum[]
  }

  /**
   * DeviceMapSoc findMany
   */
  export type DeviceMapSocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter, which DeviceMapSocs to fetch.
     */
    where?: DeviceMapSocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceMapSocs to fetch.
     */
    orderBy?: DeviceMapSocOrderByWithRelationInput | DeviceMapSocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceMapSocs.
     */
    cursor?: DeviceMapSocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceMapSocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceMapSocs.
     */
    skip?: number
    distinct?: DeviceMapSocScalarFieldEnum | DeviceMapSocScalarFieldEnum[]
  }

  /**
   * DeviceMapSoc create
   */
  export type DeviceMapSocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceMapSoc.
     */
    data: XOR<DeviceMapSocCreateInput, DeviceMapSocUncheckedCreateInput>
  }

  /**
   * DeviceMapSoc createMany
   */
  export type DeviceMapSocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceMapSocs.
     */
    data: DeviceMapSocCreateManyInput | DeviceMapSocCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceMapSoc createManyAndReturn
   */
  export type DeviceMapSocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceMapSocs.
     */
    data: DeviceMapSocCreateManyInput | DeviceMapSocCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapSoc update
   */
  export type DeviceMapSocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceMapSoc.
     */
    data: XOR<DeviceMapSocUpdateInput, DeviceMapSocUncheckedUpdateInput>
    /**
     * Choose, which DeviceMapSoc to update.
     */
    where: DeviceMapSocWhereUniqueInput
  }

  /**
   * DeviceMapSoc updateMany
   */
  export type DeviceMapSocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceMapSocs.
     */
    data: XOR<DeviceMapSocUpdateManyMutationInput, DeviceMapSocUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapSocs to update
     */
    where?: DeviceMapSocWhereInput
    /**
     * Limit how many DeviceMapSocs to update.
     */
    limit?: number
  }

  /**
   * DeviceMapSoc updateManyAndReturn
   */
  export type DeviceMapSocUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * The data used to update DeviceMapSocs.
     */
    data: XOR<DeviceMapSocUpdateManyMutationInput, DeviceMapSocUncheckedUpdateManyInput>
    /**
     * Filter which DeviceMapSocs to update
     */
    where?: DeviceMapSocWhereInput
    /**
     * Limit how many DeviceMapSocs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceMapSoc upsert
   */
  export type DeviceMapSocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceMapSoc to update in case it exists.
     */
    where: DeviceMapSocWhereUniqueInput
    /**
     * In case the DeviceMapSoc found by the `where` argument doesn't exist, create a new DeviceMapSoc with this data.
     */
    create: XOR<DeviceMapSocCreateInput, DeviceMapSocUncheckedCreateInput>
    /**
     * In case the DeviceMapSoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceMapSocUpdateInput, DeviceMapSocUncheckedUpdateInput>
  }

  /**
   * DeviceMapSoc delete
   */
  export type DeviceMapSocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
    /**
     * Filter which DeviceMapSoc to delete.
     */
    where: DeviceMapSocWhereUniqueInput
  }

  /**
   * DeviceMapSoc deleteMany
   */
  export type DeviceMapSocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceMapSocs to delete
     */
    where?: DeviceMapSocWhereInput
    /**
     * Limit how many DeviceMapSocs to delete.
     */
    limit?: number
  }

  /**
   * DeviceMapSoc without action
   */
  export type DeviceMapSocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceMapSoc
     */
    select?: DeviceMapSocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceMapSoc
     */
    omit?: DeviceMapSocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceMapSocInclude<ExtArgs> | null
  }


  /**
   * Model MapDeviceOs
   */

  export type AggregateMapDeviceOs = {
    _count: MapDeviceOsCountAggregateOutputType | null
    _avg: MapDeviceOsAvgAggregateOutputType | null
    _sum: MapDeviceOsSumAggregateOutputType | null
    _min: MapDeviceOsMinAggregateOutputType | null
    _max: MapDeviceOsMaxAggregateOutputType | null
  }

  export type MapDeviceOsAvgAggregateOutputType = {
    device_id: number | null
    os_id: number | null
  }

  export type MapDeviceOsSumAggregateOutputType = {
    device_id: number | null
    os_id: number | null
  }

  export type MapDeviceOsMinAggregateOutputType = {
    device_id: number | null
    os_id: number | null
  }

  export type MapDeviceOsMaxAggregateOutputType = {
    device_id: number | null
    os_id: number | null
  }

  export type MapDeviceOsCountAggregateOutputType = {
    device_id: number
    os_id: number
    _all: number
  }


  export type MapDeviceOsAvgAggregateInputType = {
    device_id?: true
    os_id?: true
  }

  export type MapDeviceOsSumAggregateInputType = {
    device_id?: true
    os_id?: true
  }

  export type MapDeviceOsMinAggregateInputType = {
    device_id?: true
    os_id?: true
  }

  export type MapDeviceOsMaxAggregateInputType = {
    device_id?: true
    os_id?: true
  }

  export type MapDeviceOsCountAggregateInputType = {
    device_id?: true
    os_id?: true
    _all?: true
  }

  export type MapDeviceOsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapDeviceOs to aggregate.
     */
    where?: MapDeviceOsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapDeviceOs to fetch.
     */
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapDeviceOsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapDeviceOs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapDeviceOs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapDeviceOs
    **/
    _count?: true | MapDeviceOsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapDeviceOsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapDeviceOsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapDeviceOsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapDeviceOsMaxAggregateInputType
  }

  export type GetMapDeviceOsAggregateType<T extends MapDeviceOsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapDeviceOs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapDeviceOs[P]>
      : GetScalarType<T[P], AggregateMapDeviceOs[P]>
  }




  export type MapDeviceOsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapDeviceOsWhereInput
    orderBy?: MapDeviceOsOrderByWithAggregationInput | MapDeviceOsOrderByWithAggregationInput[]
    by: MapDeviceOsScalarFieldEnum[] | MapDeviceOsScalarFieldEnum
    having?: MapDeviceOsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapDeviceOsCountAggregateInputType | true
    _avg?: MapDeviceOsAvgAggregateInputType
    _sum?: MapDeviceOsSumAggregateInputType
    _min?: MapDeviceOsMinAggregateInputType
    _max?: MapDeviceOsMaxAggregateInputType
  }

  export type MapDeviceOsGroupByOutputType = {
    device_id: number
    os_id: number
    _count: MapDeviceOsCountAggregateOutputType | null
    _avg: MapDeviceOsAvgAggregateOutputType | null
    _sum: MapDeviceOsSumAggregateOutputType | null
    _min: MapDeviceOsMinAggregateOutputType | null
    _max: MapDeviceOsMaxAggregateOutputType | null
  }

  type GetMapDeviceOsGroupByPayload<T extends MapDeviceOsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapDeviceOsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapDeviceOsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapDeviceOsGroupByOutputType[P]>
            : GetScalarType<T[P], MapDeviceOsGroupByOutputType[P]>
        }
      >
    >


  export type MapDeviceOsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    os_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapDeviceOs"]>

  export type MapDeviceOsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    os_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapDeviceOs"]>

  export type MapDeviceOsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    device_id?: boolean
    os_id?: boolean
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapDeviceOs"]>

  export type MapDeviceOsSelectScalar = {
    device_id?: boolean
    os_id?: boolean
  }

  export type MapDeviceOsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"device_id" | "os_id", ExtArgs["result"]["mapDeviceOs"]>
  export type MapDeviceOsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type MapDeviceOsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type MapDeviceOsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $MapDeviceOsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapDeviceOs"
    objects: {
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      device_id: number
      os_id: number
    }, ExtArgs["result"]["mapDeviceOs"]>
    composites: {}
  }

  type MapDeviceOsGetPayload<S extends boolean | null | undefined | MapDeviceOsDefaultArgs> = $Result.GetResult<Prisma.$MapDeviceOsPayload, S>

  type MapDeviceOsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapDeviceOsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapDeviceOsCountAggregateInputType | true
    }

  export interface MapDeviceOsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapDeviceOs'], meta: { name: 'MapDeviceOs' } }
    /**
     * Find zero or one MapDeviceOs that matches the filter.
     * @param {MapDeviceOsFindUniqueArgs} args - Arguments to find a MapDeviceOs
     * @example
     * // Get one MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapDeviceOsFindUniqueArgs>(args: SelectSubset<T, MapDeviceOsFindUniqueArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapDeviceOs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapDeviceOsFindUniqueOrThrowArgs} args - Arguments to find a MapDeviceOs
     * @example
     * // Get one MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapDeviceOsFindUniqueOrThrowArgs>(args: SelectSubset<T, MapDeviceOsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapDeviceOs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsFindFirstArgs} args - Arguments to find a MapDeviceOs
     * @example
     * // Get one MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapDeviceOsFindFirstArgs>(args?: SelectSubset<T, MapDeviceOsFindFirstArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapDeviceOs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsFindFirstOrThrowArgs} args - Arguments to find a MapDeviceOs
     * @example
     * // Get one MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapDeviceOsFindFirstOrThrowArgs>(args?: SelectSubset<T, MapDeviceOsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapDeviceOs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findMany()
     * 
     * // Get first 10 MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.findMany({ take: 10 })
     * 
     * // Only select the `device_id`
     * const mapDeviceOsWithDevice_idOnly = await prisma.mapDeviceOs.findMany({ select: { device_id: true } })
     * 
     */
    findMany<T extends MapDeviceOsFindManyArgs>(args?: SelectSubset<T, MapDeviceOsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapDeviceOs.
     * @param {MapDeviceOsCreateArgs} args - Arguments to create a MapDeviceOs.
     * @example
     * // Create one MapDeviceOs
     * const MapDeviceOs = await prisma.mapDeviceOs.create({
     *   data: {
     *     // ... data to create a MapDeviceOs
     *   }
     * })
     * 
     */
    create<T extends MapDeviceOsCreateArgs>(args: SelectSubset<T, MapDeviceOsCreateArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapDeviceOs.
     * @param {MapDeviceOsCreateManyArgs} args - Arguments to create many MapDeviceOs.
     * @example
     * // Create many MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapDeviceOsCreateManyArgs>(args?: SelectSubset<T, MapDeviceOsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapDeviceOs and returns the data saved in the database.
     * @param {MapDeviceOsCreateManyAndReturnArgs} args - Arguments to create many MapDeviceOs.
     * @example
     * // Create many MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapDeviceOs and only return the `device_id`
     * const mapDeviceOsWithDevice_idOnly = await prisma.mapDeviceOs.createManyAndReturn({
     *   select: { device_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapDeviceOsCreateManyAndReturnArgs>(args?: SelectSubset<T, MapDeviceOsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapDeviceOs.
     * @param {MapDeviceOsDeleteArgs} args - Arguments to delete one MapDeviceOs.
     * @example
     * // Delete one MapDeviceOs
     * const MapDeviceOs = await prisma.mapDeviceOs.delete({
     *   where: {
     *     // ... filter to delete one MapDeviceOs
     *   }
     * })
     * 
     */
    delete<T extends MapDeviceOsDeleteArgs>(args: SelectSubset<T, MapDeviceOsDeleteArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapDeviceOs.
     * @param {MapDeviceOsUpdateArgs} args - Arguments to update one MapDeviceOs.
     * @example
     * // Update one MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapDeviceOsUpdateArgs>(args: SelectSubset<T, MapDeviceOsUpdateArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapDeviceOs.
     * @param {MapDeviceOsDeleteManyArgs} args - Arguments to filter MapDeviceOs to delete.
     * @example
     * // Delete a few MapDeviceOs
     * const { count } = await prisma.mapDeviceOs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapDeviceOsDeleteManyArgs>(args?: SelectSubset<T, MapDeviceOsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapDeviceOs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapDeviceOsUpdateManyArgs>(args: SelectSubset<T, MapDeviceOsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapDeviceOs and returns the data updated in the database.
     * @param {MapDeviceOsUpdateManyAndReturnArgs} args - Arguments to update many MapDeviceOs.
     * @example
     * // Update many MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapDeviceOs and only return the `device_id`
     * const mapDeviceOsWithDevice_idOnly = await prisma.mapDeviceOs.updateManyAndReturn({
     *   select: { device_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapDeviceOsUpdateManyAndReturnArgs>(args: SelectSubset<T, MapDeviceOsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapDeviceOs.
     * @param {MapDeviceOsUpsertArgs} args - Arguments to update or create a MapDeviceOs.
     * @example
     * // Update or create a MapDeviceOs
     * const mapDeviceOs = await prisma.mapDeviceOs.upsert({
     *   create: {
     *     // ... data to create a MapDeviceOs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapDeviceOs we want to update
     *   }
     * })
     */
    upsert<T extends MapDeviceOsUpsertArgs>(args: SelectSubset<T, MapDeviceOsUpsertArgs<ExtArgs>>): Prisma__MapDeviceOsClient<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapDeviceOs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsCountArgs} args - Arguments to filter MapDeviceOs to count.
     * @example
     * // Count the number of MapDeviceOs
     * const count = await prisma.mapDeviceOs.count({
     *   where: {
     *     // ... the filter for the MapDeviceOs we want to count
     *   }
     * })
    **/
    count<T extends MapDeviceOsCountArgs>(
      args?: Subset<T, MapDeviceOsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapDeviceOsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapDeviceOs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapDeviceOsAggregateArgs>(args: Subset<T, MapDeviceOsAggregateArgs>): Prisma.PrismaPromise<GetMapDeviceOsAggregateType<T>>

    /**
     * Group by MapDeviceOs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapDeviceOsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapDeviceOsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapDeviceOsGroupByArgs['orderBy'] }
        : { orderBy?: MapDeviceOsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapDeviceOsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapDeviceOsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapDeviceOs model
   */
  readonly fields: MapDeviceOsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapDeviceOs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapDeviceOsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapDeviceOs model
   */
  interface MapDeviceOsFieldRefs {
    readonly device_id: FieldRef<"MapDeviceOs", 'Int'>
    readonly os_id: FieldRef<"MapDeviceOs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MapDeviceOs findUnique
   */
  export type MapDeviceOsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter, which MapDeviceOs to fetch.
     */
    where: MapDeviceOsWhereUniqueInput
  }

  /**
   * MapDeviceOs findUniqueOrThrow
   */
  export type MapDeviceOsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter, which MapDeviceOs to fetch.
     */
    where: MapDeviceOsWhereUniqueInput
  }

  /**
   * MapDeviceOs findFirst
   */
  export type MapDeviceOsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter, which MapDeviceOs to fetch.
     */
    where?: MapDeviceOsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapDeviceOs to fetch.
     */
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapDeviceOs.
     */
    cursor?: MapDeviceOsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapDeviceOs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapDeviceOs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapDeviceOs.
     */
    distinct?: MapDeviceOsScalarFieldEnum | MapDeviceOsScalarFieldEnum[]
  }

  /**
   * MapDeviceOs findFirstOrThrow
   */
  export type MapDeviceOsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter, which MapDeviceOs to fetch.
     */
    where?: MapDeviceOsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapDeviceOs to fetch.
     */
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapDeviceOs.
     */
    cursor?: MapDeviceOsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapDeviceOs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapDeviceOs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapDeviceOs.
     */
    distinct?: MapDeviceOsScalarFieldEnum | MapDeviceOsScalarFieldEnum[]
  }

  /**
   * MapDeviceOs findMany
   */
  export type MapDeviceOsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter, which MapDeviceOs to fetch.
     */
    where?: MapDeviceOsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapDeviceOs to fetch.
     */
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapDeviceOs.
     */
    cursor?: MapDeviceOsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapDeviceOs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapDeviceOs.
     */
    skip?: number
    distinct?: MapDeviceOsScalarFieldEnum | MapDeviceOsScalarFieldEnum[]
  }

  /**
   * MapDeviceOs create
   */
  export type MapDeviceOsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * The data needed to create a MapDeviceOs.
     */
    data: XOR<MapDeviceOsCreateInput, MapDeviceOsUncheckedCreateInput>
  }

  /**
   * MapDeviceOs createMany
   */
  export type MapDeviceOsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapDeviceOs.
     */
    data: MapDeviceOsCreateManyInput | MapDeviceOsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapDeviceOs createManyAndReturn
   */
  export type MapDeviceOsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * The data used to create many MapDeviceOs.
     */
    data: MapDeviceOsCreateManyInput | MapDeviceOsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapDeviceOs update
   */
  export type MapDeviceOsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * The data needed to update a MapDeviceOs.
     */
    data: XOR<MapDeviceOsUpdateInput, MapDeviceOsUncheckedUpdateInput>
    /**
     * Choose, which MapDeviceOs to update.
     */
    where: MapDeviceOsWhereUniqueInput
  }

  /**
   * MapDeviceOs updateMany
   */
  export type MapDeviceOsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapDeviceOs.
     */
    data: XOR<MapDeviceOsUpdateManyMutationInput, MapDeviceOsUncheckedUpdateManyInput>
    /**
     * Filter which MapDeviceOs to update
     */
    where?: MapDeviceOsWhereInput
    /**
     * Limit how many MapDeviceOs to update.
     */
    limit?: number
  }

  /**
   * MapDeviceOs updateManyAndReturn
   */
  export type MapDeviceOsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * The data used to update MapDeviceOs.
     */
    data: XOR<MapDeviceOsUpdateManyMutationInput, MapDeviceOsUncheckedUpdateManyInput>
    /**
     * Filter which MapDeviceOs to update
     */
    where?: MapDeviceOsWhereInput
    /**
     * Limit how many MapDeviceOs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapDeviceOs upsert
   */
  export type MapDeviceOsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * The filter to search for the MapDeviceOs to update in case it exists.
     */
    where: MapDeviceOsWhereUniqueInput
    /**
     * In case the MapDeviceOs found by the `where` argument doesn't exist, create a new MapDeviceOs with this data.
     */
    create: XOR<MapDeviceOsCreateInput, MapDeviceOsUncheckedCreateInput>
    /**
     * In case the MapDeviceOs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapDeviceOsUpdateInput, MapDeviceOsUncheckedUpdateInput>
  }

  /**
   * MapDeviceOs delete
   */
  export type MapDeviceOsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    /**
     * Filter which MapDeviceOs to delete.
     */
    where: MapDeviceOsWhereUniqueInput
  }

  /**
   * MapDeviceOs deleteMany
   */
  export type MapDeviceOsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapDeviceOs to delete
     */
    where?: MapDeviceOsWhereInput
    /**
     * Limit how many MapDeviceOs to delete.
     */
    limit?: number
  }

  /**
   * MapDeviceOs without action
   */
  export type MapDeviceOsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
  }


  /**
   * Model OsEntry
   */

  export type AggregateOsEntry = {
    _count: OsEntryCountAggregateOutputType | null
    _avg: OsEntryAvgAggregateOutputType | null
    _sum: OsEntrySumAggregateOutputType | null
    _min: OsEntryMinAggregateOutputType | null
    _max: OsEntryMaxAggregateOutputType | null
  }

  export type OsEntryAvgAggregateOutputType = {
    id: number | null
    name_id: number | null
    release_datetime_depth: number | null
  }

  export type OsEntrySumAggregateOutputType = {
    id: number | null
    name_id: number | null
    release_datetime_depth: number | null
  }

  export type OsEntryMinAggregateOutputType = {
    id: number | null
    name_id: number | null
    version: string | null
    build: string | null
    release_datetime: Date | null
    release_datetime_depth: number | null
    is_release: boolean | null
    is_beta: boolean | null
    is_rc: boolean | null
    is_internal: boolean | null
    is_rsr: boolean | null
    is_sdk: boolean | null
    is_simulator: boolean | null
    image_id: string | null
    embedded_os_build: string | null
    bridge_os_build: string | null
    notes: string | null
    legacy_unique_key: string | null
    search: string | null
  }

  export type OsEntryMaxAggregateOutputType = {
    id: number | null
    name_id: number | null
    version: string | null
    build: string | null
    release_datetime: Date | null
    release_datetime_depth: number | null
    is_release: boolean | null
    is_beta: boolean | null
    is_rc: boolean | null
    is_internal: boolean | null
    is_rsr: boolean | null
    is_sdk: boolean | null
    is_simulator: boolean | null
    image_id: string | null
    embedded_os_build: string | null
    bridge_os_build: string | null
    notes: string | null
    legacy_unique_key: string | null
    search: string | null
  }

  export type OsEntryCountAggregateOutputType = {
    id: number
    name_id: number
    version: number
    build: number
    release_datetime: number
    release_datetime_depth: number
    is_release: number
    is_beta: number
    is_rc: number
    is_internal: number
    is_rsr: number
    is_sdk: number
    is_simulator: number
    image_id: number
    embedded_os_build: number
    bridge_os_build: number
    notes: number
    legacy_unique_key: number
    search: number
    _all: number
  }


  export type OsEntryAvgAggregateInputType = {
    id?: true
    name_id?: true
    release_datetime_depth?: true
  }

  export type OsEntrySumAggregateInputType = {
    id?: true
    name_id?: true
    release_datetime_depth?: true
  }

  export type OsEntryMinAggregateInputType = {
    id?: true
    name_id?: true
    version?: true
    build?: true
    release_datetime?: true
    release_datetime_depth?: true
    is_release?: true
    is_beta?: true
    is_rc?: true
    is_internal?: true
    is_rsr?: true
    is_sdk?: true
    is_simulator?: true
    image_id?: true
    embedded_os_build?: true
    bridge_os_build?: true
    notes?: true
    legacy_unique_key?: true
    search?: true
  }

  export type OsEntryMaxAggregateInputType = {
    id?: true
    name_id?: true
    version?: true
    build?: true
    release_datetime?: true
    release_datetime_depth?: true
    is_release?: true
    is_beta?: true
    is_rc?: true
    is_internal?: true
    is_rsr?: true
    is_sdk?: true
    is_simulator?: true
    image_id?: true
    embedded_os_build?: true
    bridge_os_build?: true
    notes?: true
    legacy_unique_key?: true
    search?: true
  }

  export type OsEntryCountAggregateInputType = {
    id?: true
    name_id?: true
    version?: true
    build?: true
    release_datetime?: true
    release_datetime_depth?: true
    is_release?: true
    is_beta?: true
    is_rc?: true
    is_internal?: true
    is_rsr?: true
    is_sdk?: true
    is_simulator?: true
    image_id?: true
    embedded_os_build?: true
    bridge_os_build?: true
    notes?: true
    legacy_unique_key?: true
    search?: true
    _all?: true
  }

  export type OsEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntry to aggregate.
     */
    where?: OsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntries to fetch.
     */
    orderBy?: OsEntryOrderByWithRelationInput | OsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntries
    **/
    _count?: true | OsEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryMaxAggregateInputType
  }

  export type GetOsEntryAggregateType<T extends OsEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntry[P]>
      : GetScalarType<T[P], AggregateOsEntry[P]>
  }




  export type OsEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryWhereInput
    orderBy?: OsEntryOrderByWithAggregationInput | OsEntryOrderByWithAggregationInput[]
    by: OsEntryScalarFieldEnum[] | OsEntryScalarFieldEnum
    having?: OsEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryCountAggregateInputType | true
    _avg?: OsEntryAvgAggregateInputType
    _sum?: OsEntrySumAggregateInputType
    _min?: OsEntryMinAggregateInputType
    _max?: OsEntryMaxAggregateInputType
  }

  export type OsEntryGroupByOutputType = {
    id: number
    name_id: number
    version: string
    build: string | null
    release_datetime: Date | null
    release_datetime_depth: number | null
    is_release: boolean | null
    is_beta: boolean | null
    is_rc: boolean | null
    is_internal: boolean | null
    is_rsr: boolean | null
    is_sdk: boolean | null
    is_simulator: boolean | null
    image_id: string | null
    embedded_os_build: string | null
    bridge_os_build: string | null
    notes: string | null
    legacy_unique_key: string | null
    search: string | null
    _count: OsEntryCountAggregateOutputType | null
    _avg: OsEntryAvgAggregateOutputType | null
    _sum: OsEntrySumAggregateOutputType | null
    _min: OsEntryMinAggregateOutputType | null
    _max: OsEntryMaxAggregateOutputType | null
  }

  type GetOsEntryGroupByPayload<T extends OsEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryGroupByOutputType[P]>
        }
      >
    >


  export type OsEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_id?: boolean
    version?: boolean
    build?: boolean
    release_datetime?: boolean
    release_datetime_depth?: boolean
    is_release?: boolean
    is_beta?: boolean
    is_rc?: boolean
    is_internal?: boolean
    is_rsr?: boolean
    is_sdk?: boolean
    is_simulator?: boolean
    image_id?: boolean
    embedded_os_build?: boolean
    bridge_os_build?: boolean
    notes?: boolean
    legacy_unique_key?: boolean
    search?: boolean
    MapDeviceOs?: boolean | OsEntry$MapDeviceOsArgs<ExtArgs>
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
    OsEntryBuildTrain?: boolean | OsEntry$OsEntryBuildTrainArgs<ExtArgs>
    OsEntryIpd?: boolean | OsEntry$OsEntryIpdArgs<ExtArgs>
    OsEntryOsStringMap?: boolean | OsEntry$OsEntryOsStringMapArgs<ExtArgs>
    OsEntryPreinstalled?: boolean | OsEntry$OsEntryPreinstalledArgs<ExtArgs>
    OsEntryReleaseNote?: boolean | OsEntry$OsEntryReleaseNoteArgs<ExtArgs>
    OsEntrySafariVersion?: boolean | OsEntry$OsEntrySafariVersionArgs<ExtArgs>
    OsEntrySecurityNote?: boolean | OsEntry$OsEntrySecurityNoteArgs<ExtArgs>
    SourceEntry?: boolean | OsEntry$SourceEntryArgs<ExtArgs>
    _count?: boolean | OsEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntry"]>

  export type OsEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_id?: boolean
    version?: boolean
    build?: boolean
    release_datetime?: boolean
    release_datetime_depth?: boolean
    is_release?: boolean
    is_beta?: boolean
    is_rc?: boolean
    is_internal?: boolean
    is_rsr?: boolean
    is_sdk?: boolean
    is_simulator?: boolean
    image_id?: boolean
    embedded_os_build?: boolean
    bridge_os_build?: boolean
    notes?: boolean
    legacy_unique_key?: boolean
    search?: boolean
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntry"]>

  export type OsEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_id?: boolean
    version?: boolean
    build?: boolean
    release_datetime?: boolean
    release_datetime_depth?: boolean
    is_release?: boolean
    is_beta?: boolean
    is_rc?: boolean
    is_internal?: boolean
    is_rsr?: boolean
    is_sdk?: boolean
    is_simulator?: boolean
    image_id?: boolean
    embedded_os_build?: boolean
    bridge_os_build?: boolean
    notes?: boolean
    legacy_unique_key?: boolean
    search?: boolean
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntry"]>

  export type OsEntrySelectScalar = {
    id?: boolean
    name_id?: boolean
    version?: boolean
    build?: boolean
    release_datetime?: boolean
    release_datetime_depth?: boolean
    is_release?: boolean
    is_beta?: boolean
    is_rc?: boolean
    is_internal?: boolean
    is_rsr?: boolean
    is_sdk?: boolean
    is_simulator?: boolean
    image_id?: boolean
    embedded_os_build?: boolean
    bridge_os_build?: boolean
    notes?: boolean
    legacy_unique_key?: boolean
    search?: boolean
  }

  export type OsEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_id" | "version" | "build" | "release_datetime" | "release_datetime_depth" | "is_release" | "is_beta" | "is_rc" | "is_internal" | "is_rsr" | "is_sdk" | "is_simulator" | "image_id" | "embedded_os_build" | "bridge_os_build" | "notes" | "legacy_unique_key" | "search", ExtArgs["result"]["osEntry"]>
  export type OsEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapDeviceOs?: boolean | OsEntry$MapDeviceOsArgs<ExtArgs>
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
    OsEntryBuildTrain?: boolean | OsEntry$OsEntryBuildTrainArgs<ExtArgs>
    OsEntryIpd?: boolean | OsEntry$OsEntryIpdArgs<ExtArgs>
    OsEntryOsStringMap?: boolean | OsEntry$OsEntryOsStringMapArgs<ExtArgs>
    OsEntryPreinstalled?: boolean | OsEntry$OsEntryPreinstalledArgs<ExtArgs>
    OsEntryReleaseNote?: boolean | OsEntry$OsEntryReleaseNoteArgs<ExtArgs>
    OsEntrySafariVersion?: boolean | OsEntry$OsEntrySafariVersionArgs<ExtArgs>
    OsEntrySecurityNote?: boolean | OsEntry$OsEntrySecurityNoteArgs<ExtArgs>
    SourceEntry?: boolean | OsEntry$SourceEntryArgs<ExtArgs>
    _count?: boolean | OsEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OsEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
  }
  export type OsEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsLookupName?: boolean | OsLookupNameDefaultArgs<ExtArgs>
  }

  export type $OsEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntry"
    objects: {
      MapDeviceOs: Prisma.$MapDeviceOsPayload<ExtArgs>[]
      OsLookupName: Prisma.$OsLookupNamePayload<ExtArgs>
      OsEntryBuildTrain: Prisma.$OsEntryBuildTrainPayload<ExtArgs>[]
      OsEntryIpd: Prisma.$OsEntryIpdPayload<ExtArgs>[]
      OsEntryOsStringMap: Prisma.$OsEntryOsStringMapPayload<ExtArgs>[]
      OsEntryPreinstalled: Prisma.$OsEntryPreinstalledPayload<ExtArgs>[]
      OsEntryReleaseNote: Prisma.$OsEntryReleaseNotePayload<ExtArgs>[]
      OsEntrySafariVersion: Prisma.$OsEntrySafariVersionPayload<ExtArgs>[]
      OsEntrySecurityNote: Prisma.$OsEntrySecurityNotePayload<ExtArgs>[]
      SourceEntry: Prisma.$SourceEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name_id: number
      version: string
      build: string | null
      release_datetime: Date | null
      release_datetime_depth: number | null
      is_release: boolean | null
      is_beta: boolean | null
      is_rc: boolean | null
      is_internal: boolean | null
      is_rsr: boolean | null
      is_sdk: boolean | null
      is_simulator: boolean | null
      image_id: string | null
      embedded_os_build: string | null
      bridge_os_build: string | null
      notes: string | null
      legacy_unique_key: string | null
      search: string | null
    }, ExtArgs["result"]["osEntry"]>
    composites: {}
  }

  type OsEntryGetPayload<S extends boolean | null | undefined | OsEntryDefaultArgs> = $Result.GetResult<Prisma.$OsEntryPayload, S>

  type OsEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryCountAggregateInputType | true
    }

  export interface OsEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntry'], meta: { name: 'OsEntry' } }
    /**
     * Find zero or one OsEntry that matches the filter.
     * @param {OsEntryFindUniqueArgs} args - Arguments to find a OsEntry
     * @example
     * // Get one OsEntry
     * const osEntry = await prisma.osEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryFindUniqueArgs>(args: SelectSubset<T, OsEntryFindUniqueArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryFindUniqueOrThrowArgs} args - Arguments to find a OsEntry
     * @example
     * // Get one OsEntry
     * const osEntry = await prisma.osEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryFindFirstArgs} args - Arguments to find a OsEntry
     * @example
     * // Get one OsEntry
     * const osEntry = await prisma.osEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryFindFirstArgs>(args?: SelectSubset<T, OsEntryFindFirstArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryFindFirstOrThrowArgs} args - Arguments to find a OsEntry
     * @example
     * // Get one OsEntry
     * const osEntry = await prisma.osEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntries
     * const osEntries = await prisma.osEntry.findMany()
     * 
     * // Get first 10 OsEntries
     * const osEntries = await prisma.osEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const osEntryWithIdOnly = await prisma.osEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OsEntryFindManyArgs>(args?: SelectSubset<T, OsEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntry.
     * @param {OsEntryCreateArgs} args - Arguments to create a OsEntry.
     * @example
     * // Create one OsEntry
     * const OsEntry = await prisma.osEntry.create({
     *   data: {
     *     // ... data to create a OsEntry
     *   }
     * })
     * 
     */
    create<T extends OsEntryCreateArgs>(args: SelectSubset<T, OsEntryCreateArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntries.
     * @param {OsEntryCreateManyArgs} args - Arguments to create many OsEntries.
     * @example
     * // Create many OsEntries
     * const osEntry = await prisma.osEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryCreateManyArgs>(args?: SelectSubset<T, OsEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntries and returns the data saved in the database.
     * @param {OsEntryCreateManyAndReturnArgs} args - Arguments to create many OsEntries.
     * @example
     * // Create many OsEntries
     * const osEntry = await prisma.osEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntries and only return the `id`
     * const osEntryWithIdOnly = await prisma.osEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntry.
     * @param {OsEntryDeleteArgs} args - Arguments to delete one OsEntry.
     * @example
     * // Delete one OsEntry
     * const OsEntry = await prisma.osEntry.delete({
     *   where: {
     *     // ... filter to delete one OsEntry
     *   }
     * })
     * 
     */
    delete<T extends OsEntryDeleteArgs>(args: SelectSubset<T, OsEntryDeleteArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntry.
     * @param {OsEntryUpdateArgs} args - Arguments to update one OsEntry.
     * @example
     * // Update one OsEntry
     * const osEntry = await prisma.osEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryUpdateArgs>(args: SelectSubset<T, OsEntryUpdateArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntries.
     * @param {OsEntryDeleteManyArgs} args - Arguments to filter OsEntries to delete.
     * @example
     * // Delete a few OsEntries
     * const { count } = await prisma.osEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryDeleteManyArgs>(args?: SelectSubset<T, OsEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntries
     * const osEntry = await prisma.osEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryUpdateManyArgs>(args: SelectSubset<T, OsEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntries and returns the data updated in the database.
     * @param {OsEntryUpdateManyAndReturnArgs} args - Arguments to update many OsEntries.
     * @example
     * // Update many OsEntries
     * const osEntry = await prisma.osEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntries and only return the `id`
     * const osEntryWithIdOnly = await prisma.osEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntry.
     * @param {OsEntryUpsertArgs} args - Arguments to update or create a OsEntry.
     * @example
     * // Update or create a OsEntry
     * const osEntry = await prisma.osEntry.upsert({
     *   create: {
     *     // ... data to create a OsEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntry we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryUpsertArgs>(args: SelectSubset<T, OsEntryUpsertArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryCountArgs} args - Arguments to filter OsEntries to count.
     * @example
     * // Count the number of OsEntries
     * const count = await prisma.osEntry.count({
     *   where: {
     *     // ... the filter for the OsEntries we want to count
     *   }
     * })
    **/
    count<T extends OsEntryCountArgs>(
      args?: Subset<T, OsEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryAggregateArgs>(args: Subset<T, OsEntryAggregateArgs>): Prisma.PrismaPromise<GetOsEntryAggregateType<T>>

    /**
     * Group by OsEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntry model
   */
  readonly fields: OsEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MapDeviceOs<T extends OsEntry$MapDeviceOsArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$MapDeviceOsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapDeviceOsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsLookupName<T extends OsLookupNameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsLookupNameDefaultArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OsEntryBuildTrain<T extends OsEntry$OsEntryBuildTrainArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntryBuildTrainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntryIpd<T extends OsEntry$OsEntryIpdArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntryIpdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntryOsStringMap<T extends OsEntry$OsEntryOsStringMapArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntryOsStringMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntryPreinstalled<T extends OsEntry$OsEntryPreinstalledArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntryPreinstalledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntryReleaseNote<T extends OsEntry$OsEntryReleaseNoteArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntryReleaseNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntrySafariVersion<T extends OsEntry$OsEntrySafariVersionArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntrySafariVersionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OsEntrySecurityNote<T extends OsEntry$OsEntrySecurityNoteArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$OsEntrySecurityNoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceEntry<T extends OsEntry$SourceEntryArgs<ExtArgs> = {}>(args?: Subset<T, OsEntry$SourceEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntry model
   */
  interface OsEntryFieldRefs {
    readonly id: FieldRef<"OsEntry", 'Int'>
    readonly name_id: FieldRef<"OsEntry", 'Int'>
    readonly version: FieldRef<"OsEntry", 'String'>
    readonly build: FieldRef<"OsEntry", 'String'>
    readonly release_datetime: FieldRef<"OsEntry", 'DateTime'>
    readonly release_datetime_depth: FieldRef<"OsEntry", 'Int'>
    readonly is_release: FieldRef<"OsEntry", 'Boolean'>
    readonly is_beta: FieldRef<"OsEntry", 'Boolean'>
    readonly is_rc: FieldRef<"OsEntry", 'Boolean'>
    readonly is_internal: FieldRef<"OsEntry", 'Boolean'>
    readonly is_rsr: FieldRef<"OsEntry", 'Boolean'>
    readonly is_sdk: FieldRef<"OsEntry", 'Boolean'>
    readonly is_simulator: FieldRef<"OsEntry", 'Boolean'>
    readonly image_id: FieldRef<"OsEntry", 'String'>
    readonly embedded_os_build: FieldRef<"OsEntry", 'String'>
    readonly bridge_os_build: FieldRef<"OsEntry", 'String'>
    readonly notes: FieldRef<"OsEntry", 'String'>
    readonly legacy_unique_key: FieldRef<"OsEntry", 'String'>
    readonly search: FieldRef<"OsEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OsEntry findUnique
   */
  export type OsEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter, which OsEntry to fetch.
     */
    where: OsEntryWhereUniqueInput
  }

  /**
   * OsEntry findUniqueOrThrow
   */
  export type OsEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter, which OsEntry to fetch.
     */
    where: OsEntryWhereUniqueInput
  }

  /**
   * OsEntry findFirst
   */
  export type OsEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter, which OsEntry to fetch.
     */
    where?: OsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntries to fetch.
     */
    orderBy?: OsEntryOrderByWithRelationInput | OsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntries.
     */
    cursor?: OsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntries.
     */
    distinct?: OsEntryScalarFieldEnum | OsEntryScalarFieldEnum[]
  }

  /**
   * OsEntry findFirstOrThrow
   */
  export type OsEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter, which OsEntry to fetch.
     */
    where?: OsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntries to fetch.
     */
    orderBy?: OsEntryOrderByWithRelationInput | OsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntries.
     */
    cursor?: OsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntries.
     */
    distinct?: OsEntryScalarFieldEnum | OsEntryScalarFieldEnum[]
  }

  /**
   * OsEntry findMany
   */
  export type OsEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter, which OsEntries to fetch.
     */
    where?: OsEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntries to fetch.
     */
    orderBy?: OsEntryOrderByWithRelationInput | OsEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntries.
     */
    cursor?: OsEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntries.
     */
    skip?: number
    distinct?: OsEntryScalarFieldEnum | OsEntryScalarFieldEnum[]
  }

  /**
   * OsEntry create
   */
  export type OsEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntry.
     */
    data: XOR<OsEntryCreateInput, OsEntryUncheckedCreateInput>
  }

  /**
   * OsEntry createMany
   */
  export type OsEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntries.
     */
    data: OsEntryCreateManyInput | OsEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntry createManyAndReturn
   */
  export type OsEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntries.
     */
    data: OsEntryCreateManyInput | OsEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntry update
   */
  export type OsEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntry.
     */
    data: XOR<OsEntryUpdateInput, OsEntryUncheckedUpdateInput>
    /**
     * Choose, which OsEntry to update.
     */
    where: OsEntryWhereUniqueInput
  }

  /**
   * OsEntry updateMany
   */
  export type OsEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntries.
     */
    data: XOR<OsEntryUpdateManyMutationInput, OsEntryUncheckedUpdateManyInput>
    /**
     * Filter which OsEntries to update
     */
    where?: OsEntryWhereInput
    /**
     * Limit how many OsEntries to update.
     */
    limit?: number
  }

  /**
   * OsEntry updateManyAndReturn
   */
  export type OsEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * The data used to update OsEntries.
     */
    data: XOR<OsEntryUpdateManyMutationInput, OsEntryUncheckedUpdateManyInput>
    /**
     * Filter which OsEntries to update
     */
    where?: OsEntryWhereInput
    /**
     * Limit how many OsEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntry upsert
   */
  export type OsEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntry to update in case it exists.
     */
    where: OsEntryWhereUniqueInput
    /**
     * In case the OsEntry found by the `where` argument doesn't exist, create a new OsEntry with this data.
     */
    create: XOR<OsEntryCreateInput, OsEntryUncheckedCreateInput>
    /**
     * In case the OsEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryUpdateInput, OsEntryUncheckedUpdateInput>
  }

  /**
   * OsEntry delete
   */
  export type OsEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    /**
     * Filter which OsEntry to delete.
     */
    where: OsEntryWhereUniqueInput
  }

  /**
   * OsEntry deleteMany
   */
  export type OsEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntries to delete
     */
    where?: OsEntryWhereInput
    /**
     * Limit how many OsEntries to delete.
     */
    limit?: number
  }

  /**
   * OsEntry.MapDeviceOs
   */
  export type OsEntry$MapDeviceOsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapDeviceOs
     */
    select?: MapDeviceOsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapDeviceOs
     */
    omit?: MapDeviceOsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapDeviceOsInclude<ExtArgs> | null
    where?: MapDeviceOsWhereInput
    orderBy?: MapDeviceOsOrderByWithRelationInput | MapDeviceOsOrderByWithRelationInput[]
    cursor?: MapDeviceOsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapDeviceOsScalarFieldEnum | MapDeviceOsScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntryBuildTrain
   */
  export type OsEntry$OsEntryBuildTrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    where?: OsEntryBuildTrainWhereInput
    orderBy?: OsEntryBuildTrainOrderByWithRelationInput | OsEntryBuildTrainOrderByWithRelationInput[]
    cursor?: OsEntryBuildTrainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryBuildTrainScalarFieldEnum | OsEntryBuildTrainScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntryIpd
   */
  export type OsEntry$OsEntryIpdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    where?: OsEntryIpdWhereInput
    orderBy?: OsEntryIpdOrderByWithRelationInput | OsEntryIpdOrderByWithRelationInput[]
    cursor?: OsEntryIpdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryIpdScalarFieldEnum | OsEntryIpdScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntryOsStringMap
   */
  export type OsEntry$OsEntryOsStringMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    where?: OsEntryOsStringMapWhereInput
    orderBy?: OsEntryOsStringMapOrderByWithRelationInput | OsEntryOsStringMapOrderByWithRelationInput[]
    cursor?: OsEntryOsStringMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryOsStringMapScalarFieldEnum | OsEntryOsStringMapScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntryPreinstalled
   */
  export type OsEntry$OsEntryPreinstalledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    where?: OsEntryPreinstalledWhereInput
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    cursor?: OsEntryPreinstalledWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryPreinstalledScalarFieldEnum | OsEntryPreinstalledScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntryReleaseNote
   */
  export type OsEntry$OsEntryReleaseNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    where?: OsEntryReleaseNoteWhereInput
    orderBy?: OsEntryReleaseNoteOrderByWithRelationInput | OsEntryReleaseNoteOrderByWithRelationInput[]
    cursor?: OsEntryReleaseNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryReleaseNoteScalarFieldEnum | OsEntryReleaseNoteScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntrySafariVersion
   */
  export type OsEntry$OsEntrySafariVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    where?: OsEntrySafariVersionWhereInput
    orderBy?: OsEntrySafariVersionOrderByWithRelationInput | OsEntrySafariVersionOrderByWithRelationInput[]
    cursor?: OsEntrySafariVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntrySafariVersionScalarFieldEnum | OsEntrySafariVersionScalarFieldEnum[]
  }

  /**
   * OsEntry.OsEntrySecurityNote
   */
  export type OsEntry$OsEntrySecurityNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    where?: OsEntrySecurityNoteWhereInput
    orderBy?: OsEntrySecurityNoteOrderByWithRelationInput | OsEntrySecurityNoteOrderByWithRelationInput[]
    cursor?: OsEntrySecurityNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntrySecurityNoteScalarFieldEnum | OsEntrySecurityNoteScalarFieldEnum[]
  }

  /**
   * OsEntry.SourceEntry
   */
  export type OsEntry$SourceEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    where?: SourceEntryWhereInput
    orderBy?: SourceEntryOrderByWithRelationInput | SourceEntryOrderByWithRelationInput[]
    cursor?: SourceEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceEntryScalarFieldEnum | SourceEntryScalarFieldEnum[]
  }

  /**
   * OsEntry without action
   */
  export type OsEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
  }


  /**
   * Model OsEntryBuildTrain
   */

  export type AggregateOsEntryBuildTrain = {
    _count: OsEntryBuildTrainCountAggregateOutputType | null
    _avg: OsEntryBuildTrainAvgAggregateOutputType | null
    _sum: OsEntryBuildTrainSumAggregateOutputType | null
    _min: OsEntryBuildTrainMinAggregateOutputType | null
    _max: OsEntryBuildTrainMaxAggregateOutputType | null
  }

  export type OsEntryBuildTrainAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryBuildTrainSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryBuildTrainMinAggregateOutputType = {
    os_id: number | null
    build_train: string | null
  }

  export type OsEntryBuildTrainMaxAggregateOutputType = {
    os_id: number | null
    build_train: string | null
  }

  export type OsEntryBuildTrainCountAggregateOutputType = {
    os_id: number
    build_train: number
    _all: number
  }


  export type OsEntryBuildTrainAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntryBuildTrainSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntryBuildTrainMinAggregateInputType = {
    os_id?: true
    build_train?: true
  }

  export type OsEntryBuildTrainMaxAggregateInputType = {
    os_id?: true
    build_train?: true
  }

  export type OsEntryBuildTrainCountAggregateInputType = {
    os_id?: true
    build_train?: true
    _all?: true
  }

  export type OsEntryBuildTrainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryBuildTrain to aggregate.
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryBuildTrains to fetch.
     */
    orderBy?: OsEntryBuildTrainOrderByWithRelationInput | OsEntryBuildTrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryBuildTrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryBuildTrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryBuildTrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntryBuildTrains
    **/
    _count?: true | OsEntryBuildTrainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryBuildTrainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntryBuildTrainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryBuildTrainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryBuildTrainMaxAggregateInputType
  }

  export type GetOsEntryBuildTrainAggregateType<T extends OsEntryBuildTrainAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntryBuildTrain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntryBuildTrain[P]>
      : GetScalarType<T[P], AggregateOsEntryBuildTrain[P]>
  }




  export type OsEntryBuildTrainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryBuildTrainWhereInput
    orderBy?: OsEntryBuildTrainOrderByWithAggregationInput | OsEntryBuildTrainOrderByWithAggregationInput[]
    by: OsEntryBuildTrainScalarFieldEnum[] | OsEntryBuildTrainScalarFieldEnum
    having?: OsEntryBuildTrainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryBuildTrainCountAggregateInputType | true
    _avg?: OsEntryBuildTrainAvgAggregateInputType
    _sum?: OsEntryBuildTrainSumAggregateInputType
    _min?: OsEntryBuildTrainMinAggregateInputType
    _max?: OsEntryBuildTrainMaxAggregateInputType
  }

  export type OsEntryBuildTrainGroupByOutputType = {
    os_id: number
    build_train: string
    _count: OsEntryBuildTrainCountAggregateOutputType | null
    _avg: OsEntryBuildTrainAvgAggregateOutputType | null
    _sum: OsEntryBuildTrainSumAggregateOutputType | null
    _min: OsEntryBuildTrainMinAggregateOutputType | null
    _max: OsEntryBuildTrainMaxAggregateOutputType | null
  }

  type GetOsEntryBuildTrainGroupByPayload<T extends OsEntryBuildTrainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryBuildTrainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryBuildTrainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryBuildTrainGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryBuildTrainGroupByOutputType[P]>
        }
      >
    >


  export type OsEntryBuildTrainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    build_train?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryBuildTrain"]>

  export type OsEntryBuildTrainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    build_train?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryBuildTrain"]>

  export type OsEntryBuildTrainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    build_train?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryBuildTrain"]>

  export type OsEntryBuildTrainSelectScalar = {
    os_id?: boolean
    build_train?: boolean
  }

  export type OsEntryBuildTrainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "build_train", ExtArgs["result"]["osEntryBuildTrain"]>
  export type OsEntryBuildTrainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryBuildTrainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryBuildTrainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntryBuildTrainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntryBuildTrain"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      build_train: string
    }, ExtArgs["result"]["osEntryBuildTrain"]>
    composites: {}
  }

  type OsEntryBuildTrainGetPayload<S extends boolean | null | undefined | OsEntryBuildTrainDefaultArgs> = $Result.GetResult<Prisma.$OsEntryBuildTrainPayload, S>

  type OsEntryBuildTrainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryBuildTrainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryBuildTrainCountAggregateInputType | true
    }

  export interface OsEntryBuildTrainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntryBuildTrain'], meta: { name: 'OsEntryBuildTrain' } }
    /**
     * Find zero or one OsEntryBuildTrain that matches the filter.
     * @param {OsEntryBuildTrainFindUniqueArgs} args - Arguments to find a OsEntryBuildTrain
     * @example
     * // Get one OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryBuildTrainFindUniqueArgs>(args: SelectSubset<T, OsEntryBuildTrainFindUniqueArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntryBuildTrain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryBuildTrainFindUniqueOrThrowArgs} args - Arguments to find a OsEntryBuildTrain
     * @example
     * // Get one OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryBuildTrainFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryBuildTrainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryBuildTrain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainFindFirstArgs} args - Arguments to find a OsEntryBuildTrain
     * @example
     * // Get one OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryBuildTrainFindFirstArgs>(args?: SelectSubset<T, OsEntryBuildTrainFindFirstArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryBuildTrain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainFindFirstOrThrowArgs} args - Arguments to find a OsEntryBuildTrain
     * @example
     * // Get one OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryBuildTrainFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryBuildTrainFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntryBuildTrains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntryBuildTrains
     * const osEntryBuildTrains = await prisma.osEntryBuildTrain.findMany()
     * 
     * // Get first 10 OsEntryBuildTrains
     * const osEntryBuildTrains = await prisma.osEntryBuildTrain.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntryBuildTrainWithOs_idOnly = await prisma.osEntryBuildTrain.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntryBuildTrainFindManyArgs>(args?: SelectSubset<T, OsEntryBuildTrainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntryBuildTrain.
     * @param {OsEntryBuildTrainCreateArgs} args - Arguments to create a OsEntryBuildTrain.
     * @example
     * // Create one OsEntryBuildTrain
     * const OsEntryBuildTrain = await prisma.osEntryBuildTrain.create({
     *   data: {
     *     // ... data to create a OsEntryBuildTrain
     *   }
     * })
     * 
     */
    create<T extends OsEntryBuildTrainCreateArgs>(args: SelectSubset<T, OsEntryBuildTrainCreateArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntryBuildTrains.
     * @param {OsEntryBuildTrainCreateManyArgs} args - Arguments to create many OsEntryBuildTrains.
     * @example
     * // Create many OsEntryBuildTrains
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryBuildTrainCreateManyArgs>(args?: SelectSubset<T, OsEntryBuildTrainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntryBuildTrains and returns the data saved in the database.
     * @param {OsEntryBuildTrainCreateManyAndReturnArgs} args - Arguments to create many OsEntryBuildTrains.
     * @example
     * // Create many OsEntryBuildTrains
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntryBuildTrains and only return the `os_id`
     * const osEntryBuildTrainWithOs_idOnly = await prisma.osEntryBuildTrain.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryBuildTrainCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryBuildTrainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntryBuildTrain.
     * @param {OsEntryBuildTrainDeleteArgs} args - Arguments to delete one OsEntryBuildTrain.
     * @example
     * // Delete one OsEntryBuildTrain
     * const OsEntryBuildTrain = await prisma.osEntryBuildTrain.delete({
     *   where: {
     *     // ... filter to delete one OsEntryBuildTrain
     *   }
     * })
     * 
     */
    delete<T extends OsEntryBuildTrainDeleteArgs>(args: SelectSubset<T, OsEntryBuildTrainDeleteArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntryBuildTrain.
     * @param {OsEntryBuildTrainUpdateArgs} args - Arguments to update one OsEntryBuildTrain.
     * @example
     * // Update one OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryBuildTrainUpdateArgs>(args: SelectSubset<T, OsEntryBuildTrainUpdateArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntryBuildTrains.
     * @param {OsEntryBuildTrainDeleteManyArgs} args - Arguments to filter OsEntryBuildTrains to delete.
     * @example
     * // Delete a few OsEntryBuildTrains
     * const { count } = await prisma.osEntryBuildTrain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryBuildTrainDeleteManyArgs>(args?: SelectSubset<T, OsEntryBuildTrainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryBuildTrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntryBuildTrains
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryBuildTrainUpdateManyArgs>(args: SelectSubset<T, OsEntryBuildTrainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryBuildTrains and returns the data updated in the database.
     * @param {OsEntryBuildTrainUpdateManyAndReturnArgs} args - Arguments to update many OsEntryBuildTrains.
     * @example
     * // Update many OsEntryBuildTrains
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntryBuildTrains and only return the `os_id`
     * const osEntryBuildTrainWithOs_idOnly = await prisma.osEntryBuildTrain.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryBuildTrainUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryBuildTrainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntryBuildTrain.
     * @param {OsEntryBuildTrainUpsertArgs} args - Arguments to update or create a OsEntryBuildTrain.
     * @example
     * // Update or create a OsEntryBuildTrain
     * const osEntryBuildTrain = await prisma.osEntryBuildTrain.upsert({
     *   create: {
     *     // ... data to create a OsEntryBuildTrain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntryBuildTrain we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryBuildTrainUpsertArgs>(args: SelectSubset<T, OsEntryBuildTrainUpsertArgs<ExtArgs>>): Prisma__OsEntryBuildTrainClient<$Result.GetResult<Prisma.$OsEntryBuildTrainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntryBuildTrains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainCountArgs} args - Arguments to filter OsEntryBuildTrains to count.
     * @example
     * // Count the number of OsEntryBuildTrains
     * const count = await prisma.osEntryBuildTrain.count({
     *   where: {
     *     // ... the filter for the OsEntryBuildTrains we want to count
     *   }
     * })
    **/
    count<T extends OsEntryBuildTrainCountArgs>(
      args?: Subset<T, OsEntryBuildTrainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryBuildTrainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntryBuildTrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryBuildTrainAggregateArgs>(args: Subset<T, OsEntryBuildTrainAggregateArgs>): Prisma.PrismaPromise<GetOsEntryBuildTrainAggregateType<T>>

    /**
     * Group by OsEntryBuildTrain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryBuildTrainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryBuildTrainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryBuildTrainGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryBuildTrainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryBuildTrainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryBuildTrainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntryBuildTrain model
   */
  readonly fields: OsEntryBuildTrainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntryBuildTrain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryBuildTrainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntryBuildTrain model
   */
  interface OsEntryBuildTrainFieldRefs {
    readonly os_id: FieldRef<"OsEntryBuildTrain", 'Int'>
    readonly build_train: FieldRef<"OsEntryBuildTrain", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OsEntryBuildTrain findUnique
   */
  export type OsEntryBuildTrainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryBuildTrain to fetch.
     */
    where: OsEntryBuildTrainWhereUniqueInput
  }

  /**
   * OsEntryBuildTrain findUniqueOrThrow
   */
  export type OsEntryBuildTrainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryBuildTrain to fetch.
     */
    where: OsEntryBuildTrainWhereUniqueInput
  }

  /**
   * OsEntryBuildTrain findFirst
   */
  export type OsEntryBuildTrainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryBuildTrain to fetch.
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryBuildTrains to fetch.
     */
    orderBy?: OsEntryBuildTrainOrderByWithRelationInput | OsEntryBuildTrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryBuildTrains.
     */
    cursor?: OsEntryBuildTrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryBuildTrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryBuildTrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryBuildTrains.
     */
    distinct?: OsEntryBuildTrainScalarFieldEnum | OsEntryBuildTrainScalarFieldEnum[]
  }

  /**
   * OsEntryBuildTrain findFirstOrThrow
   */
  export type OsEntryBuildTrainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryBuildTrain to fetch.
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryBuildTrains to fetch.
     */
    orderBy?: OsEntryBuildTrainOrderByWithRelationInput | OsEntryBuildTrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryBuildTrains.
     */
    cursor?: OsEntryBuildTrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryBuildTrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryBuildTrains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryBuildTrains.
     */
    distinct?: OsEntryBuildTrainScalarFieldEnum | OsEntryBuildTrainScalarFieldEnum[]
  }

  /**
   * OsEntryBuildTrain findMany
   */
  export type OsEntryBuildTrainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryBuildTrains to fetch.
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryBuildTrains to fetch.
     */
    orderBy?: OsEntryBuildTrainOrderByWithRelationInput | OsEntryBuildTrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntryBuildTrains.
     */
    cursor?: OsEntryBuildTrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryBuildTrains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryBuildTrains.
     */
    skip?: number
    distinct?: OsEntryBuildTrainScalarFieldEnum | OsEntryBuildTrainScalarFieldEnum[]
  }

  /**
   * OsEntryBuildTrain create
   */
  export type OsEntryBuildTrainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntryBuildTrain.
     */
    data: XOR<OsEntryBuildTrainCreateInput, OsEntryBuildTrainUncheckedCreateInput>
  }

  /**
   * OsEntryBuildTrain createMany
   */
  export type OsEntryBuildTrainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntryBuildTrains.
     */
    data: OsEntryBuildTrainCreateManyInput | OsEntryBuildTrainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntryBuildTrain createManyAndReturn
   */
  export type OsEntryBuildTrainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntryBuildTrains.
     */
    data: OsEntryBuildTrainCreateManyInput | OsEntryBuildTrainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryBuildTrain update
   */
  export type OsEntryBuildTrainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntryBuildTrain.
     */
    data: XOR<OsEntryBuildTrainUpdateInput, OsEntryBuildTrainUncheckedUpdateInput>
    /**
     * Choose, which OsEntryBuildTrain to update.
     */
    where: OsEntryBuildTrainWhereUniqueInput
  }

  /**
   * OsEntryBuildTrain updateMany
   */
  export type OsEntryBuildTrainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntryBuildTrains.
     */
    data: XOR<OsEntryBuildTrainUpdateManyMutationInput, OsEntryBuildTrainUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryBuildTrains to update
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * Limit how many OsEntryBuildTrains to update.
     */
    limit?: number
  }

  /**
   * OsEntryBuildTrain updateManyAndReturn
   */
  export type OsEntryBuildTrainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * The data used to update OsEntryBuildTrains.
     */
    data: XOR<OsEntryBuildTrainUpdateManyMutationInput, OsEntryBuildTrainUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryBuildTrains to update
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * Limit how many OsEntryBuildTrains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryBuildTrain upsert
   */
  export type OsEntryBuildTrainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntryBuildTrain to update in case it exists.
     */
    where: OsEntryBuildTrainWhereUniqueInput
    /**
     * In case the OsEntryBuildTrain found by the `where` argument doesn't exist, create a new OsEntryBuildTrain with this data.
     */
    create: XOR<OsEntryBuildTrainCreateInput, OsEntryBuildTrainUncheckedCreateInput>
    /**
     * In case the OsEntryBuildTrain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryBuildTrainUpdateInput, OsEntryBuildTrainUncheckedUpdateInput>
  }

  /**
   * OsEntryBuildTrain delete
   */
  export type OsEntryBuildTrainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
    /**
     * Filter which OsEntryBuildTrain to delete.
     */
    where: OsEntryBuildTrainWhereUniqueInput
  }

  /**
   * OsEntryBuildTrain deleteMany
   */
  export type OsEntryBuildTrainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryBuildTrains to delete
     */
    where?: OsEntryBuildTrainWhereInput
    /**
     * Limit how many OsEntryBuildTrains to delete.
     */
    limit?: number
  }

  /**
   * OsEntryBuildTrain without action
   */
  export type OsEntryBuildTrainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryBuildTrain
     */
    select?: OsEntryBuildTrainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryBuildTrain
     */
    omit?: OsEntryBuildTrainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryBuildTrainInclude<ExtArgs> | null
  }


  /**
   * Model OsEntryIpd
   */

  export type AggregateOsEntryIpd = {
    _count: OsEntryIpdCountAggregateOutputType | null
    _avg: OsEntryIpdAvgAggregateOutputType | null
    _sum: OsEntryIpdSumAggregateOutputType | null
    _min: OsEntryIpdMinAggregateOutputType | null
    _max: OsEntryIpdMaxAggregateOutputType | null
  }

  export type OsEntryIpdAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryIpdSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryIpdMinAggregateOutputType = {
    os_id: number | null
    ipd_type: string | null
    url: string | null
    active: boolean | null
  }

  export type OsEntryIpdMaxAggregateOutputType = {
    os_id: number | null
    ipd_type: string | null
    url: string | null
    active: boolean | null
  }

  export type OsEntryIpdCountAggregateOutputType = {
    os_id: number
    ipd_type: number
    url: number
    active: number
    _all: number
  }


  export type OsEntryIpdAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntryIpdSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntryIpdMinAggregateInputType = {
    os_id?: true
    ipd_type?: true
    url?: true
    active?: true
  }

  export type OsEntryIpdMaxAggregateInputType = {
    os_id?: true
    ipd_type?: true
    url?: true
    active?: true
  }

  export type OsEntryIpdCountAggregateInputType = {
    os_id?: true
    ipd_type?: true
    url?: true
    active?: true
    _all?: true
  }

  export type OsEntryIpdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryIpd to aggregate.
     */
    where?: OsEntryIpdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryIpds to fetch.
     */
    orderBy?: OsEntryIpdOrderByWithRelationInput | OsEntryIpdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryIpdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryIpds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryIpds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntryIpds
    **/
    _count?: true | OsEntryIpdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryIpdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntryIpdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryIpdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryIpdMaxAggregateInputType
  }

  export type GetOsEntryIpdAggregateType<T extends OsEntryIpdAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntryIpd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntryIpd[P]>
      : GetScalarType<T[P], AggregateOsEntryIpd[P]>
  }




  export type OsEntryIpdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryIpdWhereInput
    orderBy?: OsEntryIpdOrderByWithAggregationInput | OsEntryIpdOrderByWithAggregationInput[]
    by: OsEntryIpdScalarFieldEnum[] | OsEntryIpdScalarFieldEnum
    having?: OsEntryIpdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryIpdCountAggregateInputType | true
    _avg?: OsEntryIpdAvgAggregateInputType
    _sum?: OsEntryIpdSumAggregateInputType
    _min?: OsEntryIpdMinAggregateInputType
    _max?: OsEntryIpdMaxAggregateInputType
  }

  export type OsEntryIpdGroupByOutputType = {
    os_id: number
    ipd_type: string
    url: string | null
    active: boolean | null
    _count: OsEntryIpdCountAggregateOutputType | null
    _avg: OsEntryIpdAvgAggregateOutputType | null
    _sum: OsEntryIpdSumAggregateOutputType | null
    _min: OsEntryIpdMinAggregateOutputType | null
    _max: OsEntryIpdMaxAggregateOutputType | null
  }

  type GetOsEntryIpdGroupByPayload<T extends OsEntryIpdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryIpdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryIpdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryIpdGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryIpdGroupByOutputType[P]>
        }
      >
    >


  export type OsEntryIpdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    ipd_type?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryIpd"]>

  export type OsEntryIpdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    ipd_type?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryIpd"]>

  export type OsEntryIpdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    ipd_type?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryIpd"]>

  export type OsEntryIpdSelectScalar = {
    os_id?: boolean
    ipd_type?: boolean
    url?: boolean
    active?: boolean
  }

  export type OsEntryIpdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "ipd_type" | "url" | "active", ExtArgs["result"]["osEntryIpd"]>
  export type OsEntryIpdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryIpdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryIpdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntryIpdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntryIpd"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      ipd_type: string
      url: string | null
      active: boolean | null
    }, ExtArgs["result"]["osEntryIpd"]>
    composites: {}
  }

  type OsEntryIpdGetPayload<S extends boolean | null | undefined | OsEntryIpdDefaultArgs> = $Result.GetResult<Prisma.$OsEntryIpdPayload, S>

  type OsEntryIpdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryIpdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryIpdCountAggregateInputType | true
    }

  export interface OsEntryIpdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntryIpd'], meta: { name: 'OsEntryIpd' } }
    /**
     * Find zero or one OsEntryIpd that matches the filter.
     * @param {OsEntryIpdFindUniqueArgs} args - Arguments to find a OsEntryIpd
     * @example
     * // Get one OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryIpdFindUniqueArgs>(args: SelectSubset<T, OsEntryIpdFindUniqueArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntryIpd that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryIpdFindUniqueOrThrowArgs} args - Arguments to find a OsEntryIpd
     * @example
     * // Get one OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryIpdFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryIpdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryIpd that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdFindFirstArgs} args - Arguments to find a OsEntryIpd
     * @example
     * // Get one OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryIpdFindFirstArgs>(args?: SelectSubset<T, OsEntryIpdFindFirstArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryIpd that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdFindFirstOrThrowArgs} args - Arguments to find a OsEntryIpd
     * @example
     * // Get one OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryIpdFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryIpdFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntryIpds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntryIpds
     * const osEntryIpds = await prisma.osEntryIpd.findMany()
     * 
     * // Get first 10 OsEntryIpds
     * const osEntryIpds = await prisma.osEntryIpd.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntryIpdWithOs_idOnly = await prisma.osEntryIpd.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntryIpdFindManyArgs>(args?: SelectSubset<T, OsEntryIpdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntryIpd.
     * @param {OsEntryIpdCreateArgs} args - Arguments to create a OsEntryIpd.
     * @example
     * // Create one OsEntryIpd
     * const OsEntryIpd = await prisma.osEntryIpd.create({
     *   data: {
     *     // ... data to create a OsEntryIpd
     *   }
     * })
     * 
     */
    create<T extends OsEntryIpdCreateArgs>(args: SelectSubset<T, OsEntryIpdCreateArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntryIpds.
     * @param {OsEntryIpdCreateManyArgs} args - Arguments to create many OsEntryIpds.
     * @example
     * // Create many OsEntryIpds
     * const osEntryIpd = await prisma.osEntryIpd.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryIpdCreateManyArgs>(args?: SelectSubset<T, OsEntryIpdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntryIpds and returns the data saved in the database.
     * @param {OsEntryIpdCreateManyAndReturnArgs} args - Arguments to create many OsEntryIpds.
     * @example
     * // Create many OsEntryIpds
     * const osEntryIpd = await prisma.osEntryIpd.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntryIpds and only return the `os_id`
     * const osEntryIpdWithOs_idOnly = await prisma.osEntryIpd.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryIpdCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryIpdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntryIpd.
     * @param {OsEntryIpdDeleteArgs} args - Arguments to delete one OsEntryIpd.
     * @example
     * // Delete one OsEntryIpd
     * const OsEntryIpd = await prisma.osEntryIpd.delete({
     *   where: {
     *     // ... filter to delete one OsEntryIpd
     *   }
     * })
     * 
     */
    delete<T extends OsEntryIpdDeleteArgs>(args: SelectSubset<T, OsEntryIpdDeleteArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntryIpd.
     * @param {OsEntryIpdUpdateArgs} args - Arguments to update one OsEntryIpd.
     * @example
     * // Update one OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryIpdUpdateArgs>(args: SelectSubset<T, OsEntryIpdUpdateArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntryIpds.
     * @param {OsEntryIpdDeleteManyArgs} args - Arguments to filter OsEntryIpds to delete.
     * @example
     * // Delete a few OsEntryIpds
     * const { count } = await prisma.osEntryIpd.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryIpdDeleteManyArgs>(args?: SelectSubset<T, OsEntryIpdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryIpds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntryIpds
     * const osEntryIpd = await prisma.osEntryIpd.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryIpdUpdateManyArgs>(args: SelectSubset<T, OsEntryIpdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryIpds and returns the data updated in the database.
     * @param {OsEntryIpdUpdateManyAndReturnArgs} args - Arguments to update many OsEntryIpds.
     * @example
     * // Update many OsEntryIpds
     * const osEntryIpd = await prisma.osEntryIpd.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntryIpds and only return the `os_id`
     * const osEntryIpdWithOs_idOnly = await prisma.osEntryIpd.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryIpdUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryIpdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntryIpd.
     * @param {OsEntryIpdUpsertArgs} args - Arguments to update or create a OsEntryIpd.
     * @example
     * // Update or create a OsEntryIpd
     * const osEntryIpd = await prisma.osEntryIpd.upsert({
     *   create: {
     *     // ... data to create a OsEntryIpd
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntryIpd we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryIpdUpsertArgs>(args: SelectSubset<T, OsEntryIpdUpsertArgs<ExtArgs>>): Prisma__OsEntryIpdClient<$Result.GetResult<Prisma.$OsEntryIpdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntryIpds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdCountArgs} args - Arguments to filter OsEntryIpds to count.
     * @example
     * // Count the number of OsEntryIpds
     * const count = await prisma.osEntryIpd.count({
     *   where: {
     *     // ... the filter for the OsEntryIpds we want to count
     *   }
     * })
    **/
    count<T extends OsEntryIpdCountArgs>(
      args?: Subset<T, OsEntryIpdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryIpdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntryIpd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryIpdAggregateArgs>(args: Subset<T, OsEntryIpdAggregateArgs>): Prisma.PrismaPromise<GetOsEntryIpdAggregateType<T>>

    /**
     * Group by OsEntryIpd.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryIpdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryIpdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryIpdGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryIpdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryIpdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryIpdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntryIpd model
   */
  readonly fields: OsEntryIpdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntryIpd.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryIpdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntryIpd model
   */
  interface OsEntryIpdFieldRefs {
    readonly os_id: FieldRef<"OsEntryIpd", 'Int'>
    readonly ipd_type: FieldRef<"OsEntryIpd", 'String'>
    readonly url: FieldRef<"OsEntryIpd", 'String'>
    readonly active: FieldRef<"OsEntryIpd", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OsEntryIpd findUnique
   */
  export type OsEntryIpdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryIpd to fetch.
     */
    where: OsEntryIpdWhereUniqueInput
  }

  /**
   * OsEntryIpd findUniqueOrThrow
   */
  export type OsEntryIpdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryIpd to fetch.
     */
    where: OsEntryIpdWhereUniqueInput
  }

  /**
   * OsEntryIpd findFirst
   */
  export type OsEntryIpdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryIpd to fetch.
     */
    where?: OsEntryIpdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryIpds to fetch.
     */
    orderBy?: OsEntryIpdOrderByWithRelationInput | OsEntryIpdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryIpds.
     */
    cursor?: OsEntryIpdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryIpds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryIpds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryIpds.
     */
    distinct?: OsEntryIpdScalarFieldEnum | OsEntryIpdScalarFieldEnum[]
  }

  /**
   * OsEntryIpd findFirstOrThrow
   */
  export type OsEntryIpdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryIpd to fetch.
     */
    where?: OsEntryIpdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryIpds to fetch.
     */
    orderBy?: OsEntryIpdOrderByWithRelationInput | OsEntryIpdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryIpds.
     */
    cursor?: OsEntryIpdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryIpds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryIpds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryIpds.
     */
    distinct?: OsEntryIpdScalarFieldEnum | OsEntryIpdScalarFieldEnum[]
  }

  /**
   * OsEntryIpd findMany
   */
  export type OsEntryIpdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryIpds to fetch.
     */
    where?: OsEntryIpdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryIpds to fetch.
     */
    orderBy?: OsEntryIpdOrderByWithRelationInput | OsEntryIpdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntryIpds.
     */
    cursor?: OsEntryIpdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryIpds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryIpds.
     */
    skip?: number
    distinct?: OsEntryIpdScalarFieldEnum | OsEntryIpdScalarFieldEnum[]
  }

  /**
   * OsEntryIpd create
   */
  export type OsEntryIpdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntryIpd.
     */
    data: XOR<OsEntryIpdCreateInput, OsEntryIpdUncheckedCreateInput>
  }

  /**
   * OsEntryIpd createMany
   */
  export type OsEntryIpdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntryIpds.
     */
    data: OsEntryIpdCreateManyInput | OsEntryIpdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntryIpd createManyAndReturn
   */
  export type OsEntryIpdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntryIpds.
     */
    data: OsEntryIpdCreateManyInput | OsEntryIpdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryIpd update
   */
  export type OsEntryIpdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntryIpd.
     */
    data: XOR<OsEntryIpdUpdateInput, OsEntryIpdUncheckedUpdateInput>
    /**
     * Choose, which OsEntryIpd to update.
     */
    where: OsEntryIpdWhereUniqueInput
  }

  /**
   * OsEntryIpd updateMany
   */
  export type OsEntryIpdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntryIpds.
     */
    data: XOR<OsEntryIpdUpdateManyMutationInput, OsEntryIpdUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryIpds to update
     */
    where?: OsEntryIpdWhereInput
    /**
     * Limit how many OsEntryIpds to update.
     */
    limit?: number
  }

  /**
   * OsEntryIpd updateManyAndReturn
   */
  export type OsEntryIpdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * The data used to update OsEntryIpds.
     */
    data: XOR<OsEntryIpdUpdateManyMutationInput, OsEntryIpdUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryIpds to update
     */
    where?: OsEntryIpdWhereInput
    /**
     * Limit how many OsEntryIpds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryIpd upsert
   */
  export type OsEntryIpdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntryIpd to update in case it exists.
     */
    where: OsEntryIpdWhereUniqueInput
    /**
     * In case the OsEntryIpd found by the `where` argument doesn't exist, create a new OsEntryIpd with this data.
     */
    create: XOR<OsEntryIpdCreateInput, OsEntryIpdUncheckedCreateInput>
    /**
     * In case the OsEntryIpd was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryIpdUpdateInput, OsEntryIpdUncheckedUpdateInput>
  }

  /**
   * OsEntryIpd delete
   */
  export type OsEntryIpdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
    /**
     * Filter which OsEntryIpd to delete.
     */
    where: OsEntryIpdWhereUniqueInput
  }

  /**
   * OsEntryIpd deleteMany
   */
  export type OsEntryIpdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryIpds to delete
     */
    where?: OsEntryIpdWhereInput
    /**
     * Limit how many OsEntryIpds to delete.
     */
    limit?: number
  }

  /**
   * OsEntryIpd without action
   */
  export type OsEntryIpdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryIpd
     */
    select?: OsEntryIpdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryIpd
     */
    omit?: OsEntryIpdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryIpdInclude<ExtArgs> | null
  }


  /**
   * Model OsEntryOsStringMap
   */

  export type AggregateOsEntryOsStringMap = {
    _count: OsEntryOsStringMapCountAggregateOutputType | null
    _avg: OsEntryOsStringMapAvgAggregateOutputType | null
    _sum: OsEntryOsStringMapSumAggregateOutputType | null
    _min: OsEntryOsStringMapMinAggregateOutputType | null
    _max: OsEntryOsStringMapMaxAggregateOutputType | null
  }

  export type OsEntryOsStringMapAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryOsStringMapSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryOsStringMapMinAggregateOutputType = {
    os_id: number | null
    os_string: string | null
  }

  export type OsEntryOsStringMapMaxAggregateOutputType = {
    os_id: number | null
    os_string: string | null
  }

  export type OsEntryOsStringMapCountAggregateOutputType = {
    os_id: number
    os_string: number
    _all: number
  }


  export type OsEntryOsStringMapAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntryOsStringMapSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntryOsStringMapMinAggregateInputType = {
    os_id?: true
    os_string?: true
  }

  export type OsEntryOsStringMapMaxAggregateInputType = {
    os_id?: true
    os_string?: true
  }

  export type OsEntryOsStringMapCountAggregateInputType = {
    os_id?: true
    os_string?: true
    _all?: true
  }

  export type OsEntryOsStringMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryOsStringMap to aggregate.
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryOsStringMaps to fetch.
     */
    orderBy?: OsEntryOsStringMapOrderByWithRelationInput | OsEntryOsStringMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryOsStringMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryOsStringMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryOsStringMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntryOsStringMaps
    **/
    _count?: true | OsEntryOsStringMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryOsStringMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntryOsStringMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryOsStringMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryOsStringMapMaxAggregateInputType
  }

  export type GetOsEntryOsStringMapAggregateType<T extends OsEntryOsStringMapAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntryOsStringMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntryOsStringMap[P]>
      : GetScalarType<T[P], AggregateOsEntryOsStringMap[P]>
  }




  export type OsEntryOsStringMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryOsStringMapWhereInput
    orderBy?: OsEntryOsStringMapOrderByWithAggregationInput | OsEntryOsStringMapOrderByWithAggregationInput[]
    by: OsEntryOsStringMapScalarFieldEnum[] | OsEntryOsStringMapScalarFieldEnum
    having?: OsEntryOsStringMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryOsStringMapCountAggregateInputType | true
    _avg?: OsEntryOsStringMapAvgAggregateInputType
    _sum?: OsEntryOsStringMapSumAggregateInputType
    _min?: OsEntryOsStringMapMinAggregateInputType
    _max?: OsEntryOsStringMapMaxAggregateInputType
  }

  export type OsEntryOsStringMapGroupByOutputType = {
    os_id: number
    os_string: string
    _count: OsEntryOsStringMapCountAggregateOutputType | null
    _avg: OsEntryOsStringMapAvgAggregateOutputType | null
    _sum: OsEntryOsStringMapSumAggregateOutputType | null
    _min: OsEntryOsStringMapMinAggregateOutputType | null
    _max: OsEntryOsStringMapMaxAggregateOutputType | null
  }

  type GetOsEntryOsStringMapGroupByPayload<T extends OsEntryOsStringMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryOsStringMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryOsStringMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryOsStringMapGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryOsStringMapGroupByOutputType[P]>
        }
      >
    >


  export type OsEntryOsStringMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    os_string?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryOsStringMap"]>

  export type OsEntryOsStringMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    os_string?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryOsStringMap"]>

  export type OsEntryOsStringMapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    os_string?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryOsStringMap"]>

  export type OsEntryOsStringMapSelectScalar = {
    os_id?: boolean
    os_string?: boolean
  }

  export type OsEntryOsStringMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "os_string", ExtArgs["result"]["osEntryOsStringMap"]>
  export type OsEntryOsStringMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryOsStringMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryOsStringMapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntryOsStringMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntryOsStringMap"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      os_string: string
    }, ExtArgs["result"]["osEntryOsStringMap"]>
    composites: {}
  }

  type OsEntryOsStringMapGetPayload<S extends boolean | null | undefined | OsEntryOsStringMapDefaultArgs> = $Result.GetResult<Prisma.$OsEntryOsStringMapPayload, S>

  type OsEntryOsStringMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryOsStringMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryOsStringMapCountAggregateInputType | true
    }

  export interface OsEntryOsStringMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntryOsStringMap'], meta: { name: 'OsEntryOsStringMap' } }
    /**
     * Find zero or one OsEntryOsStringMap that matches the filter.
     * @param {OsEntryOsStringMapFindUniqueArgs} args - Arguments to find a OsEntryOsStringMap
     * @example
     * // Get one OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryOsStringMapFindUniqueArgs>(args: SelectSubset<T, OsEntryOsStringMapFindUniqueArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntryOsStringMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryOsStringMapFindUniqueOrThrowArgs} args - Arguments to find a OsEntryOsStringMap
     * @example
     * // Get one OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryOsStringMapFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryOsStringMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryOsStringMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapFindFirstArgs} args - Arguments to find a OsEntryOsStringMap
     * @example
     * // Get one OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryOsStringMapFindFirstArgs>(args?: SelectSubset<T, OsEntryOsStringMapFindFirstArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryOsStringMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapFindFirstOrThrowArgs} args - Arguments to find a OsEntryOsStringMap
     * @example
     * // Get one OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryOsStringMapFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryOsStringMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntryOsStringMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntryOsStringMaps
     * const osEntryOsStringMaps = await prisma.osEntryOsStringMap.findMany()
     * 
     * // Get first 10 OsEntryOsStringMaps
     * const osEntryOsStringMaps = await prisma.osEntryOsStringMap.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntryOsStringMapWithOs_idOnly = await prisma.osEntryOsStringMap.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntryOsStringMapFindManyArgs>(args?: SelectSubset<T, OsEntryOsStringMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntryOsStringMap.
     * @param {OsEntryOsStringMapCreateArgs} args - Arguments to create a OsEntryOsStringMap.
     * @example
     * // Create one OsEntryOsStringMap
     * const OsEntryOsStringMap = await prisma.osEntryOsStringMap.create({
     *   data: {
     *     // ... data to create a OsEntryOsStringMap
     *   }
     * })
     * 
     */
    create<T extends OsEntryOsStringMapCreateArgs>(args: SelectSubset<T, OsEntryOsStringMapCreateArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntryOsStringMaps.
     * @param {OsEntryOsStringMapCreateManyArgs} args - Arguments to create many OsEntryOsStringMaps.
     * @example
     * // Create many OsEntryOsStringMaps
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryOsStringMapCreateManyArgs>(args?: SelectSubset<T, OsEntryOsStringMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntryOsStringMaps and returns the data saved in the database.
     * @param {OsEntryOsStringMapCreateManyAndReturnArgs} args - Arguments to create many OsEntryOsStringMaps.
     * @example
     * // Create many OsEntryOsStringMaps
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntryOsStringMaps and only return the `os_id`
     * const osEntryOsStringMapWithOs_idOnly = await prisma.osEntryOsStringMap.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryOsStringMapCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryOsStringMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntryOsStringMap.
     * @param {OsEntryOsStringMapDeleteArgs} args - Arguments to delete one OsEntryOsStringMap.
     * @example
     * // Delete one OsEntryOsStringMap
     * const OsEntryOsStringMap = await prisma.osEntryOsStringMap.delete({
     *   where: {
     *     // ... filter to delete one OsEntryOsStringMap
     *   }
     * })
     * 
     */
    delete<T extends OsEntryOsStringMapDeleteArgs>(args: SelectSubset<T, OsEntryOsStringMapDeleteArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntryOsStringMap.
     * @param {OsEntryOsStringMapUpdateArgs} args - Arguments to update one OsEntryOsStringMap.
     * @example
     * // Update one OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryOsStringMapUpdateArgs>(args: SelectSubset<T, OsEntryOsStringMapUpdateArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntryOsStringMaps.
     * @param {OsEntryOsStringMapDeleteManyArgs} args - Arguments to filter OsEntryOsStringMaps to delete.
     * @example
     * // Delete a few OsEntryOsStringMaps
     * const { count } = await prisma.osEntryOsStringMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryOsStringMapDeleteManyArgs>(args?: SelectSubset<T, OsEntryOsStringMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryOsStringMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntryOsStringMaps
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryOsStringMapUpdateManyArgs>(args: SelectSubset<T, OsEntryOsStringMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryOsStringMaps and returns the data updated in the database.
     * @param {OsEntryOsStringMapUpdateManyAndReturnArgs} args - Arguments to update many OsEntryOsStringMaps.
     * @example
     * // Update many OsEntryOsStringMaps
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntryOsStringMaps and only return the `os_id`
     * const osEntryOsStringMapWithOs_idOnly = await prisma.osEntryOsStringMap.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryOsStringMapUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryOsStringMapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntryOsStringMap.
     * @param {OsEntryOsStringMapUpsertArgs} args - Arguments to update or create a OsEntryOsStringMap.
     * @example
     * // Update or create a OsEntryOsStringMap
     * const osEntryOsStringMap = await prisma.osEntryOsStringMap.upsert({
     *   create: {
     *     // ... data to create a OsEntryOsStringMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntryOsStringMap we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryOsStringMapUpsertArgs>(args: SelectSubset<T, OsEntryOsStringMapUpsertArgs<ExtArgs>>): Prisma__OsEntryOsStringMapClient<$Result.GetResult<Prisma.$OsEntryOsStringMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntryOsStringMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapCountArgs} args - Arguments to filter OsEntryOsStringMaps to count.
     * @example
     * // Count the number of OsEntryOsStringMaps
     * const count = await prisma.osEntryOsStringMap.count({
     *   where: {
     *     // ... the filter for the OsEntryOsStringMaps we want to count
     *   }
     * })
    **/
    count<T extends OsEntryOsStringMapCountArgs>(
      args?: Subset<T, OsEntryOsStringMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryOsStringMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntryOsStringMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryOsStringMapAggregateArgs>(args: Subset<T, OsEntryOsStringMapAggregateArgs>): Prisma.PrismaPromise<GetOsEntryOsStringMapAggregateType<T>>

    /**
     * Group by OsEntryOsStringMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryOsStringMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryOsStringMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryOsStringMapGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryOsStringMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryOsStringMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryOsStringMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntryOsStringMap model
   */
  readonly fields: OsEntryOsStringMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntryOsStringMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryOsStringMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntryOsStringMap model
   */
  interface OsEntryOsStringMapFieldRefs {
    readonly os_id: FieldRef<"OsEntryOsStringMap", 'Int'>
    readonly os_string: FieldRef<"OsEntryOsStringMap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OsEntryOsStringMap findUnique
   */
  export type OsEntryOsStringMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryOsStringMap to fetch.
     */
    where: OsEntryOsStringMapWhereUniqueInput
  }

  /**
   * OsEntryOsStringMap findUniqueOrThrow
   */
  export type OsEntryOsStringMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryOsStringMap to fetch.
     */
    where: OsEntryOsStringMapWhereUniqueInput
  }

  /**
   * OsEntryOsStringMap findFirst
   */
  export type OsEntryOsStringMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryOsStringMap to fetch.
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryOsStringMaps to fetch.
     */
    orderBy?: OsEntryOsStringMapOrderByWithRelationInput | OsEntryOsStringMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryOsStringMaps.
     */
    cursor?: OsEntryOsStringMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryOsStringMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryOsStringMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryOsStringMaps.
     */
    distinct?: OsEntryOsStringMapScalarFieldEnum | OsEntryOsStringMapScalarFieldEnum[]
  }

  /**
   * OsEntryOsStringMap findFirstOrThrow
   */
  export type OsEntryOsStringMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryOsStringMap to fetch.
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryOsStringMaps to fetch.
     */
    orderBy?: OsEntryOsStringMapOrderByWithRelationInput | OsEntryOsStringMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryOsStringMaps.
     */
    cursor?: OsEntryOsStringMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryOsStringMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryOsStringMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryOsStringMaps.
     */
    distinct?: OsEntryOsStringMapScalarFieldEnum | OsEntryOsStringMapScalarFieldEnum[]
  }

  /**
   * OsEntryOsStringMap findMany
   */
  export type OsEntryOsStringMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryOsStringMaps to fetch.
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryOsStringMaps to fetch.
     */
    orderBy?: OsEntryOsStringMapOrderByWithRelationInput | OsEntryOsStringMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntryOsStringMaps.
     */
    cursor?: OsEntryOsStringMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryOsStringMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryOsStringMaps.
     */
    skip?: number
    distinct?: OsEntryOsStringMapScalarFieldEnum | OsEntryOsStringMapScalarFieldEnum[]
  }

  /**
   * OsEntryOsStringMap create
   */
  export type OsEntryOsStringMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntryOsStringMap.
     */
    data: XOR<OsEntryOsStringMapCreateInput, OsEntryOsStringMapUncheckedCreateInput>
  }

  /**
   * OsEntryOsStringMap createMany
   */
  export type OsEntryOsStringMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntryOsStringMaps.
     */
    data: OsEntryOsStringMapCreateManyInput | OsEntryOsStringMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntryOsStringMap createManyAndReturn
   */
  export type OsEntryOsStringMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntryOsStringMaps.
     */
    data: OsEntryOsStringMapCreateManyInput | OsEntryOsStringMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryOsStringMap update
   */
  export type OsEntryOsStringMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntryOsStringMap.
     */
    data: XOR<OsEntryOsStringMapUpdateInput, OsEntryOsStringMapUncheckedUpdateInput>
    /**
     * Choose, which OsEntryOsStringMap to update.
     */
    where: OsEntryOsStringMapWhereUniqueInput
  }

  /**
   * OsEntryOsStringMap updateMany
   */
  export type OsEntryOsStringMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntryOsStringMaps.
     */
    data: XOR<OsEntryOsStringMapUpdateManyMutationInput, OsEntryOsStringMapUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryOsStringMaps to update
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * Limit how many OsEntryOsStringMaps to update.
     */
    limit?: number
  }

  /**
   * OsEntryOsStringMap updateManyAndReturn
   */
  export type OsEntryOsStringMapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * The data used to update OsEntryOsStringMaps.
     */
    data: XOR<OsEntryOsStringMapUpdateManyMutationInput, OsEntryOsStringMapUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryOsStringMaps to update
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * Limit how many OsEntryOsStringMaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryOsStringMap upsert
   */
  export type OsEntryOsStringMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntryOsStringMap to update in case it exists.
     */
    where: OsEntryOsStringMapWhereUniqueInput
    /**
     * In case the OsEntryOsStringMap found by the `where` argument doesn't exist, create a new OsEntryOsStringMap with this data.
     */
    create: XOR<OsEntryOsStringMapCreateInput, OsEntryOsStringMapUncheckedCreateInput>
    /**
     * In case the OsEntryOsStringMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryOsStringMapUpdateInput, OsEntryOsStringMapUncheckedUpdateInput>
  }

  /**
   * OsEntryOsStringMap delete
   */
  export type OsEntryOsStringMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
    /**
     * Filter which OsEntryOsStringMap to delete.
     */
    where: OsEntryOsStringMapWhereUniqueInput
  }

  /**
   * OsEntryOsStringMap deleteMany
   */
  export type OsEntryOsStringMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryOsStringMaps to delete
     */
    where?: OsEntryOsStringMapWhereInput
    /**
     * Limit how many OsEntryOsStringMaps to delete.
     */
    limit?: number
  }

  /**
   * OsEntryOsStringMap without action
   */
  export type OsEntryOsStringMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryOsStringMap
     */
    select?: OsEntryOsStringMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryOsStringMap
     */
    omit?: OsEntryOsStringMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryOsStringMapInclude<ExtArgs> | null
  }


  /**
   * Model OsEntryPreinstalled
   */

  export type AggregateOsEntryPreinstalled = {
    _count: OsEntryPreinstalledCountAggregateOutputType | null
    _avg: OsEntryPreinstalledAvgAggregateOutputType | null
    _sum: OsEntryPreinstalledSumAggregateOutputType | null
    _min: OsEntryPreinstalledMinAggregateOutputType | null
    _max: OsEntryPreinstalledMaxAggregateOutputType | null
  }

  export type OsEntryPreinstalledAvgAggregateOutputType = {
    os_id: number | null
    device_id: number | null
  }

  export type OsEntryPreinstalledSumAggregateOutputType = {
    os_id: number | null
    device_id: number | null
  }

  export type OsEntryPreinstalledMinAggregateOutputType = {
    os_id: number | null
    device_id: number | null
  }

  export type OsEntryPreinstalledMaxAggregateOutputType = {
    os_id: number | null
    device_id: number | null
  }

  export type OsEntryPreinstalledCountAggregateOutputType = {
    os_id: number
    device_id: number
    _all: number
  }


  export type OsEntryPreinstalledAvgAggregateInputType = {
    os_id?: true
    device_id?: true
  }

  export type OsEntryPreinstalledSumAggregateInputType = {
    os_id?: true
    device_id?: true
  }

  export type OsEntryPreinstalledMinAggregateInputType = {
    os_id?: true
    device_id?: true
  }

  export type OsEntryPreinstalledMaxAggregateInputType = {
    os_id?: true
    device_id?: true
  }

  export type OsEntryPreinstalledCountAggregateInputType = {
    os_id?: true
    device_id?: true
    _all?: true
  }

  export type OsEntryPreinstalledAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryPreinstalled to aggregate.
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryPreinstalleds to fetch.
     */
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryPreinstalledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryPreinstalleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryPreinstalleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntryPreinstalleds
    **/
    _count?: true | OsEntryPreinstalledCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryPreinstalledAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntryPreinstalledSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryPreinstalledMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryPreinstalledMaxAggregateInputType
  }

  export type GetOsEntryPreinstalledAggregateType<T extends OsEntryPreinstalledAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntryPreinstalled]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntryPreinstalled[P]>
      : GetScalarType<T[P], AggregateOsEntryPreinstalled[P]>
  }




  export type OsEntryPreinstalledGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryPreinstalledWhereInput
    orderBy?: OsEntryPreinstalledOrderByWithAggregationInput | OsEntryPreinstalledOrderByWithAggregationInput[]
    by: OsEntryPreinstalledScalarFieldEnum[] | OsEntryPreinstalledScalarFieldEnum
    having?: OsEntryPreinstalledScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryPreinstalledCountAggregateInputType | true
    _avg?: OsEntryPreinstalledAvgAggregateInputType
    _sum?: OsEntryPreinstalledSumAggregateInputType
    _min?: OsEntryPreinstalledMinAggregateInputType
    _max?: OsEntryPreinstalledMaxAggregateInputType
  }

  export type OsEntryPreinstalledGroupByOutputType = {
    os_id: number
    device_id: number
    _count: OsEntryPreinstalledCountAggregateOutputType | null
    _avg: OsEntryPreinstalledAvgAggregateOutputType | null
    _sum: OsEntryPreinstalledSumAggregateOutputType | null
    _min: OsEntryPreinstalledMinAggregateOutputType | null
    _max: OsEntryPreinstalledMaxAggregateOutputType | null
  }

  type GetOsEntryPreinstalledGroupByPayload<T extends OsEntryPreinstalledGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryPreinstalledGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryPreinstalledGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryPreinstalledGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryPreinstalledGroupByOutputType[P]>
        }
      >
    >


  export type OsEntryPreinstalledSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    device_id?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryPreinstalled"]>

  export type OsEntryPreinstalledSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    device_id?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryPreinstalled"]>

  export type OsEntryPreinstalledSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    device_id?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryPreinstalled"]>

  export type OsEntryPreinstalledSelectScalar = {
    os_id?: boolean
    device_id?: boolean
  }

  export type OsEntryPreinstalledOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "device_id", ExtArgs["result"]["osEntryPreinstalled"]>
  export type OsEntryPreinstalledInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryPreinstalledIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryPreinstalledIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntryPreinstalledPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntryPreinstalled"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      device_id: number
    }, ExtArgs["result"]["osEntryPreinstalled"]>
    composites: {}
  }

  type OsEntryPreinstalledGetPayload<S extends boolean | null | undefined | OsEntryPreinstalledDefaultArgs> = $Result.GetResult<Prisma.$OsEntryPreinstalledPayload, S>

  type OsEntryPreinstalledCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryPreinstalledFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryPreinstalledCountAggregateInputType | true
    }

  export interface OsEntryPreinstalledDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntryPreinstalled'], meta: { name: 'OsEntryPreinstalled' } }
    /**
     * Find zero or one OsEntryPreinstalled that matches the filter.
     * @param {OsEntryPreinstalledFindUniqueArgs} args - Arguments to find a OsEntryPreinstalled
     * @example
     * // Get one OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryPreinstalledFindUniqueArgs>(args: SelectSubset<T, OsEntryPreinstalledFindUniqueArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntryPreinstalled that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryPreinstalledFindUniqueOrThrowArgs} args - Arguments to find a OsEntryPreinstalled
     * @example
     * // Get one OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryPreinstalledFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryPreinstalledFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryPreinstalled that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledFindFirstArgs} args - Arguments to find a OsEntryPreinstalled
     * @example
     * // Get one OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryPreinstalledFindFirstArgs>(args?: SelectSubset<T, OsEntryPreinstalledFindFirstArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryPreinstalled that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledFindFirstOrThrowArgs} args - Arguments to find a OsEntryPreinstalled
     * @example
     * // Get one OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryPreinstalledFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryPreinstalledFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntryPreinstalleds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntryPreinstalleds
     * const osEntryPreinstalleds = await prisma.osEntryPreinstalled.findMany()
     * 
     * // Get first 10 OsEntryPreinstalleds
     * const osEntryPreinstalleds = await prisma.osEntryPreinstalled.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntryPreinstalledWithOs_idOnly = await prisma.osEntryPreinstalled.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntryPreinstalledFindManyArgs>(args?: SelectSubset<T, OsEntryPreinstalledFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntryPreinstalled.
     * @param {OsEntryPreinstalledCreateArgs} args - Arguments to create a OsEntryPreinstalled.
     * @example
     * // Create one OsEntryPreinstalled
     * const OsEntryPreinstalled = await prisma.osEntryPreinstalled.create({
     *   data: {
     *     // ... data to create a OsEntryPreinstalled
     *   }
     * })
     * 
     */
    create<T extends OsEntryPreinstalledCreateArgs>(args: SelectSubset<T, OsEntryPreinstalledCreateArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntryPreinstalleds.
     * @param {OsEntryPreinstalledCreateManyArgs} args - Arguments to create many OsEntryPreinstalleds.
     * @example
     * // Create many OsEntryPreinstalleds
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryPreinstalledCreateManyArgs>(args?: SelectSubset<T, OsEntryPreinstalledCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntryPreinstalleds and returns the data saved in the database.
     * @param {OsEntryPreinstalledCreateManyAndReturnArgs} args - Arguments to create many OsEntryPreinstalleds.
     * @example
     * // Create many OsEntryPreinstalleds
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntryPreinstalleds and only return the `os_id`
     * const osEntryPreinstalledWithOs_idOnly = await prisma.osEntryPreinstalled.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryPreinstalledCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryPreinstalledCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntryPreinstalled.
     * @param {OsEntryPreinstalledDeleteArgs} args - Arguments to delete one OsEntryPreinstalled.
     * @example
     * // Delete one OsEntryPreinstalled
     * const OsEntryPreinstalled = await prisma.osEntryPreinstalled.delete({
     *   where: {
     *     // ... filter to delete one OsEntryPreinstalled
     *   }
     * })
     * 
     */
    delete<T extends OsEntryPreinstalledDeleteArgs>(args: SelectSubset<T, OsEntryPreinstalledDeleteArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntryPreinstalled.
     * @param {OsEntryPreinstalledUpdateArgs} args - Arguments to update one OsEntryPreinstalled.
     * @example
     * // Update one OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryPreinstalledUpdateArgs>(args: SelectSubset<T, OsEntryPreinstalledUpdateArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntryPreinstalleds.
     * @param {OsEntryPreinstalledDeleteManyArgs} args - Arguments to filter OsEntryPreinstalleds to delete.
     * @example
     * // Delete a few OsEntryPreinstalleds
     * const { count } = await prisma.osEntryPreinstalled.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryPreinstalledDeleteManyArgs>(args?: SelectSubset<T, OsEntryPreinstalledDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryPreinstalleds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntryPreinstalleds
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryPreinstalledUpdateManyArgs>(args: SelectSubset<T, OsEntryPreinstalledUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryPreinstalleds and returns the data updated in the database.
     * @param {OsEntryPreinstalledUpdateManyAndReturnArgs} args - Arguments to update many OsEntryPreinstalleds.
     * @example
     * // Update many OsEntryPreinstalleds
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntryPreinstalleds and only return the `os_id`
     * const osEntryPreinstalledWithOs_idOnly = await prisma.osEntryPreinstalled.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryPreinstalledUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryPreinstalledUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntryPreinstalled.
     * @param {OsEntryPreinstalledUpsertArgs} args - Arguments to update or create a OsEntryPreinstalled.
     * @example
     * // Update or create a OsEntryPreinstalled
     * const osEntryPreinstalled = await prisma.osEntryPreinstalled.upsert({
     *   create: {
     *     // ... data to create a OsEntryPreinstalled
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntryPreinstalled we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryPreinstalledUpsertArgs>(args: SelectSubset<T, OsEntryPreinstalledUpsertArgs<ExtArgs>>): Prisma__OsEntryPreinstalledClient<$Result.GetResult<Prisma.$OsEntryPreinstalledPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntryPreinstalleds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledCountArgs} args - Arguments to filter OsEntryPreinstalleds to count.
     * @example
     * // Count the number of OsEntryPreinstalleds
     * const count = await prisma.osEntryPreinstalled.count({
     *   where: {
     *     // ... the filter for the OsEntryPreinstalleds we want to count
     *   }
     * })
    **/
    count<T extends OsEntryPreinstalledCountArgs>(
      args?: Subset<T, OsEntryPreinstalledCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryPreinstalledCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntryPreinstalled.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryPreinstalledAggregateArgs>(args: Subset<T, OsEntryPreinstalledAggregateArgs>): Prisma.PrismaPromise<GetOsEntryPreinstalledAggregateType<T>>

    /**
     * Group by OsEntryPreinstalled.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryPreinstalledGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryPreinstalledGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryPreinstalledGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryPreinstalledGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryPreinstalledGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryPreinstalledGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntryPreinstalled model
   */
  readonly fields: OsEntryPreinstalledFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntryPreinstalled.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryPreinstalledClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntryPreinstalled model
   */
  interface OsEntryPreinstalledFieldRefs {
    readonly os_id: FieldRef<"OsEntryPreinstalled", 'Int'>
    readonly device_id: FieldRef<"OsEntryPreinstalled", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OsEntryPreinstalled findUnique
   */
  export type OsEntryPreinstalledFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryPreinstalled to fetch.
     */
    where: OsEntryPreinstalledWhereUniqueInput
  }

  /**
   * OsEntryPreinstalled findUniqueOrThrow
   */
  export type OsEntryPreinstalledFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryPreinstalled to fetch.
     */
    where: OsEntryPreinstalledWhereUniqueInput
  }

  /**
   * OsEntryPreinstalled findFirst
   */
  export type OsEntryPreinstalledFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryPreinstalled to fetch.
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryPreinstalleds to fetch.
     */
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryPreinstalleds.
     */
    cursor?: OsEntryPreinstalledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryPreinstalleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryPreinstalleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryPreinstalleds.
     */
    distinct?: OsEntryPreinstalledScalarFieldEnum | OsEntryPreinstalledScalarFieldEnum[]
  }

  /**
   * OsEntryPreinstalled findFirstOrThrow
   */
  export type OsEntryPreinstalledFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryPreinstalled to fetch.
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryPreinstalleds to fetch.
     */
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryPreinstalleds.
     */
    cursor?: OsEntryPreinstalledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryPreinstalleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryPreinstalleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryPreinstalleds.
     */
    distinct?: OsEntryPreinstalledScalarFieldEnum | OsEntryPreinstalledScalarFieldEnum[]
  }

  /**
   * OsEntryPreinstalled findMany
   */
  export type OsEntryPreinstalledFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryPreinstalleds to fetch.
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryPreinstalleds to fetch.
     */
    orderBy?: OsEntryPreinstalledOrderByWithRelationInput | OsEntryPreinstalledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntryPreinstalleds.
     */
    cursor?: OsEntryPreinstalledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryPreinstalleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryPreinstalleds.
     */
    skip?: number
    distinct?: OsEntryPreinstalledScalarFieldEnum | OsEntryPreinstalledScalarFieldEnum[]
  }

  /**
   * OsEntryPreinstalled create
   */
  export type OsEntryPreinstalledCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntryPreinstalled.
     */
    data: XOR<OsEntryPreinstalledCreateInput, OsEntryPreinstalledUncheckedCreateInput>
  }

  /**
   * OsEntryPreinstalled createMany
   */
  export type OsEntryPreinstalledCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntryPreinstalleds.
     */
    data: OsEntryPreinstalledCreateManyInput | OsEntryPreinstalledCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntryPreinstalled createManyAndReturn
   */
  export type OsEntryPreinstalledCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntryPreinstalleds.
     */
    data: OsEntryPreinstalledCreateManyInput | OsEntryPreinstalledCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryPreinstalled update
   */
  export type OsEntryPreinstalledUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntryPreinstalled.
     */
    data: XOR<OsEntryPreinstalledUpdateInput, OsEntryPreinstalledUncheckedUpdateInput>
    /**
     * Choose, which OsEntryPreinstalled to update.
     */
    where: OsEntryPreinstalledWhereUniqueInput
  }

  /**
   * OsEntryPreinstalled updateMany
   */
  export type OsEntryPreinstalledUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntryPreinstalleds.
     */
    data: XOR<OsEntryPreinstalledUpdateManyMutationInput, OsEntryPreinstalledUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryPreinstalleds to update
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * Limit how many OsEntryPreinstalleds to update.
     */
    limit?: number
  }

  /**
   * OsEntryPreinstalled updateManyAndReturn
   */
  export type OsEntryPreinstalledUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * The data used to update OsEntryPreinstalleds.
     */
    data: XOR<OsEntryPreinstalledUpdateManyMutationInput, OsEntryPreinstalledUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryPreinstalleds to update
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * Limit how many OsEntryPreinstalleds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryPreinstalled upsert
   */
  export type OsEntryPreinstalledUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntryPreinstalled to update in case it exists.
     */
    where: OsEntryPreinstalledWhereUniqueInput
    /**
     * In case the OsEntryPreinstalled found by the `where` argument doesn't exist, create a new OsEntryPreinstalled with this data.
     */
    create: XOR<OsEntryPreinstalledCreateInput, OsEntryPreinstalledUncheckedCreateInput>
    /**
     * In case the OsEntryPreinstalled was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryPreinstalledUpdateInput, OsEntryPreinstalledUncheckedUpdateInput>
  }

  /**
   * OsEntryPreinstalled delete
   */
  export type OsEntryPreinstalledDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
    /**
     * Filter which OsEntryPreinstalled to delete.
     */
    where: OsEntryPreinstalledWhereUniqueInput
  }

  /**
   * OsEntryPreinstalled deleteMany
   */
  export type OsEntryPreinstalledDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryPreinstalleds to delete
     */
    where?: OsEntryPreinstalledWhereInput
    /**
     * Limit how many OsEntryPreinstalleds to delete.
     */
    limit?: number
  }

  /**
   * OsEntryPreinstalled without action
   */
  export type OsEntryPreinstalledDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryPreinstalled
     */
    select?: OsEntryPreinstalledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryPreinstalled
     */
    omit?: OsEntryPreinstalledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryPreinstalledInclude<ExtArgs> | null
  }


  /**
   * Model OsEntryReleaseNote
   */

  export type AggregateOsEntryReleaseNote = {
    _count: OsEntryReleaseNoteCountAggregateOutputType | null
    _avg: OsEntryReleaseNoteAvgAggregateOutputType | null
    _sum: OsEntryReleaseNoteSumAggregateOutputType | null
    _min: OsEntryReleaseNoteMinAggregateOutputType | null
    _max: OsEntryReleaseNoteMaxAggregateOutputType | null
  }

  export type OsEntryReleaseNoteAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryReleaseNoteSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntryReleaseNoteMinAggregateOutputType = {
    os_id: number | null
    url: string | null
    active: boolean | null
  }

  export type OsEntryReleaseNoteMaxAggregateOutputType = {
    os_id: number | null
    url: string | null
    active: boolean | null
  }

  export type OsEntryReleaseNoteCountAggregateOutputType = {
    os_id: number
    url: number
    active: number
    _all: number
  }


  export type OsEntryReleaseNoteAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntryReleaseNoteSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntryReleaseNoteMinAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
  }

  export type OsEntryReleaseNoteMaxAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
  }

  export type OsEntryReleaseNoteCountAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
    _all?: true
  }

  export type OsEntryReleaseNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryReleaseNote to aggregate.
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryReleaseNotes to fetch.
     */
    orderBy?: OsEntryReleaseNoteOrderByWithRelationInput | OsEntryReleaseNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntryReleaseNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryReleaseNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryReleaseNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntryReleaseNotes
    **/
    _count?: true | OsEntryReleaseNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntryReleaseNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntryReleaseNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntryReleaseNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntryReleaseNoteMaxAggregateInputType
  }

  export type GetOsEntryReleaseNoteAggregateType<T extends OsEntryReleaseNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntryReleaseNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntryReleaseNote[P]>
      : GetScalarType<T[P], AggregateOsEntryReleaseNote[P]>
  }




  export type OsEntryReleaseNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntryReleaseNoteWhereInput
    orderBy?: OsEntryReleaseNoteOrderByWithAggregationInput | OsEntryReleaseNoteOrderByWithAggregationInput[]
    by: OsEntryReleaseNoteScalarFieldEnum[] | OsEntryReleaseNoteScalarFieldEnum
    having?: OsEntryReleaseNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntryReleaseNoteCountAggregateInputType | true
    _avg?: OsEntryReleaseNoteAvgAggregateInputType
    _sum?: OsEntryReleaseNoteSumAggregateInputType
    _min?: OsEntryReleaseNoteMinAggregateInputType
    _max?: OsEntryReleaseNoteMaxAggregateInputType
  }

  export type OsEntryReleaseNoteGroupByOutputType = {
    os_id: number
    url: string
    active: boolean | null
    _count: OsEntryReleaseNoteCountAggregateOutputType | null
    _avg: OsEntryReleaseNoteAvgAggregateOutputType | null
    _sum: OsEntryReleaseNoteSumAggregateOutputType | null
    _min: OsEntryReleaseNoteMinAggregateOutputType | null
    _max: OsEntryReleaseNoteMaxAggregateOutputType | null
  }

  type GetOsEntryReleaseNoteGroupByPayload<T extends OsEntryReleaseNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntryReleaseNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntryReleaseNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntryReleaseNoteGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntryReleaseNoteGroupByOutputType[P]>
        }
      >
    >


  export type OsEntryReleaseNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryReleaseNote"]>

  export type OsEntryReleaseNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryReleaseNote"]>

  export type OsEntryReleaseNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntryReleaseNote"]>

  export type OsEntryReleaseNoteSelectScalar = {
    os_id?: boolean
    url?: boolean
    active?: boolean
  }

  export type OsEntryReleaseNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "url" | "active", ExtArgs["result"]["osEntryReleaseNote"]>
  export type OsEntryReleaseNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryReleaseNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntryReleaseNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntryReleaseNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntryReleaseNote"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      url: string
      active: boolean | null
    }, ExtArgs["result"]["osEntryReleaseNote"]>
    composites: {}
  }

  type OsEntryReleaseNoteGetPayload<S extends boolean | null | undefined | OsEntryReleaseNoteDefaultArgs> = $Result.GetResult<Prisma.$OsEntryReleaseNotePayload, S>

  type OsEntryReleaseNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntryReleaseNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntryReleaseNoteCountAggregateInputType | true
    }

  export interface OsEntryReleaseNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntryReleaseNote'], meta: { name: 'OsEntryReleaseNote' } }
    /**
     * Find zero or one OsEntryReleaseNote that matches the filter.
     * @param {OsEntryReleaseNoteFindUniqueArgs} args - Arguments to find a OsEntryReleaseNote
     * @example
     * // Get one OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntryReleaseNoteFindUniqueArgs>(args: SelectSubset<T, OsEntryReleaseNoteFindUniqueArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntryReleaseNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntryReleaseNoteFindUniqueOrThrowArgs} args - Arguments to find a OsEntryReleaseNote
     * @example
     * // Get one OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntryReleaseNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntryReleaseNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryReleaseNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteFindFirstArgs} args - Arguments to find a OsEntryReleaseNote
     * @example
     * // Get one OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntryReleaseNoteFindFirstArgs>(args?: SelectSubset<T, OsEntryReleaseNoteFindFirstArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntryReleaseNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteFindFirstOrThrowArgs} args - Arguments to find a OsEntryReleaseNote
     * @example
     * // Get one OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntryReleaseNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntryReleaseNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntryReleaseNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntryReleaseNotes
     * const osEntryReleaseNotes = await prisma.osEntryReleaseNote.findMany()
     * 
     * // Get first 10 OsEntryReleaseNotes
     * const osEntryReleaseNotes = await prisma.osEntryReleaseNote.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntryReleaseNoteWithOs_idOnly = await prisma.osEntryReleaseNote.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntryReleaseNoteFindManyArgs>(args?: SelectSubset<T, OsEntryReleaseNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntryReleaseNote.
     * @param {OsEntryReleaseNoteCreateArgs} args - Arguments to create a OsEntryReleaseNote.
     * @example
     * // Create one OsEntryReleaseNote
     * const OsEntryReleaseNote = await prisma.osEntryReleaseNote.create({
     *   data: {
     *     // ... data to create a OsEntryReleaseNote
     *   }
     * })
     * 
     */
    create<T extends OsEntryReleaseNoteCreateArgs>(args: SelectSubset<T, OsEntryReleaseNoteCreateArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntryReleaseNotes.
     * @param {OsEntryReleaseNoteCreateManyArgs} args - Arguments to create many OsEntryReleaseNotes.
     * @example
     * // Create many OsEntryReleaseNotes
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntryReleaseNoteCreateManyArgs>(args?: SelectSubset<T, OsEntryReleaseNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntryReleaseNotes and returns the data saved in the database.
     * @param {OsEntryReleaseNoteCreateManyAndReturnArgs} args - Arguments to create many OsEntryReleaseNotes.
     * @example
     * // Create many OsEntryReleaseNotes
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntryReleaseNotes and only return the `os_id`
     * const osEntryReleaseNoteWithOs_idOnly = await prisma.osEntryReleaseNote.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntryReleaseNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntryReleaseNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntryReleaseNote.
     * @param {OsEntryReleaseNoteDeleteArgs} args - Arguments to delete one OsEntryReleaseNote.
     * @example
     * // Delete one OsEntryReleaseNote
     * const OsEntryReleaseNote = await prisma.osEntryReleaseNote.delete({
     *   where: {
     *     // ... filter to delete one OsEntryReleaseNote
     *   }
     * })
     * 
     */
    delete<T extends OsEntryReleaseNoteDeleteArgs>(args: SelectSubset<T, OsEntryReleaseNoteDeleteArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntryReleaseNote.
     * @param {OsEntryReleaseNoteUpdateArgs} args - Arguments to update one OsEntryReleaseNote.
     * @example
     * // Update one OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntryReleaseNoteUpdateArgs>(args: SelectSubset<T, OsEntryReleaseNoteUpdateArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntryReleaseNotes.
     * @param {OsEntryReleaseNoteDeleteManyArgs} args - Arguments to filter OsEntryReleaseNotes to delete.
     * @example
     * // Delete a few OsEntryReleaseNotes
     * const { count } = await prisma.osEntryReleaseNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntryReleaseNoteDeleteManyArgs>(args?: SelectSubset<T, OsEntryReleaseNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryReleaseNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntryReleaseNotes
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntryReleaseNoteUpdateManyArgs>(args: SelectSubset<T, OsEntryReleaseNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntryReleaseNotes and returns the data updated in the database.
     * @param {OsEntryReleaseNoteUpdateManyAndReturnArgs} args - Arguments to update many OsEntryReleaseNotes.
     * @example
     * // Update many OsEntryReleaseNotes
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntryReleaseNotes and only return the `os_id`
     * const osEntryReleaseNoteWithOs_idOnly = await prisma.osEntryReleaseNote.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntryReleaseNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntryReleaseNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntryReleaseNote.
     * @param {OsEntryReleaseNoteUpsertArgs} args - Arguments to update or create a OsEntryReleaseNote.
     * @example
     * // Update or create a OsEntryReleaseNote
     * const osEntryReleaseNote = await prisma.osEntryReleaseNote.upsert({
     *   create: {
     *     // ... data to create a OsEntryReleaseNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntryReleaseNote we want to update
     *   }
     * })
     */
    upsert<T extends OsEntryReleaseNoteUpsertArgs>(args: SelectSubset<T, OsEntryReleaseNoteUpsertArgs<ExtArgs>>): Prisma__OsEntryReleaseNoteClient<$Result.GetResult<Prisma.$OsEntryReleaseNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntryReleaseNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteCountArgs} args - Arguments to filter OsEntryReleaseNotes to count.
     * @example
     * // Count the number of OsEntryReleaseNotes
     * const count = await prisma.osEntryReleaseNote.count({
     *   where: {
     *     // ... the filter for the OsEntryReleaseNotes we want to count
     *   }
     * })
    **/
    count<T extends OsEntryReleaseNoteCountArgs>(
      args?: Subset<T, OsEntryReleaseNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntryReleaseNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntryReleaseNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntryReleaseNoteAggregateArgs>(args: Subset<T, OsEntryReleaseNoteAggregateArgs>): Prisma.PrismaPromise<GetOsEntryReleaseNoteAggregateType<T>>

    /**
     * Group by OsEntryReleaseNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntryReleaseNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntryReleaseNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntryReleaseNoteGroupByArgs['orderBy'] }
        : { orderBy?: OsEntryReleaseNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntryReleaseNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntryReleaseNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntryReleaseNote model
   */
  readonly fields: OsEntryReleaseNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntryReleaseNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntryReleaseNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntryReleaseNote model
   */
  interface OsEntryReleaseNoteFieldRefs {
    readonly os_id: FieldRef<"OsEntryReleaseNote", 'Int'>
    readonly url: FieldRef<"OsEntryReleaseNote", 'String'>
    readonly active: FieldRef<"OsEntryReleaseNote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OsEntryReleaseNote findUnique
   */
  export type OsEntryReleaseNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryReleaseNote to fetch.
     */
    where: OsEntryReleaseNoteWhereUniqueInput
  }

  /**
   * OsEntryReleaseNote findUniqueOrThrow
   */
  export type OsEntryReleaseNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryReleaseNote to fetch.
     */
    where: OsEntryReleaseNoteWhereUniqueInput
  }

  /**
   * OsEntryReleaseNote findFirst
   */
  export type OsEntryReleaseNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryReleaseNote to fetch.
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryReleaseNotes to fetch.
     */
    orderBy?: OsEntryReleaseNoteOrderByWithRelationInput | OsEntryReleaseNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryReleaseNotes.
     */
    cursor?: OsEntryReleaseNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryReleaseNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryReleaseNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryReleaseNotes.
     */
    distinct?: OsEntryReleaseNoteScalarFieldEnum | OsEntryReleaseNoteScalarFieldEnum[]
  }

  /**
   * OsEntryReleaseNote findFirstOrThrow
   */
  export type OsEntryReleaseNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryReleaseNote to fetch.
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryReleaseNotes to fetch.
     */
    orderBy?: OsEntryReleaseNoteOrderByWithRelationInput | OsEntryReleaseNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntryReleaseNotes.
     */
    cursor?: OsEntryReleaseNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryReleaseNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryReleaseNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntryReleaseNotes.
     */
    distinct?: OsEntryReleaseNoteScalarFieldEnum | OsEntryReleaseNoteScalarFieldEnum[]
  }

  /**
   * OsEntryReleaseNote findMany
   */
  export type OsEntryReleaseNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntryReleaseNotes to fetch.
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntryReleaseNotes to fetch.
     */
    orderBy?: OsEntryReleaseNoteOrderByWithRelationInput | OsEntryReleaseNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntryReleaseNotes.
     */
    cursor?: OsEntryReleaseNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntryReleaseNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntryReleaseNotes.
     */
    skip?: number
    distinct?: OsEntryReleaseNoteScalarFieldEnum | OsEntryReleaseNoteScalarFieldEnum[]
  }

  /**
   * OsEntryReleaseNote create
   */
  export type OsEntryReleaseNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntryReleaseNote.
     */
    data: XOR<OsEntryReleaseNoteCreateInput, OsEntryReleaseNoteUncheckedCreateInput>
  }

  /**
   * OsEntryReleaseNote createMany
   */
  export type OsEntryReleaseNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntryReleaseNotes.
     */
    data: OsEntryReleaseNoteCreateManyInput | OsEntryReleaseNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntryReleaseNote createManyAndReturn
   */
  export type OsEntryReleaseNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntryReleaseNotes.
     */
    data: OsEntryReleaseNoteCreateManyInput | OsEntryReleaseNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryReleaseNote update
   */
  export type OsEntryReleaseNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntryReleaseNote.
     */
    data: XOR<OsEntryReleaseNoteUpdateInput, OsEntryReleaseNoteUncheckedUpdateInput>
    /**
     * Choose, which OsEntryReleaseNote to update.
     */
    where: OsEntryReleaseNoteWhereUniqueInput
  }

  /**
   * OsEntryReleaseNote updateMany
   */
  export type OsEntryReleaseNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntryReleaseNotes.
     */
    data: XOR<OsEntryReleaseNoteUpdateManyMutationInput, OsEntryReleaseNoteUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryReleaseNotes to update
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * Limit how many OsEntryReleaseNotes to update.
     */
    limit?: number
  }

  /**
   * OsEntryReleaseNote updateManyAndReturn
   */
  export type OsEntryReleaseNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * The data used to update OsEntryReleaseNotes.
     */
    data: XOR<OsEntryReleaseNoteUpdateManyMutationInput, OsEntryReleaseNoteUncheckedUpdateManyInput>
    /**
     * Filter which OsEntryReleaseNotes to update
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * Limit how many OsEntryReleaseNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntryReleaseNote upsert
   */
  export type OsEntryReleaseNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntryReleaseNote to update in case it exists.
     */
    where: OsEntryReleaseNoteWhereUniqueInput
    /**
     * In case the OsEntryReleaseNote found by the `where` argument doesn't exist, create a new OsEntryReleaseNote with this data.
     */
    create: XOR<OsEntryReleaseNoteCreateInput, OsEntryReleaseNoteUncheckedCreateInput>
    /**
     * In case the OsEntryReleaseNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntryReleaseNoteUpdateInput, OsEntryReleaseNoteUncheckedUpdateInput>
  }

  /**
   * OsEntryReleaseNote delete
   */
  export type OsEntryReleaseNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
    /**
     * Filter which OsEntryReleaseNote to delete.
     */
    where: OsEntryReleaseNoteWhereUniqueInput
  }

  /**
   * OsEntryReleaseNote deleteMany
   */
  export type OsEntryReleaseNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntryReleaseNotes to delete
     */
    where?: OsEntryReleaseNoteWhereInput
    /**
     * Limit how many OsEntryReleaseNotes to delete.
     */
    limit?: number
  }

  /**
   * OsEntryReleaseNote without action
   */
  export type OsEntryReleaseNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntryReleaseNote
     */
    select?: OsEntryReleaseNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntryReleaseNote
     */
    omit?: OsEntryReleaseNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryReleaseNoteInclude<ExtArgs> | null
  }


  /**
   * Model OsEntrySafariVersion
   */

  export type AggregateOsEntrySafariVersion = {
    _count: OsEntrySafariVersionCountAggregateOutputType | null
    _avg: OsEntrySafariVersionAvgAggregateOutputType | null
    _sum: OsEntrySafariVersionSumAggregateOutputType | null
    _min: OsEntrySafariVersionMinAggregateOutputType | null
    _max: OsEntrySafariVersionMaxAggregateOutputType | null
  }

  export type OsEntrySafariVersionAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntrySafariVersionSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntrySafariVersionMinAggregateOutputType = {
    os_id: number | null
    version: string | null
  }

  export type OsEntrySafariVersionMaxAggregateOutputType = {
    os_id: number | null
    version: string | null
  }

  export type OsEntrySafariVersionCountAggregateOutputType = {
    os_id: number
    version: number
    _all: number
  }


  export type OsEntrySafariVersionAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntrySafariVersionSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntrySafariVersionMinAggregateInputType = {
    os_id?: true
    version?: true
  }

  export type OsEntrySafariVersionMaxAggregateInputType = {
    os_id?: true
    version?: true
  }

  export type OsEntrySafariVersionCountAggregateInputType = {
    os_id?: true
    version?: true
    _all?: true
  }

  export type OsEntrySafariVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntrySafariVersion to aggregate.
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySafariVersions to fetch.
     */
    orderBy?: OsEntrySafariVersionOrderByWithRelationInput | OsEntrySafariVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntrySafariVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySafariVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySafariVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntrySafariVersions
    **/
    _count?: true | OsEntrySafariVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntrySafariVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntrySafariVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntrySafariVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntrySafariVersionMaxAggregateInputType
  }

  export type GetOsEntrySafariVersionAggregateType<T extends OsEntrySafariVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntrySafariVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntrySafariVersion[P]>
      : GetScalarType<T[P], AggregateOsEntrySafariVersion[P]>
  }




  export type OsEntrySafariVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntrySafariVersionWhereInput
    orderBy?: OsEntrySafariVersionOrderByWithAggregationInput | OsEntrySafariVersionOrderByWithAggregationInput[]
    by: OsEntrySafariVersionScalarFieldEnum[] | OsEntrySafariVersionScalarFieldEnum
    having?: OsEntrySafariVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntrySafariVersionCountAggregateInputType | true
    _avg?: OsEntrySafariVersionAvgAggregateInputType
    _sum?: OsEntrySafariVersionSumAggregateInputType
    _min?: OsEntrySafariVersionMinAggregateInputType
    _max?: OsEntrySafariVersionMaxAggregateInputType
  }

  export type OsEntrySafariVersionGroupByOutputType = {
    os_id: number
    version: string
    _count: OsEntrySafariVersionCountAggregateOutputType | null
    _avg: OsEntrySafariVersionAvgAggregateOutputType | null
    _sum: OsEntrySafariVersionSumAggregateOutputType | null
    _min: OsEntrySafariVersionMinAggregateOutputType | null
    _max: OsEntrySafariVersionMaxAggregateOutputType | null
  }

  type GetOsEntrySafariVersionGroupByPayload<T extends OsEntrySafariVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntrySafariVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntrySafariVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntrySafariVersionGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntrySafariVersionGroupByOutputType[P]>
        }
      >
    >


  export type OsEntrySafariVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    version?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySafariVersion"]>

  export type OsEntrySafariVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    version?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySafariVersion"]>

  export type OsEntrySafariVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    version?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySafariVersion"]>

  export type OsEntrySafariVersionSelectScalar = {
    os_id?: boolean
    version?: boolean
  }

  export type OsEntrySafariVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "version", ExtArgs["result"]["osEntrySafariVersion"]>
  export type OsEntrySafariVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntrySafariVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntrySafariVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntrySafariVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntrySafariVersion"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      version: string
    }, ExtArgs["result"]["osEntrySafariVersion"]>
    composites: {}
  }

  type OsEntrySafariVersionGetPayload<S extends boolean | null | undefined | OsEntrySafariVersionDefaultArgs> = $Result.GetResult<Prisma.$OsEntrySafariVersionPayload, S>

  type OsEntrySafariVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntrySafariVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntrySafariVersionCountAggregateInputType | true
    }

  export interface OsEntrySafariVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntrySafariVersion'], meta: { name: 'OsEntrySafariVersion' } }
    /**
     * Find zero or one OsEntrySafariVersion that matches the filter.
     * @param {OsEntrySafariVersionFindUniqueArgs} args - Arguments to find a OsEntrySafariVersion
     * @example
     * // Get one OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntrySafariVersionFindUniqueArgs>(args: SelectSubset<T, OsEntrySafariVersionFindUniqueArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntrySafariVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntrySafariVersionFindUniqueOrThrowArgs} args - Arguments to find a OsEntrySafariVersion
     * @example
     * // Get one OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntrySafariVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntrySafariVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntrySafariVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionFindFirstArgs} args - Arguments to find a OsEntrySafariVersion
     * @example
     * // Get one OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntrySafariVersionFindFirstArgs>(args?: SelectSubset<T, OsEntrySafariVersionFindFirstArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntrySafariVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionFindFirstOrThrowArgs} args - Arguments to find a OsEntrySafariVersion
     * @example
     * // Get one OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntrySafariVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntrySafariVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntrySafariVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntrySafariVersions
     * const osEntrySafariVersions = await prisma.osEntrySafariVersion.findMany()
     * 
     * // Get first 10 OsEntrySafariVersions
     * const osEntrySafariVersions = await prisma.osEntrySafariVersion.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntrySafariVersionWithOs_idOnly = await prisma.osEntrySafariVersion.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntrySafariVersionFindManyArgs>(args?: SelectSubset<T, OsEntrySafariVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntrySafariVersion.
     * @param {OsEntrySafariVersionCreateArgs} args - Arguments to create a OsEntrySafariVersion.
     * @example
     * // Create one OsEntrySafariVersion
     * const OsEntrySafariVersion = await prisma.osEntrySafariVersion.create({
     *   data: {
     *     // ... data to create a OsEntrySafariVersion
     *   }
     * })
     * 
     */
    create<T extends OsEntrySafariVersionCreateArgs>(args: SelectSubset<T, OsEntrySafariVersionCreateArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntrySafariVersions.
     * @param {OsEntrySafariVersionCreateManyArgs} args - Arguments to create many OsEntrySafariVersions.
     * @example
     * // Create many OsEntrySafariVersions
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntrySafariVersionCreateManyArgs>(args?: SelectSubset<T, OsEntrySafariVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntrySafariVersions and returns the data saved in the database.
     * @param {OsEntrySafariVersionCreateManyAndReturnArgs} args - Arguments to create many OsEntrySafariVersions.
     * @example
     * // Create many OsEntrySafariVersions
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntrySafariVersions and only return the `os_id`
     * const osEntrySafariVersionWithOs_idOnly = await prisma.osEntrySafariVersion.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntrySafariVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntrySafariVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntrySafariVersion.
     * @param {OsEntrySafariVersionDeleteArgs} args - Arguments to delete one OsEntrySafariVersion.
     * @example
     * // Delete one OsEntrySafariVersion
     * const OsEntrySafariVersion = await prisma.osEntrySafariVersion.delete({
     *   where: {
     *     // ... filter to delete one OsEntrySafariVersion
     *   }
     * })
     * 
     */
    delete<T extends OsEntrySafariVersionDeleteArgs>(args: SelectSubset<T, OsEntrySafariVersionDeleteArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntrySafariVersion.
     * @param {OsEntrySafariVersionUpdateArgs} args - Arguments to update one OsEntrySafariVersion.
     * @example
     * // Update one OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntrySafariVersionUpdateArgs>(args: SelectSubset<T, OsEntrySafariVersionUpdateArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntrySafariVersions.
     * @param {OsEntrySafariVersionDeleteManyArgs} args - Arguments to filter OsEntrySafariVersions to delete.
     * @example
     * // Delete a few OsEntrySafariVersions
     * const { count } = await prisma.osEntrySafariVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntrySafariVersionDeleteManyArgs>(args?: SelectSubset<T, OsEntrySafariVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntrySafariVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntrySafariVersions
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntrySafariVersionUpdateManyArgs>(args: SelectSubset<T, OsEntrySafariVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntrySafariVersions and returns the data updated in the database.
     * @param {OsEntrySafariVersionUpdateManyAndReturnArgs} args - Arguments to update many OsEntrySafariVersions.
     * @example
     * // Update many OsEntrySafariVersions
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntrySafariVersions and only return the `os_id`
     * const osEntrySafariVersionWithOs_idOnly = await prisma.osEntrySafariVersion.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntrySafariVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntrySafariVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntrySafariVersion.
     * @param {OsEntrySafariVersionUpsertArgs} args - Arguments to update or create a OsEntrySafariVersion.
     * @example
     * // Update or create a OsEntrySafariVersion
     * const osEntrySafariVersion = await prisma.osEntrySafariVersion.upsert({
     *   create: {
     *     // ... data to create a OsEntrySafariVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntrySafariVersion we want to update
     *   }
     * })
     */
    upsert<T extends OsEntrySafariVersionUpsertArgs>(args: SelectSubset<T, OsEntrySafariVersionUpsertArgs<ExtArgs>>): Prisma__OsEntrySafariVersionClient<$Result.GetResult<Prisma.$OsEntrySafariVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntrySafariVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionCountArgs} args - Arguments to filter OsEntrySafariVersions to count.
     * @example
     * // Count the number of OsEntrySafariVersions
     * const count = await prisma.osEntrySafariVersion.count({
     *   where: {
     *     // ... the filter for the OsEntrySafariVersions we want to count
     *   }
     * })
    **/
    count<T extends OsEntrySafariVersionCountArgs>(
      args?: Subset<T, OsEntrySafariVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntrySafariVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntrySafariVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntrySafariVersionAggregateArgs>(args: Subset<T, OsEntrySafariVersionAggregateArgs>): Prisma.PrismaPromise<GetOsEntrySafariVersionAggregateType<T>>

    /**
     * Group by OsEntrySafariVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySafariVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntrySafariVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntrySafariVersionGroupByArgs['orderBy'] }
        : { orderBy?: OsEntrySafariVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntrySafariVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntrySafariVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntrySafariVersion model
   */
  readonly fields: OsEntrySafariVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntrySafariVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntrySafariVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntrySafariVersion model
   */
  interface OsEntrySafariVersionFieldRefs {
    readonly os_id: FieldRef<"OsEntrySafariVersion", 'Int'>
    readonly version: FieldRef<"OsEntrySafariVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OsEntrySafariVersion findUnique
   */
  export type OsEntrySafariVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySafariVersion to fetch.
     */
    where: OsEntrySafariVersionWhereUniqueInput
  }

  /**
   * OsEntrySafariVersion findUniqueOrThrow
   */
  export type OsEntrySafariVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySafariVersion to fetch.
     */
    where: OsEntrySafariVersionWhereUniqueInput
  }

  /**
   * OsEntrySafariVersion findFirst
   */
  export type OsEntrySafariVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySafariVersion to fetch.
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySafariVersions to fetch.
     */
    orderBy?: OsEntrySafariVersionOrderByWithRelationInput | OsEntrySafariVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntrySafariVersions.
     */
    cursor?: OsEntrySafariVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySafariVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySafariVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntrySafariVersions.
     */
    distinct?: OsEntrySafariVersionScalarFieldEnum | OsEntrySafariVersionScalarFieldEnum[]
  }

  /**
   * OsEntrySafariVersion findFirstOrThrow
   */
  export type OsEntrySafariVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySafariVersion to fetch.
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySafariVersions to fetch.
     */
    orderBy?: OsEntrySafariVersionOrderByWithRelationInput | OsEntrySafariVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntrySafariVersions.
     */
    cursor?: OsEntrySafariVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySafariVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySafariVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntrySafariVersions.
     */
    distinct?: OsEntrySafariVersionScalarFieldEnum | OsEntrySafariVersionScalarFieldEnum[]
  }

  /**
   * OsEntrySafariVersion findMany
   */
  export type OsEntrySafariVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySafariVersions to fetch.
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySafariVersions to fetch.
     */
    orderBy?: OsEntrySafariVersionOrderByWithRelationInput | OsEntrySafariVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntrySafariVersions.
     */
    cursor?: OsEntrySafariVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySafariVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySafariVersions.
     */
    skip?: number
    distinct?: OsEntrySafariVersionScalarFieldEnum | OsEntrySafariVersionScalarFieldEnum[]
  }

  /**
   * OsEntrySafariVersion create
   */
  export type OsEntrySafariVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntrySafariVersion.
     */
    data: XOR<OsEntrySafariVersionCreateInput, OsEntrySafariVersionUncheckedCreateInput>
  }

  /**
   * OsEntrySafariVersion createMany
   */
  export type OsEntrySafariVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntrySafariVersions.
     */
    data: OsEntrySafariVersionCreateManyInput | OsEntrySafariVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntrySafariVersion createManyAndReturn
   */
  export type OsEntrySafariVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntrySafariVersions.
     */
    data: OsEntrySafariVersionCreateManyInput | OsEntrySafariVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntrySafariVersion update
   */
  export type OsEntrySafariVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntrySafariVersion.
     */
    data: XOR<OsEntrySafariVersionUpdateInput, OsEntrySafariVersionUncheckedUpdateInput>
    /**
     * Choose, which OsEntrySafariVersion to update.
     */
    where: OsEntrySafariVersionWhereUniqueInput
  }

  /**
   * OsEntrySafariVersion updateMany
   */
  export type OsEntrySafariVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntrySafariVersions.
     */
    data: XOR<OsEntrySafariVersionUpdateManyMutationInput, OsEntrySafariVersionUncheckedUpdateManyInput>
    /**
     * Filter which OsEntrySafariVersions to update
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * Limit how many OsEntrySafariVersions to update.
     */
    limit?: number
  }

  /**
   * OsEntrySafariVersion updateManyAndReturn
   */
  export type OsEntrySafariVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * The data used to update OsEntrySafariVersions.
     */
    data: XOR<OsEntrySafariVersionUpdateManyMutationInput, OsEntrySafariVersionUncheckedUpdateManyInput>
    /**
     * Filter which OsEntrySafariVersions to update
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * Limit how many OsEntrySafariVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntrySafariVersion upsert
   */
  export type OsEntrySafariVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntrySafariVersion to update in case it exists.
     */
    where: OsEntrySafariVersionWhereUniqueInput
    /**
     * In case the OsEntrySafariVersion found by the `where` argument doesn't exist, create a new OsEntrySafariVersion with this data.
     */
    create: XOR<OsEntrySafariVersionCreateInput, OsEntrySafariVersionUncheckedCreateInput>
    /**
     * In case the OsEntrySafariVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntrySafariVersionUpdateInput, OsEntrySafariVersionUncheckedUpdateInput>
  }

  /**
   * OsEntrySafariVersion delete
   */
  export type OsEntrySafariVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
    /**
     * Filter which OsEntrySafariVersion to delete.
     */
    where: OsEntrySafariVersionWhereUniqueInput
  }

  /**
   * OsEntrySafariVersion deleteMany
   */
  export type OsEntrySafariVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntrySafariVersions to delete
     */
    where?: OsEntrySafariVersionWhereInput
    /**
     * Limit how many OsEntrySafariVersions to delete.
     */
    limit?: number
  }

  /**
   * OsEntrySafariVersion without action
   */
  export type OsEntrySafariVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySafariVersion
     */
    select?: OsEntrySafariVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySafariVersion
     */
    omit?: OsEntrySafariVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySafariVersionInclude<ExtArgs> | null
  }


  /**
   * Model OsEntrySecurityNote
   */

  export type AggregateOsEntrySecurityNote = {
    _count: OsEntrySecurityNoteCountAggregateOutputType | null
    _avg: OsEntrySecurityNoteAvgAggregateOutputType | null
    _sum: OsEntrySecurityNoteSumAggregateOutputType | null
    _min: OsEntrySecurityNoteMinAggregateOutputType | null
    _max: OsEntrySecurityNoteMaxAggregateOutputType | null
  }

  export type OsEntrySecurityNoteAvgAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntrySecurityNoteSumAggregateOutputType = {
    os_id: number | null
  }

  export type OsEntrySecurityNoteMinAggregateOutputType = {
    os_id: number | null
    url: string | null
    active: boolean | null
  }

  export type OsEntrySecurityNoteMaxAggregateOutputType = {
    os_id: number | null
    url: string | null
    active: boolean | null
  }

  export type OsEntrySecurityNoteCountAggregateOutputType = {
    os_id: number
    url: number
    active: number
    _all: number
  }


  export type OsEntrySecurityNoteAvgAggregateInputType = {
    os_id?: true
  }

  export type OsEntrySecurityNoteSumAggregateInputType = {
    os_id?: true
  }

  export type OsEntrySecurityNoteMinAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
  }

  export type OsEntrySecurityNoteMaxAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
  }

  export type OsEntrySecurityNoteCountAggregateInputType = {
    os_id?: true
    url?: true
    active?: true
    _all?: true
  }

  export type OsEntrySecurityNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntrySecurityNote to aggregate.
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySecurityNotes to fetch.
     */
    orderBy?: OsEntrySecurityNoteOrderByWithRelationInput | OsEntrySecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsEntrySecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsEntrySecurityNotes
    **/
    _count?: true | OsEntrySecurityNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsEntrySecurityNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsEntrySecurityNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsEntrySecurityNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsEntrySecurityNoteMaxAggregateInputType
  }

  export type GetOsEntrySecurityNoteAggregateType<T extends OsEntrySecurityNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateOsEntrySecurityNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsEntrySecurityNote[P]>
      : GetScalarType<T[P], AggregateOsEntrySecurityNote[P]>
  }




  export type OsEntrySecurityNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsEntrySecurityNoteWhereInput
    orderBy?: OsEntrySecurityNoteOrderByWithAggregationInput | OsEntrySecurityNoteOrderByWithAggregationInput[]
    by: OsEntrySecurityNoteScalarFieldEnum[] | OsEntrySecurityNoteScalarFieldEnum
    having?: OsEntrySecurityNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsEntrySecurityNoteCountAggregateInputType | true
    _avg?: OsEntrySecurityNoteAvgAggregateInputType
    _sum?: OsEntrySecurityNoteSumAggregateInputType
    _min?: OsEntrySecurityNoteMinAggregateInputType
    _max?: OsEntrySecurityNoteMaxAggregateInputType
  }

  export type OsEntrySecurityNoteGroupByOutputType = {
    os_id: number
    url: string
    active: boolean | null
    _count: OsEntrySecurityNoteCountAggregateOutputType | null
    _avg: OsEntrySecurityNoteAvgAggregateOutputType | null
    _sum: OsEntrySecurityNoteSumAggregateOutputType | null
    _min: OsEntrySecurityNoteMinAggregateOutputType | null
    _max: OsEntrySecurityNoteMaxAggregateOutputType | null
  }

  type GetOsEntrySecurityNoteGroupByPayload<T extends OsEntrySecurityNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsEntrySecurityNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsEntrySecurityNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsEntrySecurityNoteGroupByOutputType[P]>
            : GetScalarType<T[P], OsEntrySecurityNoteGroupByOutputType[P]>
        }
      >
    >


  export type OsEntrySecurityNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySecurityNote"]>

  export type OsEntrySecurityNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySecurityNote"]>

  export type OsEntrySecurityNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    os_id?: boolean
    url?: boolean
    active?: boolean
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osEntrySecurityNote"]>

  export type OsEntrySecurityNoteSelectScalar = {
    os_id?: boolean
    url?: boolean
    active?: boolean
  }

  export type OsEntrySecurityNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"os_id" | "url" | "active", ExtArgs["result"]["osEntrySecurityNote"]>
  export type OsEntrySecurityNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntrySecurityNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }
  export type OsEntrySecurityNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsEntryDefaultArgs<ExtArgs>
  }

  export type $OsEntrySecurityNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsEntrySecurityNote"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      os_id: number
      url: string
      active: boolean | null
    }, ExtArgs["result"]["osEntrySecurityNote"]>
    composites: {}
  }

  type OsEntrySecurityNoteGetPayload<S extends boolean | null | undefined | OsEntrySecurityNoteDefaultArgs> = $Result.GetResult<Prisma.$OsEntrySecurityNotePayload, S>

  type OsEntrySecurityNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsEntrySecurityNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsEntrySecurityNoteCountAggregateInputType | true
    }

  export interface OsEntrySecurityNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsEntrySecurityNote'], meta: { name: 'OsEntrySecurityNote' } }
    /**
     * Find zero or one OsEntrySecurityNote that matches the filter.
     * @param {OsEntrySecurityNoteFindUniqueArgs} args - Arguments to find a OsEntrySecurityNote
     * @example
     * // Get one OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsEntrySecurityNoteFindUniqueArgs>(args: SelectSubset<T, OsEntrySecurityNoteFindUniqueArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsEntrySecurityNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsEntrySecurityNoteFindUniqueOrThrowArgs} args - Arguments to find a OsEntrySecurityNote
     * @example
     * // Get one OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsEntrySecurityNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, OsEntrySecurityNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntrySecurityNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteFindFirstArgs} args - Arguments to find a OsEntrySecurityNote
     * @example
     * // Get one OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsEntrySecurityNoteFindFirstArgs>(args?: SelectSubset<T, OsEntrySecurityNoteFindFirstArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsEntrySecurityNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteFindFirstOrThrowArgs} args - Arguments to find a OsEntrySecurityNote
     * @example
     * // Get one OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsEntrySecurityNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, OsEntrySecurityNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsEntrySecurityNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsEntrySecurityNotes
     * const osEntrySecurityNotes = await prisma.osEntrySecurityNote.findMany()
     * 
     * // Get first 10 OsEntrySecurityNotes
     * const osEntrySecurityNotes = await prisma.osEntrySecurityNote.findMany({ take: 10 })
     * 
     * // Only select the `os_id`
     * const osEntrySecurityNoteWithOs_idOnly = await prisma.osEntrySecurityNote.findMany({ select: { os_id: true } })
     * 
     */
    findMany<T extends OsEntrySecurityNoteFindManyArgs>(args?: SelectSubset<T, OsEntrySecurityNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsEntrySecurityNote.
     * @param {OsEntrySecurityNoteCreateArgs} args - Arguments to create a OsEntrySecurityNote.
     * @example
     * // Create one OsEntrySecurityNote
     * const OsEntrySecurityNote = await prisma.osEntrySecurityNote.create({
     *   data: {
     *     // ... data to create a OsEntrySecurityNote
     *   }
     * })
     * 
     */
    create<T extends OsEntrySecurityNoteCreateArgs>(args: SelectSubset<T, OsEntrySecurityNoteCreateArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsEntrySecurityNotes.
     * @param {OsEntrySecurityNoteCreateManyArgs} args - Arguments to create many OsEntrySecurityNotes.
     * @example
     * // Create many OsEntrySecurityNotes
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsEntrySecurityNoteCreateManyArgs>(args?: SelectSubset<T, OsEntrySecurityNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsEntrySecurityNotes and returns the data saved in the database.
     * @param {OsEntrySecurityNoteCreateManyAndReturnArgs} args - Arguments to create many OsEntrySecurityNotes.
     * @example
     * // Create many OsEntrySecurityNotes
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsEntrySecurityNotes and only return the `os_id`
     * const osEntrySecurityNoteWithOs_idOnly = await prisma.osEntrySecurityNote.createManyAndReturn({
     *   select: { os_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsEntrySecurityNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, OsEntrySecurityNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsEntrySecurityNote.
     * @param {OsEntrySecurityNoteDeleteArgs} args - Arguments to delete one OsEntrySecurityNote.
     * @example
     * // Delete one OsEntrySecurityNote
     * const OsEntrySecurityNote = await prisma.osEntrySecurityNote.delete({
     *   where: {
     *     // ... filter to delete one OsEntrySecurityNote
     *   }
     * })
     * 
     */
    delete<T extends OsEntrySecurityNoteDeleteArgs>(args: SelectSubset<T, OsEntrySecurityNoteDeleteArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsEntrySecurityNote.
     * @param {OsEntrySecurityNoteUpdateArgs} args - Arguments to update one OsEntrySecurityNote.
     * @example
     * // Update one OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsEntrySecurityNoteUpdateArgs>(args: SelectSubset<T, OsEntrySecurityNoteUpdateArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsEntrySecurityNotes.
     * @param {OsEntrySecurityNoteDeleteManyArgs} args - Arguments to filter OsEntrySecurityNotes to delete.
     * @example
     * // Delete a few OsEntrySecurityNotes
     * const { count } = await prisma.osEntrySecurityNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsEntrySecurityNoteDeleteManyArgs>(args?: SelectSubset<T, OsEntrySecurityNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntrySecurityNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsEntrySecurityNotes
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsEntrySecurityNoteUpdateManyArgs>(args: SelectSubset<T, OsEntrySecurityNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsEntrySecurityNotes and returns the data updated in the database.
     * @param {OsEntrySecurityNoteUpdateManyAndReturnArgs} args - Arguments to update many OsEntrySecurityNotes.
     * @example
     * // Update many OsEntrySecurityNotes
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsEntrySecurityNotes and only return the `os_id`
     * const osEntrySecurityNoteWithOs_idOnly = await prisma.osEntrySecurityNote.updateManyAndReturn({
     *   select: { os_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsEntrySecurityNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, OsEntrySecurityNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsEntrySecurityNote.
     * @param {OsEntrySecurityNoteUpsertArgs} args - Arguments to update or create a OsEntrySecurityNote.
     * @example
     * // Update or create a OsEntrySecurityNote
     * const osEntrySecurityNote = await prisma.osEntrySecurityNote.upsert({
     *   create: {
     *     // ... data to create a OsEntrySecurityNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsEntrySecurityNote we want to update
     *   }
     * })
     */
    upsert<T extends OsEntrySecurityNoteUpsertArgs>(args: SelectSubset<T, OsEntrySecurityNoteUpsertArgs<ExtArgs>>): Prisma__OsEntrySecurityNoteClient<$Result.GetResult<Prisma.$OsEntrySecurityNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsEntrySecurityNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteCountArgs} args - Arguments to filter OsEntrySecurityNotes to count.
     * @example
     * // Count the number of OsEntrySecurityNotes
     * const count = await prisma.osEntrySecurityNote.count({
     *   where: {
     *     // ... the filter for the OsEntrySecurityNotes we want to count
     *   }
     * })
    **/
    count<T extends OsEntrySecurityNoteCountArgs>(
      args?: Subset<T, OsEntrySecurityNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsEntrySecurityNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsEntrySecurityNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsEntrySecurityNoteAggregateArgs>(args: Subset<T, OsEntrySecurityNoteAggregateArgs>): Prisma.PrismaPromise<GetOsEntrySecurityNoteAggregateType<T>>

    /**
     * Group by OsEntrySecurityNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsEntrySecurityNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsEntrySecurityNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsEntrySecurityNoteGroupByArgs['orderBy'] }
        : { orderBy?: OsEntrySecurityNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsEntrySecurityNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsEntrySecurityNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsEntrySecurityNote model
   */
  readonly fields: OsEntrySecurityNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsEntrySecurityNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsEntrySecurityNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OsEntryDefaultArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsEntrySecurityNote model
   */
  interface OsEntrySecurityNoteFieldRefs {
    readonly os_id: FieldRef<"OsEntrySecurityNote", 'Int'>
    readonly url: FieldRef<"OsEntrySecurityNote", 'String'>
    readonly active: FieldRef<"OsEntrySecurityNote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OsEntrySecurityNote findUnique
   */
  export type OsEntrySecurityNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySecurityNote to fetch.
     */
    where: OsEntrySecurityNoteWhereUniqueInput
  }

  /**
   * OsEntrySecurityNote findUniqueOrThrow
   */
  export type OsEntrySecurityNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySecurityNote to fetch.
     */
    where: OsEntrySecurityNoteWhereUniqueInput
  }

  /**
   * OsEntrySecurityNote findFirst
   */
  export type OsEntrySecurityNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySecurityNote to fetch.
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySecurityNotes to fetch.
     */
    orderBy?: OsEntrySecurityNoteOrderByWithRelationInput | OsEntrySecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntrySecurityNotes.
     */
    cursor?: OsEntrySecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntrySecurityNotes.
     */
    distinct?: OsEntrySecurityNoteScalarFieldEnum | OsEntrySecurityNoteScalarFieldEnum[]
  }

  /**
   * OsEntrySecurityNote findFirstOrThrow
   */
  export type OsEntrySecurityNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySecurityNote to fetch.
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySecurityNotes to fetch.
     */
    orderBy?: OsEntrySecurityNoteOrderByWithRelationInput | OsEntrySecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsEntrySecurityNotes.
     */
    cursor?: OsEntrySecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySecurityNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsEntrySecurityNotes.
     */
    distinct?: OsEntrySecurityNoteScalarFieldEnum | OsEntrySecurityNoteScalarFieldEnum[]
  }

  /**
   * OsEntrySecurityNote findMany
   */
  export type OsEntrySecurityNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter, which OsEntrySecurityNotes to fetch.
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsEntrySecurityNotes to fetch.
     */
    orderBy?: OsEntrySecurityNoteOrderByWithRelationInput | OsEntrySecurityNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsEntrySecurityNotes.
     */
    cursor?: OsEntrySecurityNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsEntrySecurityNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsEntrySecurityNotes.
     */
    skip?: number
    distinct?: OsEntrySecurityNoteScalarFieldEnum | OsEntrySecurityNoteScalarFieldEnum[]
  }

  /**
   * OsEntrySecurityNote create
   */
  export type OsEntrySecurityNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a OsEntrySecurityNote.
     */
    data: XOR<OsEntrySecurityNoteCreateInput, OsEntrySecurityNoteUncheckedCreateInput>
  }

  /**
   * OsEntrySecurityNote createMany
   */
  export type OsEntrySecurityNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsEntrySecurityNotes.
     */
    data: OsEntrySecurityNoteCreateManyInput | OsEntrySecurityNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsEntrySecurityNote createManyAndReturn
   */
  export type OsEntrySecurityNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * The data used to create many OsEntrySecurityNotes.
     */
    data: OsEntrySecurityNoteCreateManyInput | OsEntrySecurityNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntrySecurityNote update
   */
  export type OsEntrySecurityNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a OsEntrySecurityNote.
     */
    data: XOR<OsEntrySecurityNoteUpdateInput, OsEntrySecurityNoteUncheckedUpdateInput>
    /**
     * Choose, which OsEntrySecurityNote to update.
     */
    where: OsEntrySecurityNoteWhereUniqueInput
  }

  /**
   * OsEntrySecurityNote updateMany
   */
  export type OsEntrySecurityNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsEntrySecurityNotes.
     */
    data: XOR<OsEntrySecurityNoteUpdateManyMutationInput, OsEntrySecurityNoteUncheckedUpdateManyInput>
    /**
     * Filter which OsEntrySecurityNotes to update
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * Limit how many OsEntrySecurityNotes to update.
     */
    limit?: number
  }

  /**
   * OsEntrySecurityNote updateManyAndReturn
   */
  export type OsEntrySecurityNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * The data used to update OsEntrySecurityNotes.
     */
    data: XOR<OsEntrySecurityNoteUpdateManyMutationInput, OsEntrySecurityNoteUncheckedUpdateManyInput>
    /**
     * Filter which OsEntrySecurityNotes to update
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * Limit how many OsEntrySecurityNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OsEntrySecurityNote upsert
   */
  export type OsEntrySecurityNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the OsEntrySecurityNote to update in case it exists.
     */
    where: OsEntrySecurityNoteWhereUniqueInput
    /**
     * In case the OsEntrySecurityNote found by the `where` argument doesn't exist, create a new OsEntrySecurityNote with this data.
     */
    create: XOR<OsEntrySecurityNoteCreateInput, OsEntrySecurityNoteUncheckedCreateInput>
    /**
     * In case the OsEntrySecurityNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsEntrySecurityNoteUpdateInput, OsEntrySecurityNoteUncheckedUpdateInput>
  }

  /**
   * OsEntrySecurityNote delete
   */
  export type OsEntrySecurityNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
    /**
     * Filter which OsEntrySecurityNote to delete.
     */
    where: OsEntrySecurityNoteWhereUniqueInput
  }

  /**
   * OsEntrySecurityNote deleteMany
   */
  export type OsEntrySecurityNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsEntrySecurityNotes to delete
     */
    where?: OsEntrySecurityNoteWhereInput
    /**
     * Limit how many OsEntrySecurityNotes to delete.
     */
    limit?: number
  }

  /**
   * OsEntrySecurityNote without action
   */
  export type OsEntrySecurityNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntrySecurityNote
     */
    select?: OsEntrySecurityNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntrySecurityNote
     */
    omit?: OsEntrySecurityNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntrySecurityNoteInclude<ExtArgs> | null
  }


  /**
   * Model OsLookupName
   */

  export type AggregateOsLookupName = {
    _count: OsLookupNameCountAggregateOutputType | null
    _avg: OsLookupNameAvgAggregateOutputType | null
    _sum: OsLookupNameSumAggregateOutputType | null
    _min: OsLookupNameMinAggregateOutputType | null
    _max: OsLookupNameMaxAggregateOutputType | null
  }

  export type OsLookupNameAvgAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type OsLookupNameSumAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type OsLookupNameMinAggregateOutputType = {
    id: number | null
    name: string | null
    priority: number | null
  }

  export type OsLookupNameMaxAggregateOutputType = {
    id: number | null
    name: string | null
    priority: number | null
  }

  export type OsLookupNameCountAggregateOutputType = {
    id: number
    name: number
    priority: number
    _all: number
  }


  export type OsLookupNameAvgAggregateInputType = {
    id?: true
    priority?: true
  }

  export type OsLookupNameSumAggregateInputType = {
    id?: true
    priority?: true
  }

  export type OsLookupNameMinAggregateInputType = {
    id?: true
    name?: true
    priority?: true
  }

  export type OsLookupNameMaxAggregateInputType = {
    id?: true
    name?: true
    priority?: true
  }

  export type OsLookupNameCountAggregateInputType = {
    id?: true
    name?: true
    priority?: true
    _all?: true
  }

  export type OsLookupNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsLookupName to aggregate.
     */
    where?: OsLookupNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsLookupNames to fetch.
     */
    orderBy?: OsLookupNameOrderByWithRelationInput | OsLookupNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OsLookupNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsLookupNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsLookupNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OsLookupNames
    **/
    _count?: true | OsLookupNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OsLookupNameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OsLookupNameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OsLookupNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OsLookupNameMaxAggregateInputType
  }

  export type GetOsLookupNameAggregateType<T extends OsLookupNameAggregateArgs> = {
        [P in keyof T & keyof AggregateOsLookupName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOsLookupName[P]>
      : GetScalarType<T[P], AggregateOsLookupName[P]>
  }




  export type OsLookupNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OsLookupNameWhereInput
    orderBy?: OsLookupNameOrderByWithAggregationInput | OsLookupNameOrderByWithAggregationInput[]
    by: OsLookupNameScalarFieldEnum[] | OsLookupNameScalarFieldEnum
    having?: OsLookupNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OsLookupNameCountAggregateInputType | true
    _avg?: OsLookupNameAvgAggregateInputType
    _sum?: OsLookupNameSumAggregateInputType
    _min?: OsLookupNameMinAggregateInputType
    _max?: OsLookupNameMaxAggregateInputType
  }

  export type OsLookupNameGroupByOutputType = {
    id: number
    name: string
    priority: number | null
    _count: OsLookupNameCountAggregateOutputType | null
    _avg: OsLookupNameAvgAggregateOutputType | null
    _sum: OsLookupNameSumAggregateOutputType | null
    _min: OsLookupNameMinAggregateOutputType | null
    _max: OsLookupNameMaxAggregateOutputType | null
  }

  type GetOsLookupNameGroupByPayload<T extends OsLookupNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OsLookupNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OsLookupNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OsLookupNameGroupByOutputType[P]>
            : GetScalarType<T[P], OsLookupNameGroupByOutputType[P]>
        }
      >
    >


  export type OsLookupNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    priority?: boolean
    OsEntry?: boolean | OsLookupName$OsEntryArgs<ExtArgs>
    _count?: boolean | OsLookupNameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["osLookupName"]>

  export type OsLookupNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    priority?: boolean
  }, ExtArgs["result"]["osLookupName"]>

  export type OsLookupNameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    priority?: boolean
  }, ExtArgs["result"]["osLookupName"]>

  export type OsLookupNameSelectScalar = {
    id?: boolean
    name?: boolean
    priority?: boolean
  }

  export type OsLookupNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "priority", ExtArgs["result"]["osLookupName"]>
  export type OsLookupNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | OsLookupName$OsEntryArgs<ExtArgs>
    _count?: boolean | OsLookupNameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OsLookupNameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OsLookupNameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OsLookupNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OsLookupName"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      priority: number | null
    }, ExtArgs["result"]["osLookupName"]>
    composites: {}
  }

  type OsLookupNameGetPayload<S extends boolean | null | undefined | OsLookupNameDefaultArgs> = $Result.GetResult<Prisma.$OsLookupNamePayload, S>

  type OsLookupNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OsLookupNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OsLookupNameCountAggregateInputType | true
    }

  export interface OsLookupNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OsLookupName'], meta: { name: 'OsLookupName' } }
    /**
     * Find zero or one OsLookupName that matches the filter.
     * @param {OsLookupNameFindUniqueArgs} args - Arguments to find a OsLookupName
     * @example
     * // Get one OsLookupName
     * const osLookupName = await prisma.osLookupName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OsLookupNameFindUniqueArgs>(args: SelectSubset<T, OsLookupNameFindUniqueArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OsLookupName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OsLookupNameFindUniqueOrThrowArgs} args - Arguments to find a OsLookupName
     * @example
     * // Get one OsLookupName
     * const osLookupName = await prisma.osLookupName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OsLookupNameFindUniqueOrThrowArgs>(args: SelectSubset<T, OsLookupNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsLookupName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameFindFirstArgs} args - Arguments to find a OsLookupName
     * @example
     * // Get one OsLookupName
     * const osLookupName = await prisma.osLookupName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OsLookupNameFindFirstArgs>(args?: SelectSubset<T, OsLookupNameFindFirstArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OsLookupName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameFindFirstOrThrowArgs} args - Arguments to find a OsLookupName
     * @example
     * // Get one OsLookupName
     * const osLookupName = await prisma.osLookupName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OsLookupNameFindFirstOrThrowArgs>(args?: SelectSubset<T, OsLookupNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OsLookupNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OsLookupNames
     * const osLookupNames = await prisma.osLookupName.findMany()
     * 
     * // Get first 10 OsLookupNames
     * const osLookupNames = await prisma.osLookupName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const osLookupNameWithIdOnly = await prisma.osLookupName.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OsLookupNameFindManyArgs>(args?: SelectSubset<T, OsLookupNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OsLookupName.
     * @param {OsLookupNameCreateArgs} args - Arguments to create a OsLookupName.
     * @example
     * // Create one OsLookupName
     * const OsLookupName = await prisma.osLookupName.create({
     *   data: {
     *     // ... data to create a OsLookupName
     *   }
     * })
     * 
     */
    create<T extends OsLookupNameCreateArgs>(args: SelectSubset<T, OsLookupNameCreateArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OsLookupNames.
     * @param {OsLookupNameCreateManyArgs} args - Arguments to create many OsLookupNames.
     * @example
     * // Create many OsLookupNames
     * const osLookupName = await prisma.osLookupName.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OsLookupNameCreateManyArgs>(args?: SelectSubset<T, OsLookupNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OsLookupNames and returns the data saved in the database.
     * @param {OsLookupNameCreateManyAndReturnArgs} args - Arguments to create many OsLookupNames.
     * @example
     * // Create many OsLookupNames
     * const osLookupName = await prisma.osLookupName.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OsLookupNames and only return the `id`
     * const osLookupNameWithIdOnly = await prisma.osLookupName.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OsLookupNameCreateManyAndReturnArgs>(args?: SelectSubset<T, OsLookupNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OsLookupName.
     * @param {OsLookupNameDeleteArgs} args - Arguments to delete one OsLookupName.
     * @example
     * // Delete one OsLookupName
     * const OsLookupName = await prisma.osLookupName.delete({
     *   where: {
     *     // ... filter to delete one OsLookupName
     *   }
     * })
     * 
     */
    delete<T extends OsLookupNameDeleteArgs>(args: SelectSubset<T, OsLookupNameDeleteArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OsLookupName.
     * @param {OsLookupNameUpdateArgs} args - Arguments to update one OsLookupName.
     * @example
     * // Update one OsLookupName
     * const osLookupName = await prisma.osLookupName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OsLookupNameUpdateArgs>(args: SelectSubset<T, OsLookupNameUpdateArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OsLookupNames.
     * @param {OsLookupNameDeleteManyArgs} args - Arguments to filter OsLookupNames to delete.
     * @example
     * // Delete a few OsLookupNames
     * const { count } = await prisma.osLookupName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OsLookupNameDeleteManyArgs>(args?: SelectSubset<T, OsLookupNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsLookupNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OsLookupNames
     * const osLookupName = await prisma.osLookupName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OsLookupNameUpdateManyArgs>(args: SelectSubset<T, OsLookupNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OsLookupNames and returns the data updated in the database.
     * @param {OsLookupNameUpdateManyAndReturnArgs} args - Arguments to update many OsLookupNames.
     * @example
     * // Update many OsLookupNames
     * const osLookupName = await prisma.osLookupName.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OsLookupNames and only return the `id`
     * const osLookupNameWithIdOnly = await prisma.osLookupName.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OsLookupNameUpdateManyAndReturnArgs>(args: SelectSubset<T, OsLookupNameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OsLookupName.
     * @param {OsLookupNameUpsertArgs} args - Arguments to update or create a OsLookupName.
     * @example
     * // Update or create a OsLookupName
     * const osLookupName = await prisma.osLookupName.upsert({
     *   create: {
     *     // ... data to create a OsLookupName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OsLookupName we want to update
     *   }
     * })
     */
    upsert<T extends OsLookupNameUpsertArgs>(args: SelectSubset<T, OsLookupNameUpsertArgs<ExtArgs>>): Prisma__OsLookupNameClient<$Result.GetResult<Prisma.$OsLookupNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OsLookupNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameCountArgs} args - Arguments to filter OsLookupNames to count.
     * @example
     * // Count the number of OsLookupNames
     * const count = await prisma.osLookupName.count({
     *   where: {
     *     // ... the filter for the OsLookupNames we want to count
     *   }
     * })
    **/
    count<T extends OsLookupNameCountArgs>(
      args?: Subset<T, OsLookupNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OsLookupNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OsLookupName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OsLookupNameAggregateArgs>(args: Subset<T, OsLookupNameAggregateArgs>): Prisma.PrismaPromise<GetOsLookupNameAggregateType<T>>

    /**
     * Group by OsLookupName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OsLookupNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OsLookupNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OsLookupNameGroupByArgs['orderBy'] }
        : { orderBy?: OsLookupNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OsLookupNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOsLookupNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OsLookupName model
   */
  readonly fields: OsLookupNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OsLookupName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OsLookupNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends OsLookupName$OsEntryArgs<ExtArgs> = {}>(args?: Subset<T, OsLookupName$OsEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OsLookupName model
   */
  interface OsLookupNameFieldRefs {
    readonly id: FieldRef<"OsLookupName", 'Int'>
    readonly name: FieldRef<"OsLookupName", 'String'>
    readonly priority: FieldRef<"OsLookupName", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OsLookupName findUnique
   */
  export type OsLookupNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter, which OsLookupName to fetch.
     */
    where: OsLookupNameWhereUniqueInput
  }

  /**
   * OsLookupName findUniqueOrThrow
   */
  export type OsLookupNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter, which OsLookupName to fetch.
     */
    where: OsLookupNameWhereUniqueInput
  }

  /**
   * OsLookupName findFirst
   */
  export type OsLookupNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter, which OsLookupName to fetch.
     */
    where?: OsLookupNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsLookupNames to fetch.
     */
    orderBy?: OsLookupNameOrderByWithRelationInput | OsLookupNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsLookupNames.
     */
    cursor?: OsLookupNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsLookupNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsLookupNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsLookupNames.
     */
    distinct?: OsLookupNameScalarFieldEnum | OsLookupNameScalarFieldEnum[]
  }

  /**
   * OsLookupName findFirstOrThrow
   */
  export type OsLookupNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter, which OsLookupName to fetch.
     */
    where?: OsLookupNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsLookupNames to fetch.
     */
    orderBy?: OsLookupNameOrderByWithRelationInput | OsLookupNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OsLookupNames.
     */
    cursor?: OsLookupNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsLookupNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsLookupNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OsLookupNames.
     */
    distinct?: OsLookupNameScalarFieldEnum | OsLookupNameScalarFieldEnum[]
  }

  /**
   * OsLookupName findMany
   */
  export type OsLookupNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter, which OsLookupNames to fetch.
     */
    where?: OsLookupNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OsLookupNames to fetch.
     */
    orderBy?: OsLookupNameOrderByWithRelationInput | OsLookupNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OsLookupNames.
     */
    cursor?: OsLookupNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OsLookupNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OsLookupNames.
     */
    skip?: number
    distinct?: OsLookupNameScalarFieldEnum | OsLookupNameScalarFieldEnum[]
  }

  /**
   * OsLookupName create
   */
  export type OsLookupNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * The data needed to create a OsLookupName.
     */
    data: XOR<OsLookupNameCreateInput, OsLookupNameUncheckedCreateInput>
  }

  /**
   * OsLookupName createMany
   */
  export type OsLookupNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OsLookupNames.
     */
    data: OsLookupNameCreateManyInput | OsLookupNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsLookupName createManyAndReturn
   */
  export type OsLookupNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * The data used to create many OsLookupNames.
     */
    data: OsLookupNameCreateManyInput | OsLookupNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OsLookupName update
   */
  export type OsLookupNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * The data needed to update a OsLookupName.
     */
    data: XOR<OsLookupNameUpdateInput, OsLookupNameUncheckedUpdateInput>
    /**
     * Choose, which OsLookupName to update.
     */
    where: OsLookupNameWhereUniqueInput
  }

  /**
   * OsLookupName updateMany
   */
  export type OsLookupNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OsLookupNames.
     */
    data: XOR<OsLookupNameUpdateManyMutationInput, OsLookupNameUncheckedUpdateManyInput>
    /**
     * Filter which OsLookupNames to update
     */
    where?: OsLookupNameWhereInput
    /**
     * Limit how many OsLookupNames to update.
     */
    limit?: number
  }

  /**
   * OsLookupName updateManyAndReturn
   */
  export type OsLookupNameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * The data used to update OsLookupNames.
     */
    data: XOR<OsLookupNameUpdateManyMutationInput, OsLookupNameUncheckedUpdateManyInput>
    /**
     * Filter which OsLookupNames to update
     */
    where?: OsLookupNameWhereInput
    /**
     * Limit how many OsLookupNames to update.
     */
    limit?: number
  }

  /**
   * OsLookupName upsert
   */
  export type OsLookupNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * The filter to search for the OsLookupName to update in case it exists.
     */
    where: OsLookupNameWhereUniqueInput
    /**
     * In case the OsLookupName found by the `where` argument doesn't exist, create a new OsLookupName with this data.
     */
    create: XOR<OsLookupNameCreateInput, OsLookupNameUncheckedCreateInput>
    /**
     * In case the OsLookupName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OsLookupNameUpdateInput, OsLookupNameUncheckedUpdateInput>
  }

  /**
   * OsLookupName delete
   */
  export type OsLookupNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
    /**
     * Filter which OsLookupName to delete.
     */
    where: OsLookupNameWhereUniqueInput
  }

  /**
   * OsLookupName deleteMany
   */
  export type OsLookupNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OsLookupNames to delete
     */
    where?: OsLookupNameWhereInput
    /**
     * Limit how many OsLookupNames to delete.
     */
    limit?: number
  }

  /**
   * OsLookupName.OsEntry
   */
  export type OsLookupName$OsEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    where?: OsEntryWhereInput
    orderBy?: OsEntryOrderByWithRelationInput | OsEntryOrderByWithRelationInput[]
    cursor?: OsEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OsEntryScalarFieldEnum | OsEntryScalarFieldEnum[]
  }

  /**
   * OsLookupName without action
   */
  export type OsLookupNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsLookupName
     */
    select?: OsLookupNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsLookupName
     */
    omit?: OsLookupNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsLookupNameInclude<ExtArgs> | null
  }


  /**
   * Model SourceEntry
   */

  export type AggregateSourceEntry = {
    _count: SourceEntryCountAggregateOutputType | null
    _avg: SourceEntryAvgAggregateOutputType | null
    _sum: SourceEntrySumAggregateOutputType | null
    _min: SourceEntryMinAggregateOutputType | null
    _max: SourceEntryMaxAggregateOutputType | null
  }

  export type SourceEntryAvgAggregateOutputType = {
    id: number | null
    os_id: number | null
    size: number | null
  }

  export type SourceEntrySumAggregateOutputType = {
    id: number | null
    os_id: number | null
    size: bigint | null
  }

  export type SourceEntryMinAggregateOutputType = {
    id: number | null
    os_id: number | null
    source_type: string | null
    skip_update_links: boolean | null
    size: bigint | null
    windows_update_id: string | null
    windows_revision_id: string | null
  }

  export type SourceEntryMaxAggregateOutputType = {
    id: number | null
    os_id: number | null
    source_type: string | null
    skip_update_links: boolean | null
    size: bigint | null
    windows_update_id: string | null
    windows_revision_id: string | null
  }

  export type SourceEntryCountAggregateOutputType = {
    id: number
    os_id: number
    source_type: number
    skip_update_links: number
    size: number
    windows_update_id: number
    windows_revision_id: number
    _all: number
  }


  export type SourceEntryAvgAggregateInputType = {
    id?: true
    os_id?: true
    size?: true
  }

  export type SourceEntrySumAggregateInputType = {
    id?: true
    os_id?: true
    size?: true
  }

  export type SourceEntryMinAggregateInputType = {
    id?: true
    os_id?: true
    source_type?: true
    skip_update_links?: true
    size?: true
    windows_update_id?: true
    windows_revision_id?: true
  }

  export type SourceEntryMaxAggregateInputType = {
    id?: true
    os_id?: true
    source_type?: true
    skip_update_links?: true
    size?: true
    windows_update_id?: true
    windows_revision_id?: true
  }

  export type SourceEntryCountAggregateInputType = {
    id?: true
    os_id?: true
    source_type?: true
    skip_update_links?: true
    size?: true
    windows_update_id?: true
    windows_revision_id?: true
    _all?: true
  }

  export type SourceEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceEntry to aggregate.
     */
    where?: SourceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceEntries to fetch.
     */
    orderBy?: SourceEntryOrderByWithRelationInput | SourceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceEntries
    **/
    _count?: true | SourceEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceEntryMaxAggregateInputType
  }

  export type GetSourceEntryAggregateType<T extends SourceEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceEntry[P]>
      : GetScalarType<T[P], AggregateSourceEntry[P]>
  }




  export type SourceEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceEntryWhereInput
    orderBy?: SourceEntryOrderByWithAggregationInput | SourceEntryOrderByWithAggregationInput[]
    by: SourceEntryScalarFieldEnum[] | SourceEntryScalarFieldEnum
    having?: SourceEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceEntryCountAggregateInputType | true
    _avg?: SourceEntryAvgAggregateInputType
    _sum?: SourceEntrySumAggregateInputType
    _min?: SourceEntryMinAggregateInputType
    _max?: SourceEntryMaxAggregateInputType
  }

  export type SourceEntryGroupByOutputType = {
    id: number
    os_id: number | null
    source_type: string | null
    skip_update_links: boolean | null
    size: bigint | null
    windows_update_id: string | null
    windows_revision_id: string | null
    _count: SourceEntryCountAggregateOutputType | null
    _avg: SourceEntryAvgAggregateOutputType | null
    _sum: SourceEntrySumAggregateOutputType | null
    _min: SourceEntryMinAggregateOutputType | null
    _max: SourceEntryMaxAggregateOutputType | null
  }

  type GetSourceEntryGroupByPayload<T extends SourceEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceEntryGroupByOutputType[P]>
            : GetScalarType<T[P], SourceEntryGroupByOutputType[P]>
        }
      >
    >


  export type SourceEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    os_id?: boolean
    source_type?: boolean
    skip_update_links?: boolean
    size?: boolean
    windows_update_id?: boolean
    windows_revision_id?: boolean
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
    SourceHash?: boolean | SourceEntry$SourceHashArgs<ExtArgs>
    SourceLink?: boolean | SourceEntry$SourceLinkArgs<ExtArgs>
    SourceMapDevice?: boolean | SourceEntry$SourceMapDeviceArgs<ExtArgs>
    SourcePrequisiteBuild?: boolean | SourceEntry$SourcePrequisiteBuildArgs<ExtArgs>
    _count?: boolean | SourceEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceEntry"]>

  export type SourceEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    os_id?: boolean
    source_type?: boolean
    skip_update_links?: boolean
    size?: boolean
    windows_update_id?: boolean
    windows_revision_id?: boolean
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
  }, ExtArgs["result"]["sourceEntry"]>

  export type SourceEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    os_id?: boolean
    source_type?: boolean
    skip_update_links?: boolean
    size?: boolean
    windows_update_id?: boolean
    windows_revision_id?: boolean
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
  }, ExtArgs["result"]["sourceEntry"]>

  export type SourceEntrySelectScalar = {
    id?: boolean
    os_id?: boolean
    source_type?: boolean
    skip_update_links?: boolean
    size?: boolean
    windows_update_id?: boolean
    windows_revision_id?: boolean
  }

  export type SourceEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "os_id" | "source_type" | "skip_update_links" | "size" | "windows_update_id" | "windows_revision_id", ExtArgs["result"]["sourceEntry"]>
  export type SourceEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
    SourceHash?: boolean | SourceEntry$SourceHashArgs<ExtArgs>
    SourceLink?: boolean | SourceEntry$SourceLinkArgs<ExtArgs>
    SourceMapDevice?: boolean | SourceEntry$SourceMapDeviceArgs<ExtArgs>
    SourcePrequisiteBuild?: boolean | SourceEntry$SourcePrequisiteBuildArgs<ExtArgs>
    _count?: boolean | SourceEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
  }
  export type SourceEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OsEntry?: boolean | SourceEntry$OsEntryArgs<ExtArgs>
  }

  export type $SourceEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceEntry"
    objects: {
      OsEntry: Prisma.$OsEntryPayload<ExtArgs> | null
      SourceHash: Prisma.$SourceHashPayload<ExtArgs>[]
      SourceLink: Prisma.$SourceLinkPayload<ExtArgs>[]
      SourceMapDevice: Prisma.$SourceMapDevicePayload<ExtArgs>[]
      SourcePrequisiteBuild: Prisma.$SourcePrequisiteBuildPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      os_id: number | null
      source_type: string | null
      skip_update_links: boolean | null
      size: bigint | null
      windows_update_id: string | null
      windows_revision_id: string | null
    }, ExtArgs["result"]["sourceEntry"]>
    composites: {}
  }

  type SourceEntryGetPayload<S extends boolean | null | undefined | SourceEntryDefaultArgs> = $Result.GetResult<Prisma.$SourceEntryPayload, S>

  type SourceEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceEntryCountAggregateInputType | true
    }

  export interface SourceEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceEntry'], meta: { name: 'SourceEntry' } }
    /**
     * Find zero or one SourceEntry that matches the filter.
     * @param {SourceEntryFindUniqueArgs} args - Arguments to find a SourceEntry
     * @example
     * // Get one SourceEntry
     * const sourceEntry = await prisma.sourceEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceEntryFindUniqueArgs>(args: SelectSubset<T, SourceEntryFindUniqueArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceEntryFindUniqueOrThrowArgs} args - Arguments to find a SourceEntry
     * @example
     * // Get one SourceEntry
     * const sourceEntry = await prisma.sourceEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryFindFirstArgs} args - Arguments to find a SourceEntry
     * @example
     * // Get one SourceEntry
     * const sourceEntry = await prisma.sourceEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceEntryFindFirstArgs>(args?: SelectSubset<T, SourceEntryFindFirstArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryFindFirstOrThrowArgs} args - Arguments to find a SourceEntry
     * @example
     * // Get one SourceEntry
     * const sourceEntry = await prisma.sourceEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceEntries
     * const sourceEntries = await prisma.sourceEntry.findMany()
     * 
     * // Get first 10 SourceEntries
     * const sourceEntries = await prisma.sourceEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceEntryWithIdOnly = await prisma.sourceEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceEntryFindManyArgs>(args?: SelectSubset<T, SourceEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceEntry.
     * @param {SourceEntryCreateArgs} args - Arguments to create a SourceEntry.
     * @example
     * // Create one SourceEntry
     * const SourceEntry = await prisma.sourceEntry.create({
     *   data: {
     *     // ... data to create a SourceEntry
     *   }
     * })
     * 
     */
    create<T extends SourceEntryCreateArgs>(args: SelectSubset<T, SourceEntryCreateArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceEntries.
     * @param {SourceEntryCreateManyArgs} args - Arguments to create many SourceEntries.
     * @example
     * // Create many SourceEntries
     * const sourceEntry = await prisma.sourceEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceEntryCreateManyArgs>(args?: SelectSubset<T, SourceEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceEntries and returns the data saved in the database.
     * @param {SourceEntryCreateManyAndReturnArgs} args - Arguments to create many SourceEntries.
     * @example
     * // Create many SourceEntries
     * const sourceEntry = await prisma.sourceEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceEntries and only return the `id`
     * const sourceEntryWithIdOnly = await prisma.sourceEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceEntry.
     * @param {SourceEntryDeleteArgs} args - Arguments to delete one SourceEntry.
     * @example
     * // Delete one SourceEntry
     * const SourceEntry = await prisma.sourceEntry.delete({
     *   where: {
     *     // ... filter to delete one SourceEntry
     *   }
     * })
     * 
     */
    delete<T extends SourceEntryDeleteArgs>(args: SelectSubset<T, SourceEntryDeleteArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceEntry.
     * @param {SourceEntryUpdateArgs} args - Arguments to update one SourceEntry.
     * @example
     * // Update one SourceEntry
     * const sourceEntry = await prisma.sourceEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceEntryUpdateArgs>(args: SelectSubset<T, SourceEntryUpdateArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceEntries.
     * @param {SourceEntryDeleteManyArgs} args - Arguments to filter SourceEntries to delete.
     * @example
     * // Delete a few SourceEntries
     * const { count } = await prisma.sourceEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceEntryDeleteManyArgs>(args?: SelectSubset<T, SourceEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceEntries
     * const sourceEntry = await prisma.sourceEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceEntryUpdateManyArgs>(args: SelectSubset<T, SourceEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceEntries and returns the data updated in the database.
     * @param {SourceEntryUpdateManyAndReturnArgs} args - Arguments to update many SourceEntries.
     * @example
     * // Update many SourceEntries
     * const sourceEntry = await prisma.sourceEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceEntries and only return the `id`
     * const sourceEntryWithIdOnly = await prisma.sourceEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceEntry.
     * @param {SourceEntryUpsertArgs} args - Arguments to update or create a SourceEntry.
     * @example
     * // Update or create a SourceEntry
     * const sourceEntry = await prisma.sourceEntry.upsert({
     *   create: {
     *     // ... data to create a SourceEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceEntry we want to update
     *   }
     * })
     */
    upsert<T extends SourceEntryUpsertArgs>(args: SelectSubset<T, SourceEntryUpsertArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryCountArgs} args - Arguments to filter SourceEntries to count.
     * @example
     * // Count the number of SourceEntries
     * const count = await prisma.sourceEntry.count({
     *   where: {
     *     // ... the filter for the SourceEntries we want to count
     *   }
     * })
    **/
    count<T extends SourceEntryCountArgs>(
      args?: Subset<T, SourceEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceEntryAggregateArgs>(args: Subset<T, SourceEntryAggregateArgs>): Prisma.PrismaPromise<GetSourceEntryAggregateType<T>>

    /**
     * Group by SourceEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceEntryGroupByArgs['orderBy'] }
        : { orderBy?: SourceEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceEntry model
   */
  readonly fields: SourceEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OsEntry<T extends SourceEntry$OsEntryArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntry$OsEntryArgs<ExtArgs>>): Prisma__OsEntryClient<$Result.GetResult<Prisma.$OsEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SourceHash<T extends SourceEntry$SourceHashArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntry$SourceHashArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceLink<T extends SourceEntry$SourceLinkArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntry$SourceLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourceMapDevice<T extends SourceEntry$SourceMapDeviceArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntry$SourceMapDeviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SourcePrequisiteBuild<T extends SourceEntry$SourcePrequisiteBuildArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntry$SourcePrequisiteBuildArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceEntry model
   */
  interface SourceEntryFieldRefs {
    readonly id: FieldRef<"SourceEntry", 'Int'>
    readonly os_id: FieldRef<"SourceEntry", 'Int'>
    readonly source_type: FieldRef<"SourceEntry", 'String'>
    readonly skip_update_links: FieldRef<"SourceEntry", 'Boolean'>
    readonly size: FieldRef<"SourceEntry", 'BigInt'>
    readonly windows_update_id: FieldRef<"SourceEntry", 'String'>
    readonly windows_revision_id: FieldRef<"SourceEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SourceEntry findUnique
   */
  export type SourceEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter, which SourceEntry to fetch.
     */
    where: SourceEntryWhereUniqueInput
  }

  /**
   * SourceEntry findUniqueOrThrow
   */
  export type SourceEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter, which SourceEntry to fetch.
     */
    where: SourceEntryWhereUniqueInput
  }

  /**
   * SourceEntry findFirst
   */
  export type SourceEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter, which SourceEntry to fetch.
     */
    where?: SourceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceEntries to fetch.
     */
    orderBy?: SourceEntryOrderByWithRelationInput | SourceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceEntries.
     */
    cursor?: SourceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceEntries.
     */
    distinct?: SourceEntryScalarFieldEnum | SourceEntryScalarFieldEnum[]
  }

  /**
   * SourceEntry findFirstOrThrow
   */
  export type SourceEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter, which SourceEntry to fetch.
     */
    where?: SourceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceEntries to fetch.
     */
    orderBy?: SourceEntryOrderByWithRelationInput | SourceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceEntries.
     */
    cursor?: SourceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceEntries.
     */
    distinct?: SourceEntryScalarFieldEnum | SourceEntryScalarFieldEnum[]
  }

  /**
   * SourceEntry findMany
   */
  export type SourceEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter, which SourceEntries to fetch.
     */
    where?: SourceEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceEntries to fetch.
     */
    orderBy?: SourceEntryOrderByWithRelationInput | SourceEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceEntries.
     */
    cursor?: SourceEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceEntries.
     */
    skip?: number
    distinct?: SourceEntryScalarFieldEnum | SourceEntryScalarFieldEnum[]
  }

  /**
   * SourceEntry create
   */
  export type SourceEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceEntry.
     */
    data?: XOR<SourceEntryCreateInput, SourceEntryUncheckedCreateInput>
  }

  /**
   * SourceEntry createMany
   */
  export type SourceEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceEntries.
     */
    data: SourceEntryCreateManyInput | SourceEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceEntry createManyAndReturn
   */
  export type SourceEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * The data used to create many SourceEntries.
     */
    data: SourceEntryCreateManyInput | SourceEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceEntry update
   */
  export type SourceEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceEntry.
     */
    data: XOR<SourceEntryUpdateInput, SourceEntryUncheckedUpdateInput>
    /**
     * Choose, which SourceEntry to update.
     */
    where: SourceEntryWhereUniqueInput
  }

  /**
   * SourceEntry updateMany
   */
  export type SourceEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceEntries.
     */
    data: XOR<SourceEntryUpdateManyMutationInput, SourceEntryUncheckedUpdateManyInput>
    /**
     * Filter which SourceEntries to update
     */
    where?: SourceEntryWhereInput
    /**
     * Limit how many SourceEntries to update.
     */
    limit?: number
  }

  /**
   * SourceEntry updateManyAndReturn
   */
  export type SourceEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * The data used to update SourceEntries.
     */
    data: XOR<SourceEntryUpdateManyMutationInput, SourceEntryUncheckedUpdateManyInput>
    /**
     * Filter which SourceEntries to update
     */
    where?: SourceEntryWhereInput
    /**
     * Limit how many SourceEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceEntry upsert
   */
  export type SourceEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceEntry to update in case it exists.
     */
    where: SourceEntryWhereUniqueInput
    /**
     * In case the SourceEntry found by the `where` argument doesn't exist, create a new SourceEntry with this data.
     */
    create: XOR<SourceEntryCreateInput, SourceEntryUncheckedCreateInput>
    /**
     * In case the SourceEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceEntryUpdateInput, SourceEntryUncheckedUpdateInput>
  }

  /**
   * SourceEntry delete
   */
  export type SourceEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
    /**
     * Filter which SourceEntry to delete.
     */
    where: SourceEntryWhereUniqueInput
  }

  /**
   * SourceEntry deleteMany
   */
  export type SourceEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceEntries to delete
     */
    where?: SourceEntryWhereInput
    /**
     * Limit how many SourceEntries to delete.
     */
    limit?: number
  }

  /**
   * SourceEntry.OsEntry
   */
  export type SourceEntry$OsEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OsEntry
     */
    select?: OsEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OsEntry
     */
    omit?: OsEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OsEntryInclude<ExtArgs> | null
    where?: OsEntryWhereInput
  }

  /**
   * SourceEntry.SourceHash
   */
  export type SourceEntry$SourceHashArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    where?: SourceHashWhereInput
    orderBy?: SourceHashOrderByWithRelationInput | SourceHashOrderByWithRelationInput[]
    cursor?: SourceHashWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceHashScalarFieldEnum | SourceHashScalarFieldEnum[]
  }

  /**
   * SourceEntry.SourceLink
   */
  export type SourceEntry$SourceLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    where?: SourceLinkWhereInput
    orderBy?: SourceLinkOrderByWithRelationInput | SourceLinkOrderByWithRelationInput[]
    cursor?: SourceLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceLinkScalarFieldEnum | SourceLinkScalarFieldEnum[]
  }

  /**
   * SourceEntry.SourceMapDevice
   */
  export type SourceEntry$SourceMapDeviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    where?: SourceMapDeviceWhereInput
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    cursor?: SourceMapDeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceMapDeviceScalarFieldEnum | SourceMapDeviceScalarFieldEnum[]
  }

  /**
   * SourceEntry.SourcePrequisiteBuild
   */
  export type SourceEntry$SourcePrequisiteBuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    where?: SourcePrequisiteBuildWhereInput
    orderBy?: SourcePrequisiteBuildOrderByWithRelationInput | SourcePrequisiteBuildOrderByWithRelationInput[]
    cursor?: SourcePrequisiteBuildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourcePrequisiteBuildScalarFieldEnum | SourcePrequisiteBuildScalarFieldEnum[]
  }

  /**
   * SourceEntry without action
   */
  export type SourceEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceEntry
     */
    select?: SourceEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceEntry
     */
    omit?: SourceEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceEntryInclude<ExtArgs> | null
  }


  /**
   * Model SourceHash
   */

  export type AggregateSourceHash = {
    _count: SourceHashCountAggregateOutputType | null
    _avg: SourceHashAvgAggregateOutputType | null
    _sum: SourceHashSumAggregateOutputType | null
    _min: SourceHashMinAggregateOutputType | null
    _max: SourceHashMaxAggregateOutputType | null
  }

  export type SourceHashAvgAggregateOutputType = {
    source_id: number | null
  }

  export type SourceHashSumAggregateOutputType = {
    source_id: number | null
  }

  export type SourceHashMinAggregateOutputType = {
    source_id: number | null
    hash_type: string | null
    hash_value: string | null
  }

  export type SourceHashMaxAggregateOutputType = {
    source_id: number | null
    hash_type: string | null
    hash_value: string | null
  }

  export type SourceHashCountAggregateOutputType = {
    source_id: number
    hash_type: number
    hash_value: number
    _all: number
  }


  export type SourceHashAvgAggregateInputType = {
    source_id?: true
  }

  export type SourceHashSumAggregateInputType = {
    source_id?: true
  }

  export type SourceHashMinAggregateInputType = {
    source_id?: true
    hash_type?: true
    hash_value?: true
  }

  export type SourceHashMaxAggregateInputType = {
    source_id?: true
    hash_type?: true
    hash_value?: true
  }

  export type SourceHashCountAggregateInputType = {
    source_id?: true
    hash_type?: true
    hash_value?: true
    _all?: true
  }

  export type SourceHashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceHash to aggregate.
     */
    where?: SourceHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceHashes to fetch.
     */
    orderBy?: SourceHashOrderByWithRelationInput | SourceHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceHashes
    **/
    _count?: true | SourceHashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceHashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceHashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceHashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceHashMaxAggregateInputType
  }

  export type GetSourceHashAggregateType<T extends SourceHashAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceHash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceHash[P]>
      : GetScalarType<T[P], AggregateSourceHash[P]>
  }




  export type SourceHashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceHashWhereInput
    orderBy?: SourceHashOrderByWithAggregationInput | SourceHashOrderByWithAggregationInput[]
    by: SourceHashScalarFieldEnum[] | SourceHashScalarFieldEnum
    having?: SourceHashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceHashCountAggregateInputType | true
    _avg?: SourceHashAvgAggregateInputType
    _sum?: SourceHashSumAggregateInputType
    _min?: SourceHashMinAggregateInputType
    _max?: SourceHashMaxAggregateInputType
  }

  export type SourceHashGroupByOutputType = {
    source_id: number
    hash_type: string
    hash_value: string | null
    _count: SourceHashCountAggregateOutputType | null
    _avg: SourceHashAvgAggregateOutputType | null
    _sum: SourceHashSumAggregateOutputType | null
    _min: SourceHashMinAggregateOutputType | null
    _max: SourceHashMaxAggregateOutputType | null
  }

  type GetSourceHashGroupByPayload<T extends SourceHashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceHashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceHashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceHashGroupByOutputType[P]>
            : GetScalarType<T[P], SourceHashGroupByOutputType[P]>
        }
      >
    >


  export type SourceHashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    hash_type?: boolean
    hash_value?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceHash"]>

  export type SourceHashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    hash_type?: boolean
    hash_value?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceHash"]>

  export type SourceHashSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    hash_type?: boolean
    hash_value?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceHash"]>

  export type SourceHashSelectScalar = {
    source_id?: boolean
    hash_type?: boolean
    hash_value?: boolean
  }

  export type SourceHashOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"source_id" | "hash_type" | "hash_value", ExtArgs["result"]["sourceHash"]>
  export type SourceHashInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourceHashIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourceHashIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }

  export type $SourceHashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceHash"
    objects: {
      SourceEntry: Prisma.$SourceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      source_id: number
      hash_type: string
      hash_value: string | null
    }, ExtArgs["result"]["sourceHash"]>
    composites: {}
  }

  type SourceHashGetPayload<S extends boolean | null | undefined | SourceHashDefaultArgs> = $Result.GetResult<Prisma.$SourceHashPayload, S>

  type SourceHashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceHashFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceHashCountAggregateInputType | true
    }

  export interface SourceHashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceHash'], meta: { name: 'SourceHash' } }
    /**
     * Find zero or one SourceHash that matches the filter.
     * @param {SourceHashFindUniqueArgs} args - Arguments to find a SourceHash
     * @example
     * // Get one SourceHash
     * const sourceHash = await prisma.sourceHash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceHashFindUniqueArgs>(args: SelectSubset<T, SourceHashFindUniqueArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceHash that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceHashFindUniqueOrThrowArgs} args - Arguments to find a SourceHash
     * @example
     * // Get one SourceHash
     * const sourceHash = await prisma.sourceHash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceHashFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceHashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceHash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashFindFirstArgs} args - Arguments to find a SourceHash
     * @example
     * // Get one SourceHash
     * const sourceHash = await prisma.sourceHash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceHashFindFirstArgs>(args?: SelectSubset<T, SourceHashFindFirstArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceHash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashFindFirstOrThrowArgs} args - Arguments to find a SourceHash
     * @example
     * // Get one SourceHash
     * const sourceHash = await prisma.sourceHash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceHashFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceHashFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceHashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceHashes
     * const sourceHashes = await prisma.sourceHash.findMany()
     * 
     * // Get first 10 SourceHashes
     * const sourceHashes = await prisma.sourceHash.findMany({ take: 10 })
     * 
     * // Only select the `source_id`
     * const sourceHashWithSource_idOnly = await prisma.sourceHash.findMany({ select: { source_id: true } })
     * 
     */
    findMany<T extends SourceHashFindManyArgs>(args?: SelectSubset<T, SourceHashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceHash.
     * @param {SourceHashCreateArgs} args - Arguments to create a SourceHash.
     * @example
     * // Create one SourceHash
     * const SourceHash = await prisma.sourceHash.create({
     *   data: {
     *     // ... data to create a SourceHash
     *   }
     * })
     * 
     */
    create<T extends SourceHashCreateArgs>(args: SelectSubset<T, SourceHashCreateArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceHashes.
     * @param {SourceHashCreateManyArgs} args - Arguments to create many SourceHashes.
     * @example
     * // Create many SourceHashes
     * const sourceHash = await prisma.sourceHash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceHashCreateManyArgs>(args?: SelectSubset<T, SourceHashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceHashes and returns the data saved in the database.
     * @param {SourceHashCreateManyAndReturnArgs} args - Arguments to create many SourceHashes.
     * @example
     * // Create many SourceHashes
     * const sourceHash = await prisma.sourceHash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceHashes and only return the `source_id`
     * const sourceHashWithSource_idOnly = await prisma.sourceHash.createManyAndReturn({
     *   select: { source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceHashCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceHashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceHash.
     * @param {SourceHashDeleteArgs} args - Arguments to delete one SourceHash.
     * @example
     * // Delete one SourceHash
     * const SourceHash = await prisma.sourceHash.delete({
     *   where: {
     *     // ... filter to delete one SourceHash
     *   }
     * })
     * 
     */
    delete<T extends SourceHashDeleteArgs>(args: SelectSubset<T, SourceHashDeleteArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceHash.
     * @param {SourceHashUpdateArgs} args - Arguments to update one SourceHash.
     * @example
     * // Update one SourceHash
     * const sourceHash = await prisma.sourceHash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceHashUpdateArgs>(args: SelectSubset<T, SourceHashUpdateArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceHashes.
     * @param {SourceHashDeleteManyArgs} args - Arguments to filter SourceHashes to delete.
     * @example
     * // Delete a few SourceHashes
     * const { count } = await prisma.sourceHash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceHashDeleteManyArgs>(args?: SelectSubset<T, SourceHashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceHashes
     * const sourceHash = await prisma.sourceHash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceHashUpdateManyArgs>(args: SelectSubset<T, SourceHashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceHashes and returns the data updated in the database.
     * @param {SourceHashUpdateManyAndReturnArgs} args - Arguments to update many SourceHashes.
     * @example
     * // Update many SourceHashes
     * const sourceHash = await prisma.sourceHash.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceHashes and only return the `source_id`
     * const sourceHashWithSource_idOnly = await prisma.sourceHash.updateManyAndReturn({
     *   select: { source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceHashUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceHashUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceHash.
     * @param {SourceHashUpsertArgs} args - Arguments to update or create a SourceHash.
     * @example
     * // Update or create a SourceHash
     * const sourceHash = await prisma.sourceHash.upsert({
     *   create: {
     *     // ... data to create a SourceHash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceHash we want to update
     *   }
     * })
     */
    upsert<T extends SourceHashUpsertArgs>(args: SelectSubset<T, SourceHashUpsertArgs<ExtArgs>>): Prisma__SourceHashClient<$Result.GetResult<Prisma.$SourceHashPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceHashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashCountArgs} args - Arguments to filter SourceHashes to count.
     * @example
     * // Count the number of SourceHashes
     * const count = await prisma.sourceHash.count({
     *   where: {
     *     // ... the filter for the SourceHashes we want to count
     *   }
     * })
    **/
    count<T extends SourceHashCountArgs>(
      args?: Subset<T, SourceHashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceHashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceHash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceHashAggregateArgs>(args: Subset<T, SourceHashAggregateArgs>): Prisma.PrismaPromise<GetSourceHashAggregateType<T>>

    /**
     * Group by SourceHash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceHashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceHashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceHashGroupByArgs['orderBy'] }
        : { orderBy?: SourceHashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceHashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceHashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceHash model
   */
  readonly fields: SourceHashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceHash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceHashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SourceEntry<T extends SourceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntryDefaultArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceHash model
   */
  interface SourceHashFieldRefs {
    readonly source_id: FieldRef<"SourceHash", 'Int'>
    readonly hash_type: FieldRef<"SourceHash", 'String'>
    readonly hash_value: FieldRef<"SourceHash", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SourceHash findUnique
   */
  export type SourceHashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter, which SourceHash to fetch.
     */
    where: SourceHashWhereUniqueInput
  }

  /**
   * SourceHash findUniqueOrThrow
   */
  export type SourceHashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter, which SourceHash to fetch.
     */
    where: SourceHashWhereUniqueInput
  }

  /**
   * SourceHash findFirst
   */
  export type SourceHashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter, which SourceHash to fetch.
     */
    where?: SourceHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceHashes to fetch.
     */
    orderBy?: SourceHashOrderByWithRelationInput | SourceHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceHashes.
     */
    cursor?: SourceHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceHashes.
     */
    distinct?: SourceHashScalarFieldEnum | SourceHashScalarFieldEnum[]
  }

  /**
   * SourceHash findFirstOrThrow
   */
  export type SourceHashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter, which SourceHash to fetch.
     */
    where?: SourceHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceHashes to fetch.
     */
    orderBy?: SourceHashOrderByWithRelationInput | SourceHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceHashes.
     */
    cursor?: SourceHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceHashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceHashes.
     */
    distinct?: SourceHashScalarFieldEnum | SourceHashScalarFieldEnum[]
  }

  /**
   * SourceHash findMany
   */
  export type SourceHashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter, which SourceHashes to fetch.
     */
    where?: SourceHashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceHashes to fetch.
     */
    orderBy?: SourceHashOrderByWithRelationInput | SourceHashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceHashes.
     */
    cursor?: SourceHashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceHashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceHashes.
     */
    skip?: number
    distinct?: SourceHashScalarFieldEnum | SourceHashScalarFieldEnum[]
  }

  /**
   * SourceHash create
   */
  export type SourceHashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceHash.
     */
    data: XOR<SourceHashCreateInput, SourceHashUncheckedCreateInput>
  }

  /**
   * SourceHash createMany
   */
  export type SourceHashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceHashes.
     */
    data: SourceHashCreateManyInput | SourceHashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceHash createManyAndReturn
   */
  export type SourceHashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * The data used to create many SourceHashes.
     */
    data: SourceHashCreateManyInput | SourceHashCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceHash update
   */
  export type SourceHashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceHash.
     */
    data: XOR<SourceHashUpdateInput, SourceHashUncheckedUpdateInput>
    /**
     * Choose, which SourceHash to update.
     */
    where: SourceHashWhereUniqueInput
  }

  /**
   * SourceHash updateMany
   */
  export type SourceHashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceHashes.
     */
    data: XOR<SourceHashUpdateManyMutationInput, SourceHashUncheckedUpdateManyInput>
    /**
     * Filter which SourceHashes to update
     */
    where?: SourceHashWhereInput
    /**
     * Limit how many SourceHashes to update.
     */
    limit?: number
  }

  /**
   * SourceHash updateManyAndReturn
   */
  export type SourceHashUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * The data used to update SourceHashes.
     */
    data: XOR<SourceHashUpdateManyMutationInput, SourceHashUncheckedUpdateManyInput>
    /**
     * Filter which SourceHashes to update
     */
    where?: SourceHashWhereInput
    /**
     * Limit how many SourceHashes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceHash upsert
   */
  export type SourceHashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceHash to update in case it exists.
     */
    where: SourceHashWhereUniqueInput
    /**
     * In case the SourceHash found by the `where` argument doesn't exist, create a new SourceHash with this data.
     */
    create: XOR<SourceHashCreateInput, SourceHashUncheckedCreateInput>
    /**
     * In case the SourceHash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceHashUpdateInput, SourceHashUncheckedUpdateInput>
  }

  /**
   * SourceHash delete
   */
  export type SourceHashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
    /**
     * Filter which SourceHash to delete.
     */
    where: SourceHashWhereUniqueInput
  }

  /**
   * SourceHash deleteMany
   */
  export type SourceHashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceHashes to delete
     */
    where?: SourceHashWhereInput
    /**
     * Limit how many SourceHashes to delete.
     */
    limit?: number
  }

  /**
   * SourceHash without action
   */
  export type SourceHashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceHash
     */
    select?: SourceHashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceHash
     */
    omit?: SourceHashOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceHashInclude<ExtArgs> | null
  }


  /**
   * Model SourceLink
   */

  export type AggregateSourceLink = {
    _count: SourceLinkCountAggregateOutputType | null
    _avg: SourceLinkAvgAggregateOutputType | null
    _sum: SourceLinkSumAggregateOutputType | null
    _min: SourceLinkMinAggregateOutputType | null
    _max: SourceLinkMaxAggregateOutputType | null
  }

  export type SourceLinkAvgAggregateOutputType = {
    source_id: number | null
  }

  export type SourceLinkSumAggregateOutputType = {
    source_id: number | null
  }

  export type SourceLinkMinAggregateOutputType = {
    source_id: number | null
    url: string | null
    active: boolean | null
  }

  export type SourceLinkMaxAggregateOutputType = {
    source_id: number | null
    url: string | null
    active: boolean | null
  }

  export type SourceLinkCountAggregateOutputType = {
    source_id: number
    url: number
    active: number
    _all: number
  }


  export type SourceLinkAvgAggregateInputType = {
    source_id?: true
  }

  export type SourceLinkSumAggregateInputType = {
    source_id?: true
  }

  export type SourceLinkMinAggregateInputType = {
    source_id?: true
    url?: true
    active?: true
  }

  export type SourceLinkMaxAggregateInputType = {
    source_id?: true
    url?: true
    active?: true
  }

  export type SourceLinkCountAggregateInputType = {
    source_id?: true
    url?: true
    active?: true
    _all?: true
  }

  export type SourceLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceLink to aggregate.
     */
    where?: SourceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceLinks to fetch.
     */
    orderBy?: SourceLinkOrderByWithRelationInput | SourceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceLinks
    **/
    _count?: true | SourceLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceLinkMaxAggregateInputType
  }

  export type GetSourceLinkAggregateType<T extends SourceLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceLink[P]>
      : GetScalarType<T[P], AggregateSourceLink[P]>
  }




  export type SourceLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceLinkWhereInput
    orderBy?: SourceLinkOrderByWithAggregationInput | SourceLinkOrderByWithAggregationInput[]
    by: SourceLinkScalarFieldEnum[] | SourceLinkScalarFieldEnum
    having?: SourceLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceLinkCountAggregateInputType | true
    _avg?: SourceLinkAvgAggregateInputType
    _sum?: SourceLinkSumAggregateInputType
    _min?: SourceLinkMinAggregateInputType
    _max?: SourceLinkMaxAggregateInputType
  }

  export type SourceLinkGroupByOutputType = {
    source_id: number
    url: string
    active: boolean | null
    _count: SourceLinkCountAggregateOutputType | null
    _avg: SourceLinkAvgAggregateOutputType | null
    _sum: SourceLinkSumAggregateOutputType | null
    _min: SourceLinkMinAggregateOutputType | null
    _max: SourceLinkMaxAggregateOutputType | null
  }

  type GetSourceLinkGroupByPayload<T extends SourceLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SourceLinkGroupByOutputType[P]>
        }
      >
    >


  export type SourceLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    url?: boolean
    active?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceLink"]>

  export type SourceLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    url?: boolean
    active?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceLink"]>

  export type SourceLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    url?: boolean
    active?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceLink"]>

  export type SourceLinkSelectScalar = {
    source_id?: boolean
    url?: boolean
    active?: boolean
  }

  export type SourceLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"source_id" | "url" | "active", ExtArgs["result"]["sourceLink"]>
  export type SourceLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourceLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourceLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }

  export type $SourceLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceLink"
    objects: {
      SourceEntry: Prisma.$SourceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      source_id: number
      url: string
      active: boolean | null
    }, ExtArgs["result"]["sourceLink"]>
    composites: {}
  }

  type SourceLinkGetPayload<S extends boolean | null | undefined | SourceLinkDefaultArgs> = $Result.GetResult<Prisma.$SourceLinkPayload, S>

  type SourceLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceLinkCountAggregateInputType | true
    }

  export interface SourceLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceLink'], meta: { name: 'SourceLink' } }
    /**
     * Find zero or one SourceLink that matches the filter.
     * @param {SourceLinkFindUniqueArgs} args - Arguments to find a SourceLink
     * @example
     * // Get one SourceLink
     * const sourceLink = await prisma.sourceLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceLinkFindUniqueArgs>(args: SelectSubset<T, SourceLinkFindUniqueArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceLinkFindUniqueOrThrowArgs} args - Arguments to find a SourceLink
     * @example
     * // Get one SourceLink
     * const sourceLink = await prisma.sourceLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkFindFirstArgs} args - Arguments to find a SourceLink
     * @example
     * // Get one SourceLink
     * const sourceLink = await prisma.sourceLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceLinkFindFirstArgs>(args?: SelectSubset<T, SourceLinkFindFirstArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkFindFirstOrThrowArgs} args - Arguments to find a SourceLink
     * @example
     * // Get one SourceLink
     * const sourceLink = await prisma.sourceLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceLinks
     * const sourceLinks = await prisma.sourceLink.findMany()
     * 
     * // Get first 10 SourceLinks
     * const sourceLinks = await prisma.sourceLink.findMany({ take: 10 })
     * 
     * // Only select the `source_id`
     * const sourceLinkWithSource_idOnly = await prisma.sourceLink.findMany({ select: { source_id: true } })
     * 
     */
    findMany<T extends SourceLinkFindManyArgs>(args?: SelectSubset<T, SourceLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceLink.
     * @param {SourceLinkCreateArgs} args - Arguments to create a SourceLink.
     * @example
     * // Create one SourceLink
     * const SourceLink = await prisma.sourceLink.create({
     *   data: {
     *     // ... data to create a SourceLink
     *   }
     * })
     * 
     */
    create<T extends SourceLinkCreateArgs>(args: SelectSubset<T, SourceLinkCreateArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceLinks.
     * @param {SourceLinkCreateManyArgs} args - Arguments to create many SourceLinks.
     * @example
     * // Create many SourceLinks
     * const sourceLink = await prisma.sourceLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceLinkCreateManyArgs>(args?: SelectSubset<T, SourceLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceLinks and returns the data saved in the database.
     * @param {SourceLinkCreateManyAndReturnArgs} args - Arguments to create many SourceLinks.
     * @example
     * // Create many SourceLinks
     * const sourceLink = await prisma.sourceLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceLinks and only return the `source_id`
     * const sourceLinkWithSource_idOnly = await prisma.sourceLink.createManyAndReturn({
     *   select: { source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceLink.
     * @param {SourceLinkDeleteArgs} args - Arguments to delete one SourceLink.
     * @example
     * // Delete one SourceLink
     * const SourceLink = await prisma.sourceLink.delete({
     *   where: {
     *     // ... filter to delete one SourceLink
     *   }
     * })
     * 
     */
    delete<T extends SourceLinkDeleteArgs>(args: SelectSubset<T, SourceLinkDeleteArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceLink.
     * @param {SourceLinkUpdateArgs} args - Arguments to update one SourceLink.
     * @example
     * // Update one SourceLink
     * const sourceLink = await prisma.sourceLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceLinkUpdateArgs>(args: SelectSubset<T, SourceLinkUpdateArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceLinks.
     * @param {SourceLinkDeleteManyArgs} args - Arguments to filter SourceLinks to delete.
     * @example
     * // Delete a few SourceLinks
     * const { count } = await prisma.sourceLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceLinkDeleteManyArgs>(args?: SelectSubset<T, SourceLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceLinks
     * const sourceLink = await prisma.sourceLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceLinkUpdateManyArgs>(args: SelectSubset<T, SourceLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceLinks and returns the data updated in the database.
     * @param {SourceLinkUpdateManyAndReturnArgs} args - Arguments to update many SourceLinks.
     * @example
     * // Update many SourceLinks
     * const sourceLink = await prisma.sourceLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceLinks and only return the `source_id`
     * const sourceLinkWithSource_idOnly = await prisma.sourceLink.updateManyAndReturn({
     *   select: { source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceLink.
     * @param {SourceLinkUpsertArgs} args - Arguments to update or create a SourceLink.
     * @example
     * // Update or create a SourceLink
     * const sourceLink = await prisma.sourceLink.upsert({
     *   create: {
     *     // ... data to create a SourceLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceLink we want to update
     *   }
     * })
     */
    upsert<T extends SourceLinkUpsertArgs>(args: SelectSubset<T, SourceLinkUpsertArgs<ExtArgs>>): Prisma__SourceLinkClient<$Result.GetResult<Prisma.$SourceLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkCountArgs} args - Arguments to filter SourceLinks to count.
     * @example
     * // Count the number of SourceLinks
     * const count = await prisma.sourceLink.count({
     *   where: {
     *     // ... the filter for the SourceLinks we want to count
     *   }
     * })
    **/
    count<T extends SourceLinkCountArgs>(
      args?: Subset<T, SourceLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceLinkAggregateArgs>(args: Subset<T, SourceLinkAggregateArgs>): Prisma.PrismaPromise<GetSourceLinkAggregateType<T>>

    /**
     * Group by SourceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceLinkGroupByArgs['orderBy'] }
        : { orderBy?: SourceLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceLink model
   */
  readonly fields: SourceLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SourceEntry<T extends SourceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntryDefaultArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceLink model
   */
  interface SourceLinkFieldRefs {
    readonly source_id: FieldRef<"SourceLink", 'Int'>
    readonly url: FieldRef<"SourceLink", 'String'>
    readonly active: FieldRef<"SourceLink", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SourceLink findUnique
   */
  export type SourceLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceLink to fetch.
     */
    where: SourceLinkWhereUniqueInput
  }

  /**
   * SourceLink findUniqueOrThrow
   */
  export type SourceLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceLink to fetch.
     */
    where: SourceLinkWhereUniqueInput
  }

  /**
   * SourceLink findFirst
   */
  export type SourceLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceLink to fetch.
     */
    where?: SourceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceLinks to fetch.
     */
    orderBy?: SourceLinkOrderByWithRelationInput | SourceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceLinks.
     */
    cursor?: SourceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceLinks.
     */
    distinct?: SourceLinkScalarFieldEnum | SourceLinkScalarFieldEnum[]
  }

  /**
   * SourceLink findFirstOrThrow
   */
  export type SourceLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceLink to fetch.
     */
    where?: SourceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceLinks to fetch.
     */
    orderBy?: SourceLinkOrderByWithRelationInput | SourceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceLinks.
     */
    cursor?: SourceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceLinks.
     */
    distinct?: SourceLinkScalarFieldEnum | SourceLinkScalarFieldEnum[]
  }

  /**
   * SourceLink findMany
   */
  export type SourceLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter, which SourceLinks to fetch.
     */
    where?: SourceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceLinks to fetch.
     */
    orderBy?: SourceLinkOrderByWithRelationInput | SourceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceLinks.
     */
    cursor?: SourceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceLinks.
     */
    skip?: number
    distinct?: SourceLinkScalarFieldEnum | SourceLinkScalarFieldEnum[]
  }

  /**
   * SourceLink create
   */
  export type SourceLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceLink.
     */
    data: XOR<SourceLinkCreateInput, SourceLinkUncheckedCreateInput>
  }

  /**
   * SourceLink createMany
   */
  export type SourceLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceLinks.
     */
    data: SourceLinkCreateManyInput | SourceLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceLink createManyAndReturn
   */
  export type SourceLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SourceLinks.
     */
    data: SourceLinkCreateManyInput | SourceLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceLink update
   */
  export type SourceLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceLink.
     */
    data: XOR<SourceLinkUpdateInput, SourceLinkUncheckedUpdateInput>
    /**
     * Choose, which SourceLink to update.
     */
    where: SourceLinkWhereUniqueInput
  }

  /**
   * SourceLink updateMany
   */
  export type SourceLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceLinks.
     */
    data: XOR<SourceLinkUpdateManyMutationInput, SourceLinkUncheckedUpdateManyInput>
    /**
     * Filter which SourceLinks to update
     */
    where?: SourceLinkWhereInput
    /**
     * Limit how many SourceLinks to update.
     */
    limit?: number
  }

  /**
   * SourceLink updateManyAndReturn
   */
  export type SourceLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * The data used to update SourceLinks.
     */
    data: XOR<SourceLinkUpdateManyMutationInput, SourceLinkUncheckedUpdateManyInput>
    /**
     * Filter which SourceLinks to update
     */
    where?: SourceLinkWhereInput
    /**
     * Limit how many SourceLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceLink upsert
   */
  export type SourceLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceLink to update in case it exists.
     */
    where: SourceLinkWhereUniqueInput
    /**
     * In case the SourceLink found by the `where` argument doesn't exist, create a new SourceLink with this data.
     */
    create: XOR<SourceLinkCreateInput, SourceLinkUncheckedCreateInput>
    /**
     * In case the SourceLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceLinkUpdateInput, SourceLinkUncheckedUpdateInput>
  }

  /**
   * SourceLink delete
   */
  export type SourceLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
    /**
     * Filter which SourceLink to delete.
     */
    where: SourceLinkWhereUniqueInput
  }

  /**
   * SourceLink deleteMany
   */
  export type SourceLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceLinks to delete
     */
    where?: SourceLinkWhereInput
    /**
     * Limit how many SourceLinks to delete.
     */
    limit?: number
  }

  /**
   * SourceLink without action
   */
  export type SourceLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceLink
     */
    select?: SourceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceLink
     */
    omit?: SourceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceLinkInclude<ExtArgs> | null
  }


  /**
   * Model SourceMapDevice
   */

  export type AggregateSourceMapDevice = {
    _count: SourceMapDeviceCountAggregateOutputType | null
    _avg: SourceMapDeviceAvgAggregateOutputType | null
    _sum: SourceMapDeviceSumAggregateOutputType | null
    _min: SourceMapDeviceMinAggregateOutputType | null
    _max: SourceMapDeviceMaxAggregateOutputType | null
  }

  export type SourceMapDeviceAvgAggregateOutputType = {
    source_id: number | null
    device_id: number | null
  }

  export type SourceMapDeviceSumAggregateOutputType = {
    source_id: number | null
    device_id: number | null
  }

  export type SourceMapDeviceMinAggregateOutputType = {
    source_id: number | null
    device_id: number | null
  }

  export type SourceMapDeviceMaxAggregateOutputType = {
    source_id: number | null
    device_id: number | null
  }

  export type SourceMapDeviceCountAggregateOutputType = {
    source_id: number
    device_id: number
    _all: number
  }


  export type SourceMapDeviceAvgAggregateInputType = {
    source_id?: true
    device_id?: true
  }

  export type SourceMapDeviceSumAggregateInputType = {
    source_id?: true
    device_id?: true
  }

  export type SourceMapDeviceMinAggregateInputType = {
    source_id?: true
    device_id?: true
  }

  export type SourceMapDeviceMaxAggregateInputType = {
    source_id?: true
    device_id?: true
  }

  export type SourceMapDeviceCountAggregateInputType = {
    source_id?: true
    device_id?: true
    _all?: true
  }

  export type SourceMapDeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceMapDevice to aggregate.
     */
    where?: SourceMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapDevices to fetch.
     */
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceMapDevices
    **/
    _count?: true | SourceMapDeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceMapDeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceMapDeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMapDeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMapDeviceMaxAggregateInputType
  }

  export type GetSourceMapDeviceAggregateType<T extends SourceMapDeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceMapDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceMapDevice[P]>
      : GetScalarType<T[P], AggregateSourceMapDevice[P]>
  }




  export type SourceMapDeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceMapDeviceWhereInput
    orderBy?: SourceMapDeviceOrderByWithAggregationInput | SourceMapDeviceOrderByWithAggregationInput[]
    by: SourceMapDeviceScalarFieldEnum[] | SourceMapDeviceScalarFieldEnum
    having?: SourceMapDeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceMapDeviceCountAggregateInputType | true
    _avg?: SourceMapDeviceAvgAggregateInputType
    _sum?: SourceMapDeviceSumAggregateInputType
    _min?: SourceMapDeviceMinAggregateInputType
    _max?: SourceMapDeviceMaxAggregateInputType
  }

  export type SourceMapDeviceGroupByOutputType = {
    source_id: number
    device_id: number
    _count: SourceMapDeviceCountAggregateOutputType | null
    _avg: SourceMapDeviceAvgAggregateOutputType | null
    _sum: SourceMapDeviceSumAggregateOutputType | null
    _min: SourceMapDeviceMinAggregateOutputType | null
    _max: SourceMapDeviceMaxAggregateOutputType | null
  }

  type GetSourceMapDeviceGroupByPayload<T extends SourceMapDeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceMapDeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceMapDeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceMapDeviceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceMapDeviceGroupByOutputType[P]>
        }
      >
    >


  export type SourceMapDeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    device_id?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceMapDevice"]>

  export type SourceMapDeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    device_id?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceMapDevice"]>

  export type SourceMapDeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    device_id?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceMapDevice"]>

  export type SourceMapDeviceSelectScalar = {
    source_id?: boolean
    device_id?: boolean
  }

  export type SourceMapDeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"source_id" | "device_id", ExtArgs["result"]["sourceMapDevice"]>
  export type SourceMapDeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type SourceMapDeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }
  export type SourceMapDeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
    DeviceEntry?: boolean | DeviceEntryDefaultArgs<ExtArgs>
  }

  export type $SourceMapDevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceMapDevice"
    objects: {
      SourceEntry: Prisma.$SourceEntryPayload<ExtArgs>
      DeviceEntry: Prisma.$DeviceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      source_id: number
      device_id: number
    }, ExtArgs["result"]["sourceMapDevice"]>
    composites: {}
  }

  type SourceMapDeviceGetPayload<S extends boolean | null | undefined | SourceMapDeviceDefaultArgs> = $Result.GetResult<Prisma.$SourceMapDevicePayload, S>

  type SourceMapDeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceMapDeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceMapDeviceCountAggregateInputType | true
    }

  export interface SourceMapDeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceMapDevice'], meta: { name: 'SourceMapDevice' } }
    /**
     * Find zero or one SourceMapDevice that matches the filter.
     * @param {SourceMapDeviceFindUniqueArgs} args - Arguments to find a SourceMapDevice
     * @example
     * // Get one SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceMapDeviceFindUniqueArgs>(args: SelectSubset<T, SourceMapDeviceFindUniqueArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceMapDevice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceMapDeviceFindUniqueOrThrowArgs} args - Arguments to find a SourceMapDevice
     * @example
     * // Get one SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceMapDeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceMapDeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceMapDevice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceFindFirstArgs} args - Arguments to find a SourceMapDevice
     * @example
     * // Get one SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceMapDeviceFindFirstArgs>(args?: SelectSubset<T, SourceMapDeviceFindFirstArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceMapDevice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceFindFirstOrThrowArgs} args - Arguments to find a SourceMapDevice
     * @example
     * // Get one SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceMapDeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceMapDeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceMapDevices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceMapDevices
     * const sourceMapDevices = await prisma.sourceMapDevice.findMany()
     * 
     * // Get first 10 SourceMapDevices
     * const sourceMapDevices = await prisma.sourceMapDevice.findMany({ take: 10 })
     * 
     * // Only select the `source_id`
     * const sourceMapDeviceWithSource_idOnly = await prisma.sourceMapDevice.findMany({ select: { source_id: true } })
     * 
     */
    findMany<T extends SourceMapDeviceFindManyArgs>(args?: SelectSubset<T, SourceMapDeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceMapDevice.
     * @param {SourceMapDeviceCreateArgs} args - Arguments to create a SourceMapDevice.
     * @example
     * // Create one SourceMapDevice
     * const SourceMapDevice = await prisma.sourceMapDevice.create({
     *   data: {
     *     // ... data to create a SourceMapDevice
     *   }
     * })
     * 
     */
    create<T extends SourceMapDeviceCreateArgs>(args: SelectSubset<T, SourceMapDeviceCreateArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceMapDevices.
     * @param {SourceMapDeviceCreateManyArgs} args - Arguments to create many SourceMapDevices.
     * @example
     * // Create many SourceMapDevices
     * const sourceMapDevice = await prisma.sourceMapDevice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceMapDeviceCreateManyArgs>(args?: SelectSubset<T, SourceMapDeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceMapDevices and returns the data saved in the database.
     * @param {SourceMapDeviceCreateManyAndReturnArgs} args - Arguments to create many SourceMapDevices.
     * @example
     * // Create many SourceMapDevices
     * const sourceMapDevice = await prisma.sourceMapDevice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceMapDevices and only return the `source_id`
     * const sourceMapDeviceWithSource_idOnly = await prisma.sourceMapDevice.createManyAndReturn({
     *   select: { source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceMapDeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceMapDeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceMapDevice.
     * @param {SourceMapDeviceDeleteArgs} args - Arguments to delete one SourceMapDevice.
     * @example
     * // Delete one SourceMapDevice
     * const SourceMapDevice = await prisma.sourceMapDevice.delete({
     *   where: {
     *     // ... filter to delete one SourceMapDevice
     *   }
     * })
     * 
     */
    delete<T extends SourceMapDeviceDeleteArgs>(args: SelectSubset<T, SourceMapDeviceDeleteArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceMapDevice.
     * @param {SourceMapDeviceUpdateArgs} args - Arguments to update one SourceMapDevice.
     * @example
     * // Update one SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceMapDeviceUpdateArgs>(args: SelectSubset<T, SourceMapDeviceUpdateArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceMapDevices.
     * @param {SourceMapDeviceDeleteManyArgs} args - Arguments to filter SourceMapDevices to delete.
     * @example
     * // Delete a few SourceMapDevices
     * const { count } = await prisma.sourceMapDevice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceMapDeviceDeleteManyArgs>(args?: SelectSubset<T, SourceMapDeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceMapDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceMapDevices
     * const sourceMapDevice = await prisma.sourceMapDevice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceMapDeviceUpdateManyArgs>(args: SelectSubset<T, SourceMapDeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceMapDevices and returns the data updated in the database.
     * @param {SourceMapDeviceUpdateManyAndReturnArgs} args - Arguments to update many SourceMapDevices.
     * @example
     * // Update many SourceMapDevices
     * const sourceMapDevice = await prisma.sourceMapDevice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceMapDevices and only return the `source_id`
     * const sourceMapDeviceWithSource_idOnly = await prisma.sourceMapDevice.updateManyAndReturn({
     *   select: { source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceMapDeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceMapDeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceMapDevice.
     * @param {SourceMapDeviceUpsertArgs} args - Arguments to update or create a SourceMapDevice.
     * @example
     * // Update or create a SourceMapDevice
     * const sourceMapDevice = await prisma.sourceMapDevice.upsert({
     *   create: {
     *     // ... data to create a SourceMapDevice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceMapDevice we want to update
     *   }
     * })
     */
    upsert<T extends SourceMapDeviceUpsertArgs>(args: SelectSubset<T, SourceMapDeviceUpsertArgs<ExtArgs>>): Prisma__SourceMapDeviceClient<$Result.GetResult<Prisma.$SourceMapDevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceMapDevices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceCountArgs} args - Arguments to filter SourceMapDevices to count.
     * @example
     * // Count the number of SourceMapDevices
     * const count = await prisma.sourceMapDevice.count({
     *   where: {
     *     // ... the filter for the SourceMapDevices we want to count
     *   }
     * })
    **/
    count<T extends SourceMapDeviceCountArgs>(
      args?: Subset<T, SourceMapDeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceMapDeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceMapDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceMapDeviceAggregateArgs>(args: Subset<T, SourceMapDeviceAggregateArgs>): Prisma.PrismaPromise<GetSourceMapDeviceAggregateType<T>>

    /**
     * Group by SourceMapDevice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapDeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceMapDeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceMapDeviceGroupByArgs['orderBy'] }
        : { orderBy?: SourceMapDeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceMapDeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceMapDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceMapDevice model
   */
  readonly fields: SourceMapDeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceMapDevice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceMapDeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SourceEntry<T extends SourceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntryDefaultArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DeviceEntry<T extends DeviceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviceEntryDefaultArgs<ExtArgs>>): Prisma__DeviceEntryClient<$Result.GetResult<Prisma.$DeviceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceMapDevice model
   */
  interface SourceMapDeviceFieldRefs {
    readonly source_id: FieldRef<"SourceMapDevice", 'Int'>
    readonly device_id: FieldRef<"SourceMapDevice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SourceMapDevice findUnique
   */
  export type SourceMapDeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which SourceMapDevice to fetch.
     */
    where: SourceMapDeviceWhereUniqueInput
  }

  /**
   * SourceMapDevice findUniqueOrThrow
   */
  export type SourceMapDeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which SourceMapDevice to fetch.
     */
    where: SourceMapDeviceWhereUniqueInput
  }

  /**
   * SourceMapDevice findFirst
   */
  export type SourceMapDeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which SourceMapDevice to fetch.
     */
    where?: SourceMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapDevices to fetch.
     */
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceMapDevices.
     */
    cursor?: SourceMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceMapDevices.
     */
    distinct?: SourceMapDeviceScalarFieldEnum | SourceMapDeviceScalarFieldEnum[]
  }

  /**
   * SourceMapDevice findFirstOrThrow
   */
  export type SourceMapDeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which SourceMapDevice to fetch.
     */
    where?: SourceMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapDevices to fetch.
     */
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceMapDevices.
     */
    cursor?: SourceMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapDevices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceMapDevices.
     */
    distinct?: SourceMapDeviceScalarFieldEnum | SourceMapDeviceScalarFieldEnum[]
  }

  /**
   * SourceMapDevice findMany
   */
  export type SourceMapDeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter, which SourceMapDevices to fetch.
     */
    where?: SourceMapDeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapDevices to fetch.
     */
    orderBy?: SourceMapDeviceOrderByWithRelationInput | SourceMapDeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceMapDevices.
     */
    cursor?: SourceMapDeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapDevices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapDevices.
     */
    skip?: number
    distinct?: SourceMapDeviceScalarFieldEnum | SourceMapDeviceScalarFieldEnum[]
  }

  /**
   * SourceMapDevice create
   */
  export type SourceMapDeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceMapDevice.
     */
    data: XOR<SourceMapDeviceCreateInput, SourceMapDeviceUncheckedCreateInput>
  }

  /**
   * SourceMapDevice createMany
   */
  export type SourceMapDeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceMapDevices.
     */
    data: SourceMapDeviceCreateManyInput | SourceMapDeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceMapDevice createManyAndReturn
   */
  export type SourceMapDeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * The data used to create many SourceMapDevices.
     */
    data: SourceMapDeviceCreateManyInput | SourceMapDeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceMapDevice update
   */
  export type SourceMapDeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceMapDevice.
     */
    data: XOR<SourceMapDeviceUpdateInput, SourceMapDeviceUncheckedUpdateInput>
    /**
     * Choose, which SourceMapDevice to update.
     */
    where: SourceMapDeviceWhereUniqueInput
  }

  /**
   * SourceMapDevice updateMany
   */
  export type SourceMapDeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceMapDevices.
     */
    data: XOR<SourceMapDeviceUpdateManyMutationInput, SourceMapDeviceUncheckedUpdateManyInput>
    /**
     * Filter which SourceMapDevices to update
     */
    where?: SourceMapDeviceWhereInput
    /**
     * Limit how many SourceMapDevices to update.
     */
    limit?: number
  }

  /**
   * SourceMapDevice updateManyAndReturn
   */
  export type SourceMapDeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * The data used to update SourceMapDevices.
     */
    data: XOR<SourceMapDeviceUpdateManyMutationInput, SourceMapDeviceUncheckedUpdateManyInput>
    /**
     * Filter which SourceMapDevices to update
     */
    where?: SourceMapDeviceWhereInput
    /**
     * Limit how many SourceMapDevices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceMapDevice upsert
   */
  export type SourceMapDeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceMapDevice to update in case it exists.
     */
    where: SourceMapDeviceWhereUniqueInput
    /**
     * In case the SourceMapDevice found by the `where` argument doesn't exist, create a new SourceMapDevice with this data.
     */
    create: XOR<SourceMapDeviceCreateInput, SourceMapDeviceUncheckedCreateInput>
    /**
     * In case the SourceMapDevice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceMapDeviceUpdateInput, SourceMapDeviceUncheckedUpdateInput>
  }

  /**
   * SourceMapDevice delete
   */
  export type SourceMapDeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
    /**
     * Filter which SourceMapDevice to delete.
     */
    where: SourceMapDeviceWhereUniqueInput
  }

  /**
   * SourceMapDevice deleteMany
   */
  export type SourceMapDeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceMapDevices to delete
     */
    where?: SourceMapDeviceWhereInput
    /**
     * Limit how many SourceMapDevices to delete.
     */
    limit?: number
  }

  /**
   * SourceMapDevice without action
   */
  export type SourceMapDeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapDevice
     */
    select?: SourceMapDeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapDevice
     */
    omit?: SourceMapDeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceMapDeviceInclude<ExtArgs> | null
  }


  /**
   * Model SourceMapOsString
   */

  export type AggregateSourceMapOsString = {
    _count: SourceMapOsStringCountAggregateOutputType | null
    _avg: SourceMapOsStringAvgAggregateOutputType | null
    _sum: SourceMapOsStringSumAggregateOutputType | null
    _min: SourceMapOsStringMinAggregateOutputType | null
    _max: SourceMapOsStringMaxAggregateOutputType | null
  }

  export type SourceMapOsStringAvgAggregateOutputType = {
    source_id: number | null
  }

  export type SourceMapOsStringSumAggregateOutputType = {
    source_id: number | null
  }

  export type SourceMapOsStringMinAggregateOutputType = {
    source_id: number | null
    os_string: string | null
  }

  export type SourceMapOsStringMaxAggregateOutputType = {
    source_id: number | null
    os_string: string | null
  }

  export type SourceMapOsStringCountAggregateOutputType = {
    source_id: number
    os_string: number
    _all: number
  }


  export type SourceMapOsStringAvgAggregateInputType = {
    source_id?: true
  }

  export type SourceMapOsStringSumAggregateInputType = {
    source_id?: true
  }

  export type SourceMapOsStringMinAggregateInputType = {
    source_id?: true
    os_string?: true
  }

  export type SourceMapOsStringMaxAggregateInputType = {
    source_id?: true
    os_string?: true
  }

  export type SourceMapOsStringCountAggregateInputType = {
    source_id?: true
    os_string?: true
    _all?: true
  }

  export type SourceMapOsStringAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceMapOsString to aggregate.
     */
    where?: SourceMapOsStringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapOsStrings to fetch.
     */
    orderBy?: SourceMapOsStringOrderByWithRelationInput | SourceMapOsStringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceMapOsStringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapOsStrings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapOsStrings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceMapOsStrings
    **/
    _count?: true | SourceMapOsStringCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceMapOsStringAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceMapOsStringSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMapOsStringMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMapOsStringMaxAggregateInputType
  }

  export type GetSourceMapOsStringAggregateType<T extends SourceMapOsStringAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceMapOsString]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceMapOsString[P]>
      : GetScalarType<T[P], AggregateSourceMapOsString[P]>
  }




  export type SourceMapOsStringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceMapOsStringWhereInput
    orderBy?: SourceMapOsStringOrderByWithAggregationInput | SourceMapOsStringOrderByWithAggregationInput[]
    by: SourceMapOsStringScalarFieldEnum[] | SourceMapOsStringScalarFieldEnum
    having?: SourceMapOsStringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceMapOsStringCountAggregateInputType | true
    _avg?: SourceMapOsStringAvgAggregateInputType
    _sum?: SourceMapOsStringSumAggregateInputType
    _min?: SourceMapOsStringMinAggregateInputType
    _max?: SourceMapOsStringMaxAggregateInputType
  }

  export type SourceMapOsStringGroupByOutputType = {
    source_id: number
    os_string: string
    _count: SourceMapOsStringCountAggregateOutputType | null
    _avg: SourceMapOsStringAvgAggregateOutputType | null
    _sum: SourceMapOsStringSumAggregateOutputType | null
    _min: SourceMapOsStringMinAggregateOutputType | null
    _max: SourceMapOsStringMaxAggregateOutputType | null
  }

  type GetSourceMapOsStringGroupByPayload<T extends SourceMapOsStringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceMapOsStringGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceMapOsStringGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceMapOsStringGroupByOutputType[P]>
            : GetScalarType<T[P], SourceMapOsStringGroupByOutputType[P]>
        }
      >
    >


  export type SourceMapOsStringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    os_string?: boolean
  }, ExtArgs["result"]["sourceMapOsString"]>

  export type SourceMapOsStringSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    os_string?: boolean
  }, ExtArgs["result"]["sourceMapOsString"]>

  export type SourceMapOsStringSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    os_string?: boolean
  }, ExtArgs["result"]["sourceMapOsString"]>

  export type SourceMapOsStringSelectScalar = {
    source_id?: boolean
    os_string?: boolean
  }

  export type SourceMapOsStringOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"source_id" | "os_string", ExtArgs["result"]["sourceMapOsString"]>

  export type $SourceMapOsStringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceMapOsString"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      source_id: number
      os_string: string
    }, ExtArgs["result"]["sourceMapOsString"]>
    composites: {}
  }

  type SourceMapOsStringGetPayload<S extends boolean | null | undefined | SourceMapOsStringDefaultArgs> = $Result.GetResult<Prisma.$SourceMapOsStringPayload, S>

  type SourceMapOsStringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceMapOsStringFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceMapOsStringCountAggregateInputType | true
    }

  export interface SourceMapOsStringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceMapOsString'], meta: { name: 'SourceMapOsString' } }
    /**
     * Find zero or one SourceMapOsString that matches the filter.
     * @param {SourceMapOsStringFindUniqueArgs} args - Arguments to find a SourceMapOsString
     * @example
     * // Get one SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceMapOsStringFindUniqueArgs>(args: SelectSubset<T, SourceMapOsStringFindUniqueArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceMapOsString that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceMapOsStringFindUniqueOrThrowArgs} args - Arguments to find a SourceMapOsString
     * @example
     * // Get one SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceMapOsStringFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceMapOsStringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceMapOsString that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringFindFirstArgs} args - Arguments to find a SourceMapOsString
     * @example
     * // Get one SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceMapOsStringFindFirstArgs>(args?: SelectSubset<T, SourceMapOsStringFindFirstArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceMapOsString that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringFindFirstOrThrowArgs} args - Arguments to find a SourceMapOsString
     * @example
     * // Get one SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceMapOsStringFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceMapOsStringFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceMapOsStrings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceMapOsStrings
     * const sourceMapOsStrings = await prisma.sourceMapOsString.findMany()
     * 
     * // Get first 10 SourceMapOsStrings
     * const sourceMapOsStrings = await prisma.sourceMapOsString.findMany({ take: 10 })
     * 
     * // Only select the `source_id`
     * const sourceMapOsStringWithSource_idOnly = await prisma.sourceMapOsString.findMany({ select: { source_id: true } })
     * 
     */
    findMany<T extends SourceMapOsStringFindManyArgs>(args?: SelectSubset<T, SourceMapOsStringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceMapOsString.
     * @param {SourceMapOsStringCreateArgs} args - Arguments to create a SourceMapOsString.
     * @example
     * // Create one SourceMapOsString
     * const SourceMapOsString = await prisma.sourceMapOsString.create({
     *   data: {
     *     // ... data to create a SourceMapOsString
     *   }
     * })
     * 
     */
    create<T extends SourceMapOsStringCreateArgs>(args: SelectSubset<T, SourceMapOsStringCreateArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceMapOsStrings.
     * @param {SourceMapOsStringCreateManyArgs} args - Arguments to create many SourceMapOsStrings.
     * @example
     * // Create many SourceMapOsStrings
     * const sourceMapOsString = await prisma.sourceMapOsString.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceMapOsStringCreateManyArgs>(args?: SelectSubset<T, SourceMapOsStringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceMapOsStrings and returns the data saved in the database.
     * @param {SourceMapOsStringCreateManyAndReturnArgs} args - Arguments to create many SourceMapOsStrings.
     * @example
     * // Create many SourceMapOsStrings
     * const sourceMapOsString = await prisma.sourceMapOsString.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceMapOsStrings and only return the `source_id`
     * const sourceMapOsStringWithSource_idOnly = await prisma.sourceMapOsString.createManyAndReturn({
     *   select: { source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceMapOsStringCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceMapOsStringCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceMapOsString.
     * @param {SourceMapOsStringDeleteArgs} args - Arguments to delete one SourceMapOsString.
     * @example
     * // Delete one SourceMapOsString
     * const SourceMapOsString = await prisma.sourceMapOsString.delete({
     *   where: {
     *     // ... filter to delete one SourceMapOsString
     *   }
     * })
     * 
     */
    delete<T extends SourceMapOsStringDeleteArgs>(args: SelectSubset<T, SourceMapOsStringDeleteArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceMapOsString.
     * @param {SourceMapOsStringUpdateArgs} args - Arguments to update one SourceMapOsString.
     * @example
     * // Update one SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceMapOsStringUpdateArgs>(args: SelectSubset<T, SourceMapOsStringUpdateArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceMapOsStrings.
     * @param {SourceMapOsStringDeleteManyArgs} args - Arguments to filter SourceMapOsStrings to delete.
     * @example
     * // Delete a few SourceMapOsStrings
     * const { count } = await prisma.sourceMapOsString.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceMapOsStringDeleteManyArgs>(args?: SelectSubset<T, SourceMapOsStringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceMapOsStrings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceMapOsStrings
     * const sourceMapOsString = await prisma.sourceMapOsString.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceMapOsStringUpdateManyArgs>(args: SelectSubset<T, SourceMapOsStringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceMapOsStrings and returns the data updated in the database.
     * @param {SourceMapOsStringUpdateManyAndReturnArgs} args - Arguments to update many SourceMapOsStrings.
     * @example
     * // Update many SourceMapOsStrings
     * const sourceMapOsString = await prisma.sourceMapOsString.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceMapOsStrings and only return the `source_id`
     * const sourceMapOsStringWithSource_idOnly = await prisma.sourceMapOsString.updateManyAndReturn({
     *   select: { source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceMapOsStringUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceMapOsStringUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceMapOsString.
     * @param {SourceMapOsStringUpsertArgs} args - Arguments to update or create a SourceMapOsString.
     * @example
     * // Update or create a SourceMapOsString
     * const sourceMapOsString = await prisma.sourceMapOsString.upsert({
     *   create: {
     *     // ... data to create a SourceMapOsString
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceMapOsString we want to update
     *   }
     * })
     */
    upsert<T extends SourceMapOsStringUpsertArgs>(args: SelectSubset<T, SourceMapOsStringUpsertArgs<ExtArgs>>): Prisma__SourceMapOsStringClient<$Result.GetResult<Prisma.$SourceMapOsStringPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceMapOsStrings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringCountArgs} args - Arguments to filter SourceMapOsStrings to count.
     * @example
     * // Count the number of SourceMapOsStrings
     * const count = await prisma.sourceMapOsString.count({
     *   where: {
     *     // ... the filter for the SourceMapOsStrings we want to count
     *   }
     * })
    **/
    count<T extends SourceMapOsStringCountArgs>(
      args?: Subset<T, SourceMapOsStringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceMapOsStringCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceMapOsString.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceMapOsStringAggregateArgs>(args: Subset<T, SourceMapOsStringAggregateArgs>): Prisma.PrismaPromise<GetSourceMapOsStringAggregateType<T>>

    /**
     * Group by SourceMapOsString.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceMapOsStringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceMapOsStringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceMapOsStringGroupByArgs['orderBy'] }
        : { orderBy?: SourceMapOsStringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceMapOsStringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceMapOsStringGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceMapOsString model
   */
  readonly fields: SourceMapOsStringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceMapOsString.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceMapOsStringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceMapOsString model
   */
  interface SourceMapOsStringFieldRefs {
    readonly source_id: FieldRef<"SourceMapOsString", 'Int'>
    readonly os_string: FieldRef<"SourceMapOsString", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SourceMapOsString findUnique
   */
  export type SourceMapOsStringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter, which SourceMapOsString to fetch.
     */
    where: SourceMapOsStringWhereUniqueInput
  }

  /**
   * SourceMapOsString findUniqueOrThrow
   */
  export type SourceMapOsStringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter, which SourceMapOsString to fetch.
     */
    where: SourceMapOsStringWhereUniqueInput
  }

  /**
   * SourceMapOsString findFirst
   */
  export type SourceMapOsStringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter, which SourceMapOsString to fetch.
     */
    where?: SourceMapOsStringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapOsStrings to fetch.
     */
    orderBy?: SourceMapOsStringOrderByWithRelationInput | SourceMapOsStringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceMapOsStrings.
     */
    cursor?: SourceMapOsStringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapOsStrings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapOsStrings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceMapOsStrings.
     */
    distinct?: SourceMapOsStringScalarFieldEnum | SourceMapOsStringScalarFieldEnum[]
  }

  /**
   * SourceMapOsString findFirstOrThrow
   */
  export type SourceMapOsStringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter, which SourceMapOsString to fetch.
     */
    where?: SourceMapOsStringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapOsStrings to fetch.
     */
    orderBy?: SourceMapOsStringOrderByWithRelationInput | SourceMapOsStringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceMapOsStrings.
     */
    cursor?: SourceMapOsStringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapOsStrings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapOsStrings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceMapOsStrings.
     */
    distinct?: SourceMapOsStringScalarFieldEnum | SourceMapOsStringScalarFieldEnum[]
  }

  /**
   * SourceMapOsString findMany
   */
  export type SourceMapOsStringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter, which SourceMapOsStrings to fetch.
     */
    where?: SourceMapOsStringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceMapOsStrings to fetch.
     */
    orderBy?: SourceMapOsStringOrderByWithRelationInput | SourceMapOsStringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceMapOsStrings.
     */
    cursor?: SourceMapOsStringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceMapOsStrings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceMapOsStrings.
     */
    skip?: number
    distinct?: SourceMapOsStringScalarFieldEnum | SourceMapOsStringScalarFieldEnum[]
  }

  /**
   * SourceMapOsString create
   */
  export type SourceMapOsStringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * The data needed to create a SourceMapOsString.
     */
    data: XOR<SourceMapOsStringCreateInput, SourceMapOsStringUncheckedCreateInput>
  }

  /**
   * SourceMapOsString createMany
   */
  export type SourceMapOsStringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceMapOsStrings.
     */
    data: SourceMapOsStringCreateManyInput | SourceMapOsStringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceMapOsString createManyAndReturn
   */
  export type SourceMapOsStringCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * The data used to create many SourceMapOsStrings.
     */
    data: SourceMapOsStringCreateManyInput | SourceMapOsStringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceMapOsString update
   */
  export type SourceMapOsStringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * The data needed to update a SourceMapOsString.
     */
    data: XOR<SourceMapOsStringUpdateInput, SourceMapOsStringUncheckedUpdateInput>
    /**
     * Choose, which SourceMapOsString to update.
     */
    where: SourceMapOsStringWhereUniqueInput
  }

  /**
   * SourceMapOsString updateMany
   */
  export type SourceMapOsStringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceMapOsStrings.
     */
    data: XOR<SourceMapOsStringUpdateManyMutationInput, SourceMapOsStringUncheckedUpdateManyInput>
    /**
     * Filter which SourceMapOsStrings to update
     */
    where?: SourceMapOsStringWhereInput
    /**
     * Limit how many SourceMapOsStrings to update.
     */
    limit?: number
  }

  /**
   * SourceMapOsString updateManyAndReturn
   */
  export type SourceMapOsStringUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * The data used to update SourceMapOsStrings.
     */
    data: XOR<SourceMapOsStringUpdateManyMutationInput, SourceMapOsStringUncheckedUpdateManyInput>
    /**
     * Filter which SourceMapOsStrings to update
     */
    where?: SourceMapOsStringWhereInput
    /**
     * Limit how many SourceMapOsStrings to update.
     */
    limit?: number
  }

  /**
   * SourceMapOsString upsert
   */
  export type SourceMapOsStringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * The filter to search for the SourceMapOsString to update in case it exists.
     */
    where: SourceMapOsStringWhereUniqueInput
    /**
     * In case the SourceMapOsString found by the `where` argument doesn't exist, create a new SourceMapOsString with this data.
     */
    create: XOR<SourceMapOsStringCreateInput, SourceMapOsStringUncheckedCreateInput>
    /**
     * In case the SourceMapOsString was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceMapOsStringUpdateInput, SourceMapOsStringUncheckedUpdateInput>
  }

  /**
   * SourceMapOsString delete
   */
  export type SourceMapOsStringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
    /**
     * Filter which SourceMapOsString to delete.
     */
    where: SourceMapOsStringWhereUniqueInput
  }

  /**
   * SourceMapOsString deleteMany
   */
  export type SourceMapOsStringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceMapOsStrings to delete
     */
    where?: SourceMapOsStringWhereInput
    /**
     * Limit how many SourceMapOsStrings to delete.
     */
    limit?: number
  }

  /**
   * SourceMapOsString without action
   */
  export type SourceMapOsStringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceMapOsString
     */
    select?: SourceMapOsStringSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceMapOsString
     */
    omit?: SourceMapOsStringOmit<ExtArgs> | null
  }


  /**
   * Model SourcePrequisiteBuild
   */

  export type AggregateSourcePrequisiteBuild = {
    _count: SourcePrequisiteBuildCountAggregateOutputType | null
    _avg: SourcePrequisiteBuildAvgAggregateOutputType | null
    _sum: SourcePrequisiteBuildSumAggregateOutputType | null
    _min: SourcePrequisiteBuildMinAggregateOutputType | null
    _max: SourcePrequisiteBuildMaxAggregateOutputType | null
  }

  export type SourcePrequisiteBuildAvgAggregateOutputType = {
    source_id: number | null
  }

  export type SourcePrequisiteBuildSumAggregateOutputType = {
    source_id: number | null
  }

  export type SourcePrequisiteBuildMinAggregateOutputType = {
    source_id: number | null
    build: string | null
  }

  export type SourcePrequisiteBuildMaxAggregateOutputType = {
    source_id: number | null
    build: string | null
  }

  export type SourcePrequisiteBuildCountAggregateOutputType = {
    source_id: number
    build: number
    _all: number
  }


  export type SourcePrequisiteBuildAvgAggregateInputType = {
    source_id?: true
  }

  export type SourcePrequisiteBuildSumAggregateInputType = {
    source_id?: true
  }

  export type SourcePrequisiteBuildMinAggregateInputType = {
    source_id?: true
    build?: true
  }

  export type SourcePrequisiteBuildMaxAggregateInputType = {
    source_id?: true
    build?: true
  }

  export type SourcePrequisiteBuildCountAggregateInputType = {
    source_id?: true
    build?: true
    _all?: true
  }

  export type SourcePrequisiteBuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourcePrequisiteBuild to aggregate.
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourcePrequisiteBuilds to fetch.
     */
    orderBy?: SourcePrequisiteBuildOrderByWithRelationInput | SourcePrequisiteBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourcePrequisiteBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourcePrequisiteBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourcePrequisiteBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourcePrequisiteBuilds
    **/
    _count?: true | SourcePrequisiteBuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourcePrequisiteBuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourcePrequisiteBuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourcePrequisiteBuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourcePrequisiteBuildMaxAggregateInputType
  }

  export type GetSourcePrequisiteBuildAggregateType<T extends SourcePrequisiteBuildAggregateArgs> = {
        [P in keyof T & keyof AggregateSourcePrequisiteBuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourcePrequisiteBuild[P]>
      : GetScalarType<T[P], AggregateSourcePrequisiteBuild[P]>
  }




  export type SourcePrequisiteBuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourcePrequisiteBuildWhereInput
    orderBy?: SourcePrequisiteBuildOrderByWithAggregationInput | SourcePrequisiteBuildOrderByWithAggregationInput[]
    by: SourcePrequisiteBuildScalarFieldEnum[] | SourcePrequisiteBuildScalarFieldEnum
    having?: SourcePrequisiteBuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourcePrequisiteBuildCountAggregateInputType | true
    _avg?: SourcePrequisiteBuildAvgAggregateInputType
    _sum?: SourcePrequisiteBuildSumAggregateInputType
    _min?: SourcePrequisiteBuildMinAggregateInputType
    _max?: SourcePrequisiteBuildMaxAggregateInputType
  }

  export type SourcePrequisiteBuildGroupByOutputType = {
    source_id: number
    build: string
    _count: SourcePrequisiteBuildCountAggregateOutputType | null
    _avg: SourcePrequisiteBuildAvgAggregateOutputType | null
    _sum: SourcePrequisiteBuildSumAggregateOutputType | null
    _min: SourcePrequisiteBuildMinAggregateOutputType | null
    _max: SourcePrequisiteBuildMaxAggregateOutputType | null
  }

  type GetSourcePrequisiteBuildGroupByPayload<T extends SourcePrequisiteBuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourcePrequisiteBuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourcePrequisiteBuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourcePrequisiteBuildGroupByOutputType[P]>
            : GetScalarType<T[P], SourcePrequisiteBuildGroupByOutputType[P]>
        }
      >
    >


  export type SourcePrequisiteBuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    build?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourcePrequisiteBuild"]>

  export type SourcePrequisiteBuildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    build?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourcePrequisiteBuild"]>

  export type SourcePrequisiteBuildSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    source_id?: boolean
    build?: boolean
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourcePrequisiteBuild"]>

  export type SourcePrequisiteBuildSelectScalar = {
    source_id?: boolean
    build?: boolean
  }

  export type SourcePrequisiteBuildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"source_id" | "build", ExtArgs["result"]["sourcePrequisiteBuild"]>
  export type SourcePrequisiteBuildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourcePrequisiteBuildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }
  export type SourcePrequisiteBuildIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SourceEntry?: boolean | SourceEntryDefaultArgs<ExtArgs>
  }

  export type $SourcePrequisiteBuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourcePrequisiteBuild"
    objects: {
      SourceEntry: Prisma.$SourceEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      source_id: number
      build: string
    }, ExtArgs["result"]["sourcePrequisiteBuild"]>
    composites: {}
  }

  type SourcePrequisiteBuildGetPayload<S extends boolean | null | undefined | SourcePrequisiteBuildDefaultArgs> = $Result.GetResult<Prisma.$SourcePrequisiteBuildPayload, S>

  type SourcePrequisiteBuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourcePrequisiteBuildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourcePrequisiteBuildCountAggregateInputType | true
    }

  export interface SourcePrequisiteBuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourcePrequisiteBuild'], meta: { name: 'SourcePrequisiteBuild' } }
    /**
     * Find zero or one SourcePrequisiteBuild that matches the filter.
     * @param {SourcePrequisiteBuildFindUniqueArgs} args - Arguments to find a SourcePrequisiteBuild
     * @example
     * // Get one SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourcePrequisiteBuildFindUniqueArgs>(args: SelectSubset<T, SourcePrequisiteBuildFindUniqueArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourcePrequisiteBuild that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourcePrequisiteBuildFindUniqueOrThrowArgs} args - Arguments to find a SourcePrequisiteBuild
     * @example
     * // Get one SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourcePrequisiteBuildFindUniqueOrThrowArgs>(args: SelectSubset<T, SourcePrequisiteBuildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourcePrequisiteBuild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildFindFirstArgs} args - Arguments to find a SourcePrequisiteBuild
     * @example
     * // Get one SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourcePrequisiteBuildFindFirstArgs>(args?: SelectSubset<T, SourcePrequisiteBuildFindFirstArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourcePrequisiteBuild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildFindFirstOrThrowArgs} args - Arguments to find a SourcePrequisiteBuild
     * @example
     * // Get one SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourcePrequisiteBuildFindFirstOrThrowArgs>(args?: SelectSubset<T, SourcePrequisiteBuildFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourcePrequisiteBuilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourcePrequisiteBuilds
     * const sourcePrequisiteBuilds = await prisma.sourcePrequisiteBuild.findMany()
     * 
     * // Get first 10 SourcePrequisiteBuilds
     * const sourcePrequisiteBuilds = await prisma.sourcePrequisiteBuild.findMany({ take: 10 })
     * 
     * // Only select the `source_id`
     * const sourcePrequisiteBuildWithSource_idOnly = await prisma.sourcePrequisiteBuild.findMany({ select: { source_id: true } })
     * 
     */
    findMany<T extends SourcePrequisiteBuildFindManyArgs>(args?: SelectSubset<T, SourcePrequisiteBuildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourcePrequisiteBuild.
     * @param {SourcePrequisiteBuildCreateArgs} args - Arguments to create a SourcePrequisiteBuild.
     * @example
     * // Create one SourcePrequisiteBuild
     * const SourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.create({
     *   data: {
     *     // ... data to create a SourcePrequisiteBuild
     *   }
     * })
     * 
     */
    create<T extends SourcePrequisiteBuildCreateArgs>(args: SelectSubset<T, SourcePrequisiteBuildCreateArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourcePrequisiteBuilds.
     * @param {SourcePrequisiteBuildCreateManyArgs} args - Arguments to create many SourcePrequisiteBuilds.
     * @example
     * // Create many SourcePrequisiteBuilds
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourcePrequisiteBuildCreateManyArgs>(args?: SelectSubset<T, SourcePrequisiteBuildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourcePrequisiteBuilds and returns the data saved in the database.
     * @param {SourcePrequisiteBuildCreateManyAndReturnArgs} args - Arguments to create many SourcePrequisiteBuilds.
     * @example
     * // Create many SourcePrequisiteBuilds
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourcePrequisiteBuilds and only return the `source_id`
     * const sourcePrequisiteBuildWithSource_idOnly = await prisma.sourcePrequisiteBuild.createManyAndReturn({
     *   select: { source_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourcePrequisiteBuildCreateManyAndReturnArgs>(args?: SelectSubset<T, SourcePrequisiteBuildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourcePrequisiteBuild.
     * @param {SourcePrequisiteBuildDeleteArgs} args - Arguments to delete one SourcePrequisiteBuild.
     * @example
     * // Delete one SourcePrequisiteBuild
     * const SourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.delete({
     *   where: {
     *     // ... filter to delete one SourcePrequisiteBuild
     *   }
     * })
     * 
     */
    delete<T extends SourcePrequisiteBuildDeleteArgs>(args: SelectSubset<T, SourcePrequisiteBuildDeleteArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourcePrequisiteBuild.
     * @param {SourcePrequisiteBuildUpdateArgs} args - Arguments to update one SourcePrequisiteBuild.
     * @example
     * // Update one SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourcePrequisiteBuildUpdateArgs>(args: SelectSubset<T, SourcePrequisiteBuildUpdateArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourcePrequisiteBuilds.
     * @param {SourcePrequisiteBuildDeleteManyArgs} args - Arguments to filter SourcePrequisiteBuilds to delete.
     * @example
     * // Delete a few SourcePrequisiteBuilds
     * const { count } = await prisma.sourcePrequisiteBuild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourcePrequisiteBuildDeleteManyArgs>(args?: SelectSubset<T, SourcePrequisiteBuildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourcePrequisiteBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourcePrequisiteBuilds
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourcePrequisiteBuildUpdateManyArgs>(args: SelectSubset<T, SourcePrequisiteBuildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourcePrequisiteBuilds and returns the data updated in the database.
     * @param {SourcePrequisiteBuildUpdateManyAndReturnArgs} args - Arguments to update many SourcePrequisiteBuilds.
     * @example
     * // Update many SourcePrequisiteBuilds
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourcePrequisiteBuilds and only return the `source_id`
     * const sourcePrequisiteBuildWithSource_idOnly = await prisma.sourcePrequisiteBuild.updateManyAndReturn({
     *   select: { source_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourcePrequisiteBuildUpdateManyAndReturnArgs>(args: SelectSubset<T, SourcePrequisiteBuildUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourcePrequisiteBuild.
     * @param {SourcePrequisiteBuildUpsertArgs} args - Arguments to update or create a SourcePrequisiteBuild.
     * @example
     * // Update or create a SourcePrequisiteBuild
     * const sourcePrequisiteBuild = await prisma.sourcePrequisiteBuild.upsert({
     *   create: {
     *     // ... data to create a SourcePrequisiteBuild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourcePrequisiteBuild we want to update
     *   }
     * })
     */
    upsert<T extends SourcePrequisiteBuildUpsertArgs>(args: SelectSubset<T, SourcePrequisiteBuildUpsertArgs<ExtArgs>>): Prisma__SourcePrequisiteBuildClient<$Result.GetResult<Prisma.$SourcePrequisiteBuildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourcePrequisiteBuilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildCountArgs} args - Arguments to filter SourcePrequisiteBuilds to count.
     * @example
     * // Count the number of SourcePrequisiteBuilds
     * const count = await prisma.sourcePrequisiteBuild.count({
     *   where: {
     *     // ... the filter for the SourcePrequisiteBuilds we want to count
     *   }
     * })
    **/
    count<T extends SourcePrequisiteBuildCountArgs>(
      args?: Subset<T, SourcePrequisiteBuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourcePrequisiteBuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourcePrequisiteBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourcePrequisiteBuildAggregateArgs>(args: Subset<T, SourcePrequisiteBuildAggregateArgs>): Prisma.PrismaPromise<GetSourcePrequisiteBuildAggregateType<T>>

    /**
     * Group by SourcePrequisiteBuild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourcePrequisiteBuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourcePrequisiteBuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourcePrequisiteBuildGroupByArgs['orderBy'] }
        : { orderBy?: SourcePrequisiteBuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourcePrequisiteBuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourcePrequisiteBuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourcePrequisiteBuild model
   */
  readonly fields: SourcePrequisiteBuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourcePrequisiteBuild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourcePrequisiteBuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SourceEntry<T extends SourceEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceEntryDefaultArgs<ExtArgs>>): Prisma__SourceEntryClient<$Result.GetResult<Prisma.$SourceEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourcePrequisiteBuild model
   */
  interface SourcePrequisiteBuildFieldRefs {
    readonly source_id: FieldRef<"SourcePrequisiteBuild", 'Int'>
    readonly build: FieldRef<"SourcePrequisiteBuild", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SourcePrequisiteBuild findUnique
   */
  export type SourcePrequisiteBuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter, which SourcePrequisiteBuild to fetch.
     */
    where: SourcePrequisiteBuildWhereUniqueInput
  }

  /**
   * SourcePrequisiteBuild findUniqueOrThrow
   */
  export type SourcePrequisiteBuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter, which SourcePrequisiteBuild to fetch.
     */
    where: SourcePrequisiteBuildWhereUniqueInput
  }

  /**
   * SourcePrequisiteBuild findFirst
   */
  export type SourcePrequisiteBuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter, which SourcePrequisiteBuild to fetch.
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourcePrequisiteBuilds to fetch.
     */
    orderBy?: SourcePrequisiteBuildOrderByWithRelationInput | SourcePrequisiteBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourcePrequisiteBuilds.
     */
    cursor?: SourcePrequisiteBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourcePrequisiteBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourcePrequisiteBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourcePrequisiteBuilds.
     */
    distinct?: SourcePrequisiteBuildScalarFieldEnum | SourcePrequisiteBuildScalarFieldEnum[]
  }

  /**
   * SourcePrequisiteBuild findFirstOrThrow
   */
  export type SourcePrequisiteBuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter, which SourcePrequisiteBuild to fetch.
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourcePrequisiteBuilds to fetch.
     */
    orderBy?: SourcePrequisiteBuildOrderByWithRelationInput | SourcePrequisiteBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourcePrequisiteBuilds.
     */
    cursor?: SourcePrequisiteBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourcePrequisiteBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourcePrequisiteBuilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourcePrequisiteBuilds.
     */
    distinct?: SourcePrequisiteBuildScalarFieldEnum | SourcePrequisiteBuildScalarFieldEnum[]
  }

  /**
   * SourcePrequisiteBuild findMany
   */
  export type SourcePrequisiteBuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter, which SourcePrequisiteBuilds to fetch.
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourcePrequisiteBuilds to fetch.
     */
    orderBy?: SourcePrequisiteBuildOrderByWithRelationInput | SourcePrequisiteBuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourcePrequisiteBuilds.
     */
    cursor?: SourcePrequisiteBuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourcePrequisiteBuilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourcePrequisiteBuilds.
     */
    skip?: number
    distinct?: SourcePrequisiteBuildScalarFieldEnum | SourcePrequisiteBuildScalarFieldEnum[]
  }

  /**
   * SourcePrequisiteBuild create
   */
  export type SourcePrequisiteBuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * The data needed to create a SourcePrequisiteBuild.
     */
    data: XOR<SourcePrequisiteBuildCreateInput, SourcePrequisiteBuildUncheckedCreateInput>
  }

  /**
   * SourcePrequisiteBuild createMany
   */
  export type SourcePrequisiteBuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourcePrequisiteBuilds.
     */
    data: SourcePrequisiteBuildCreateManyInput | SourcePrequisiteBuildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourcePrequisiteBuild createManyAndReturn
   */
  export type SourcePrequisiteBuildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * The data used to create many SourcePrequisiteBuilds.
     */
    data: SourcePrequisiteBuildCreateManyInput | SourcePrequisiteBuildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourcePrequisiteBuild update
   */
  export type SourcePrequisiteBuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * The data needed to update a SourcePrequisiteBuild.
     */
    data: XOR<SourcePrequisiteBuildUpdateInput, SourcePrequisiteBuildUncheckedUpdateInput>
    /**
     * Choose, which SourcePrequisiteBuild to update.
     */
    where: SourcePrequisiteBuildWhereUniqueInput
  }

  /**
   * SourcePrequisiteBuild updateMany
   */
  export type SourcePrequisiteBuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourcePrequisiteBuilds.
     */
    data: XOR<SourcePrequisiteBuildUpdateManyMutationInput, SourcePrequisiteBuildUncheckedUpdateManyInput>
    /**
     * Filter which SourcePrequisiteBuilds to update
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * Limit how many SourcePrequisiteBuilds to update.
     */
    limit?: number
  }

  /**
   * SourcePrequisiteBuild updateManyAndReturn
   */
  export type SourcePrequisiteBuildUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * The data used to update SourcePrequisiteBuilds.
     */
    data: XOR<SourcePrequisiteBuildUpdateManyMutationInput, SourcePrequisiteBuildUncheckedUpdateManyInput>
    /**
     * Filter which SourcePrequisiteBuilds to update
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * Limit how many SourcePrequisiteBuilds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourcePrequisiteBuild upsert
   */
  export type SourcePrequisiteBuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * The filter to search for the SourcePrequisiteBuild to update in case it exists.
     */
    where: SourcePrequisiteBuildWhereUniqueInput
    /**
     * In case the SourcePrequisiteBuild found by the `where` argument doesn't exist, create a new SourcePrequisiteBuild with this data.
     */
    create: XOR<SourcePrequisiteBuildCreateInput, SourcePrequisiteBuildUncheckedCreateInput>
    /**
     * In case the SourcePrequisiteBuild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourcePrequisiteBuildUpdateInput, SourcePrequisiteBuildUncheckedUpdateInput>
  }

  /**
   * SourcePrequisiteBuild delete
   */
  export type SourcePrequisiteBuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
    /**
     * Filter which SourcePrequisiteBuild to delete.
     */
    where: SourcePrequisiteBuildWhereUniqueInput
  }

  /**
   * SourcePrequisiteBuild deleteMany
   */
  export type SourcePrequisiteBuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourcePrequisiteBuilds to delete
     */
    where?: SourcePrequisiteBuildWhereInput
    /**
     * Limit how many SourcePrequisiteBuilds to delete.
     */
    limit?: number
  }

  /**
   * SourcePrequisiteBuild without action
   */
  export type SourcePrequisiteBuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourcePrequisiteBuild
     */
    select?: SourcePrequisiteBuildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourcePrequisiteBuild
     */
    omit?: SourcePrequisiteBuildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourcePrequisiteBuildInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ColorLookupScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ColorLookupScalarFieldEnum = (typeof ColorLookupScalarFieldEnum)[keyof typeof ColorLookupScalarFieldEnum]


  export const DeviceEntryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category_id: 'category_id',
    image_id: 'image_id',
    is_internal: 'is_internal',
    legacy_unique_key: 'legacy_unique_key'
  };

  export type DeviceEntryScalarFieldEnum = (typeof DeviceEntryScalarFieldEnum)[keyof typeof DeviceEntryScalarFieldEnum]


  export const DeviceGroupEntryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category_id: 'category_id',
    image_id: 'image_id',
    is_internal: 'is_internal',
    legacy_unique_key: 'legacy_unique_key'
  };

  export type DeviceGroupEntryScalarFieldEnum = (typeof DeviceGroupEntryScalarFieldEnum)[keyof typeof DeviceGroupEntryScalarFieldEnum]


  export const DeviceGroupMapDeviceScalarFieldEnum: {
    group_id: 'group_id',
    device_id: 'device_id'
  };

  export type DeviceGroupMapDeviceScalarFieldEnum = (typeof DeviceGroupMapDeviceScalarFieldEnum)[keyof typeof DeviceGroupMapDeviceScalarFieldEnum]


  export const DeviceGroupMapDeviceGroupScalarFieldEnum: {
    parent_group_id: 'parent_group_id',
    child_group_id: 'child_group_id'
  };

  export type DeviceGroupMapDeviceGroupScalarFieldEnum = (typeof DeviceGroupMapDeviceGroupScalarFieldEnum)[keyof typeof DeviceGroupMapDeviceGroupScalarFieldEnum]


  export const DeviceImageColorsScalarFieldEnum: {
    device_image_id: 'device_image_id',
    color_id: 'color_id',
    dark_mode: 'dark_mode'
  };

  export type DeviceImageColorsScalarFieldEnum = (typeof DeviceImageColorsScalarFieldEnum)[keyof typeof DeviceImageColorsScalarFieldEnum]


  export const DeviceLookupArchitectureScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeviceLookupArchitectureScalarFieldEnum = (typeof DeviceLookupArchitectureScalarFieldEnum)[keyof typeof DeviceLookupArchitectureScalarFieldEnum]


  export const DeviceLookupCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeviceLookupCategoryScalarFieldEnum = (typeof DeviceLookupCategoryScalarFieldEnum)[keyof typeof DeviceLookupCategoryScalarFieldEnum]


  export const DeviceLookupImageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeviceLookupImageScalarFieldEnum = (typeof DeviceLookupImageScalarFieldEnum)[keyof typeof DeviceLookupImageScalarFieldEnum]


  export const DeviceLookupSocScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DeviceLookupSocScalarFieldEnum = (typeof DeviceLookupSocScalarFieldEnum)[keyof typeof DeviceLookupSocScalarFieldEnum]


  export const DeviceMapArchitectureScalarFieldEnum: {
    device_id: 'device_id',
    architecture_id: 'architecture_id'
  };

  export type DeviceMapArchitectureScalarFieldEnum = (typeof DeviceMapArchitectureScalarFieldEnum)[keyof typeof DeviceMapArchitectureScalarFieldEnum]


  export const DeviceMapIdentifierScalarFieldEnum: {
    device_id: 'device_id',
    identifier: 'identifier'
  };

  export type DeviceMapIdentifierScalarFieldEnum = (typeof DeviceMapIdentifierScalarFieldEnum)[keyof typeof DeviceMapIdentifierScalarFieldEnum]


  export const DeviceMapModelScalarFieldEnum: {
    device_id: 'device_id',
    model: 'model'
  };

  export type DeviceMapModelScalarFieldEnum = (typeof DeviceMapModelScalarFieldEnum)[keyof typeof DeviceMapModelScalarFieldEnum]


  export const DeviceMapReleaseScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    datetime: 'datetime',
    depth: 'depth'
  };

  export type DeviceMapReleaseScalarFieldEnum = (typeof DeviceMapReleaseScalarFieldEnum)[keyof typeof DeviceMapReleaseScalarFieldEnum]


  export const DeviceMapSocScalarFieldEnum: {
    device_id: 'device_id',
    soc_id: 'soc_id'
  };

  export type DeviceMapSocScalarFieldEnum = (typeof DeviceMapSocScalarFieldEnum)[keyof typeof DeviceMapSocScalarFieldEnum]


  export const MapDeviceOsScalarFieldEnum: {
    device_id: 'device_id',
    os_id: 'os_id'
  };

  export type MapDeviceOsScalarFieldEnum = (typeof MapDeviceOsScalarFieldEnum)[keyof typeof MapDeviceOsScalarFieldEnum]


  export const OsEntryScalarFieldEnum: {
    id: 'id',
    name_id: 'name_id',
    version: 'version',
    build: 'build',
    release_datetime: 'release_datetime',
    release_datetime_depth: 'release_datetime_depth',
    is_release: 'is_release',
    is_beta: 'is_beta',
    is_rc: 'is_rc',
    is_internal: 'is_internal',
    is_rsr: 'is_rsr',
    is_sdk: 'is_sdk',
    is_simulator: 'is_simulator',
    image_id: 'image_id',
    embedded_os_build: 'embedded_os_build',
    bridge_os_build: 'bridge_os_build',
    notes: 'notes',
    legacy_unique_key: 'legacy_unique_key',
    search: 'search'
  };

  export type OsEntryScalarFieldEnum = (typeof OsEntryScalarFieldEnum)[keyof typeof OsEntryScalarFieldEnum]


  export const OsEntryBuildTrainScalarFieldEnum: {
    os_id: 'os_id',
    build_train: 'build_train'
  };

  export type OsEntryBuildTrainScalarFieldEnum = (typeof OsEntryBuildTrainScalarFieldEnum)[keyof typeof OsEntryBuildTrainScalarFieldEnum]


  export const OsEntryIpdScalarFieldEnum: {
    os_id: 'os_id',
    ipd_type: 'ipd_type',
    url: 'url',
    active: 'active'
  };

  export type OsEntryIpdScalarFieldEnum = (typeof OsEntryIpdScalarFieldEnum)[keyof typeof OsEntryIpdScalarFieldEnum]


  export const OsEntryOsStringMapScalarFieldEnum: {
    os_id: 'os_id',
    os_string: 'os_string'
  };

  export type OsEntryOsStringMapScalarFieldEnum = (typeof OsEntryOsStringMapScalarFieldEnum)[keyof typeof OsEntryOsStringMapScalarFieldEnum]


  export const OsEntryPreinstalledScalarFieldEnum: {
    os_id: 'os_id',
    device_id: 'device_id'
  };

  export type OsEntryPreinstalledScalarFieldEnum = (typeof OsEntryPreinstalledScalarFieldEnum)[keyof typeof OsEntryPreinstalledScalarFieldEnum]


  export const OsEntryReleaseNoteScalarFieldEnum: {
    os_id: 'os_id',
    url: 'url',
    active: 'active'
  };

  export type OsEntryReleaseNoteScalarFieldEnum = (typeof OsEntryReleaseNoteScalarFieldEnum)[keyof typeof OsEntryReleaseNoteScalarFieldEnum]


  export const OsEntrySafariVersionScalarFieldEnum: {
    os_id: 'os_id',
    version: 'version'
  };

  export type OsEntrySafariVersionScalarFieldEnum = (typeof OsEntrySafariVersionScalarFieldEnum)[keyof typeof OsEntrySafariVersionScalarFieldEnum]


  export const OsEntrySecurityNoteScalarFieldEnum: {
    os_id: 'os_id',
    url: 'url',
    active: 'active'
  };

  export type OsEntrySecurityNoteScalarFieldEnum = (typeof OsEntrySecurityNoteScalarFieldEnum)[keyof typeof OsEntrySecurityNoteScalarFieldEnum]


  export const OsLookupNameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    priority: 'priority'
  };

  export type OsLookupNameScalarFieldEnum = (typeof OsLookupNameScalarFieldEnum)[keyof typeof OsLookupNameScalarFieldEnum]


  export const SourceEntryScalarFieldEnum: {
    id: 'id',
    os_id: 'os_id',
    source_type: 'source_type',
    skip_update_links: 'skip_update_links',
    size: 'size',
    windows_update_id: 'windows_update_id',
    windows_revision_id: 'windows_revision_id'
  };

  export type SourceEntryScalarFieldEnum = (typeof SourceEntryScalarFieldEnum)[keyof typeof SourceEntryScalarFieldEnum]


  export const SourceHashScalarFieldEnum: {
    source_id: 'source_id',
    hash_type: 'hash_type',
    hash_value: 'hash_value'
  };

  export type SourceHashScalarFieldEnum = (typeof SourceHashScalarFieldEnum)[keyof typeof SourceHashScalarFieldEnum]


  export const SourceLinkScalarFieldEnum: {
    source_id: 'source_id',
    url: 'url',
    active: 'active'
  };

  export type SourceLinkScalarFieldEnum = (typeof SourceLinkScalarFieldEnum)[keyof typeof SourceLinkScalarFieldEnum]


  export const SourceMapDeviceScalarFieldEnum: {
    source_id: 'source_id',
    device_id: 'device_id'
  };

  export type SourceMapDeviceScalarFieldEnum = (typeof SourceMapDeviceScalarFieldEnum)[keyof typeof SourceMapDeviceScalarFieldEnum]


  export const SourceMapOsStringScalarFieldEnum: {
    source_id: 'source_id',
    os_string: 'os_string'
  };

  export type SourceMapOsStringScalarFieldEnum = (typeof SourceMapOsStringScalarFieldEnum)[keyof typeof SourceMapOsStringScalarFieldEnum]


  export const SourcePrequisiteBuildScalarFieldEnum: {
    source_id: 'source_id',
    build: 'build'
  };

  export type SourcePrequisiteBuildScalarFieldEnum = (typeof SourcePrequisiteBuildScalarFieldEnum)[keyof typeof SourcePrequisiteBuildScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ColorLookupOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ColorLookupOrderByRelevanceFieldEnum = (typeof ColorLookupOrderByRelevanceFieldEnum)[keyof typeof ColorLookupOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const DeviceEntryOrderByRelevanceFieldEnum: {
    name: 'name',
    legacy_unique_key: 'legacy_unique_key'
  };

  export type DeviceEntryOrderByRelevanceFieldEnum = (typeof DeviceEntryOrderByRelevanceFieldEnum)[keyof typeof DeviceEntryOrderByRelevanceFieldEnum]


  export const DeviceGroupEntryOrderByRelevanceFieldEnum: {
    name: 'name',
    legacy_unique_key: 'legacy_unique_key'
  };

  export type DeviceGroupEntryOrderByRelevanceFieldEnum = (typeof DeviceGroupEntryOrderByRelevanceFieldEnum)[keyof typeof DeviceGroupEntryOrderByRelevanceFieldEnum]


  export const DeviceLookupArchitectureOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type DeviceLookupArchitectureOrderByRelevanceFieldEnum = (typeof DeviceLookupArchitectureOrderByRelevanceFieldEnum)[keyof typeof DeviceLookupArchitectureOrderByRelevanceFieldEnum]


  export const DeviceLookupCategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type DeviceLookupCategoryOrderByRelevanceFieldEnum = (typeof DeviceLookupCategoryOrderByRelevanceFieldEnum)[keyof typeof DeviceLookupCategoryOrderByRelevanceFieldEnum]


  export const DeviceLookupImageOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type DeviceLookupImageOrderByRelevanceFieldEnum = (typeof DeviceLookupImageOrderByRelevanceFieldEnum)[keyof typeof DeviceLookupImageOrderByRelevanceFieldEnum]


  export const DeviceLookupSocOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type DeviceLookupSocOrderByRelevanceFieldEnum = (typeof DeviceLookupSocOrderByRelevanceFieldEnum)[keyof typeof DeviceLookupSocOrderByRelevanceFieldEnum]


  export const DeviceMapIdentifierOrderByRelevanceFieldEnum: {
    identifier: 'identifier'
  };

  export type DeviceMapIdentifierOrderByRelevanceFieldEnum = (typeof DeviceMapIdentifierOrderByRelevanceFieldEnum)[keyof typeof DeviceMapIdentifierOrderByRelevanceFieldEnum]


  export const DeviceMapModelOrderByRelevanceFieldEnum: {
    model: 'model'
  };

  export type DeviceMapModelOrderByRelevanceFieldEnum = (typeof DeviceMapModelOrderByRelevanceFieldEnum)[keyof typeof DeviceMapModelOrderByRelevanceFieldEnum]


  export const OsEntryOrderByRelevanceFieldEnum: {
    version: 'version',
    build: 'build',
    image_id: 'image_id',
    embedded_os_build: 'embedded_os_build',
    bridge_os_build: 'bridge_os_build',
    notes: 'notes',
    legacy_unique_key: 'legacy_unique_key',
    search: 'search'
  };

  export type OsEntryOrderByRelevanceFieldEnum = (typeof OsEntryOrderByRelevanceFieldEnum)[keyof typeof OsEntryOrderByRelevanceFieldEnum]


  export const OsEntryBuildTrainOrderByRelevanceFieldEnum: {
    build_train: 'build_train'
  };

  export type OsEntryBuildTrainOrderByRelevanceFieldEnum = (typeof OsEntryBuildTrainOrderByRelevanceFieldEnum)[keyof typeof OsEntryBuildTrainOrderByRelevanceFieldEnum]


  export const OsEntryIpdOrderByRelevanceFieldEnum: {
    ipd_type: 'ipd_type',
    url: 'url'
  };

  export type OsEntryIpdOrderByRelevanceFieldEnum = (typeof OsEntryIpdOrderByRelevanceFieldEnum)[keyof typeof OsEntryIpdOrderByRelevanceFieldEnum]


  export const OsEntryOsStringMapOrderByRelevanceFieldEnum: {
    os_string: 'os_string'
  };

  export type OsEntryOsStringMapOrderByRelevanceFieldEnum = (typeof OsEntryOsStringMapOrderByRelevanceFieldEnum)[keyof typeof OsEntryOsStringMapOrderByRelevanceFieldEnum]


  export const OsEntryReleaseNoteOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type OsEntryReleaseNoteOrderByRelevanceFieldEnum = (typeof OsEntryReleaseNoteOrderByRelevanceFieldEnum)[keyof typeof OsEntryReleaseNoteOrderByRelevanceFieldEnum]


  export const OsEntrySafariVersionOrderByRelevanceFieldEnum: {
    version: 'version'
  };

  export type OsEntrySafariVersionOrderByRelevanceFieldEnum = (typeof OsEntrySafariVersionOrderByRelevanceFieldEnum)[keyof typeof OsEntrySafariVersionOrderByRelevanceFieldEnum]


  export const OsEntrySecurityNoteOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type OsEntrySecurityNoteOrderByRelevanceFieldEnum = (typeof OsEntrySecurityNoteOrderByRelevanceFieldEnum)[keyof typeof OsEntrySecurityNoteOrderByRelevanceFieldEnum]


  export const OsLookupNameOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type OsLookupNameOrderByRelevanceFieldEnum = (typeof OsLookupNameOrderByRelevanceFieldEnum)[keyof typeof OsLookupNameOrderByRelevanceFieldEnum]


  export const SourceEntryOrderByRelevanceFieldEnum: {
    source_type: 'source_type',
    windows_update_id: 'windows_update_id',
    windows_revision_id: 'windows_revision_id'
  };

  export type SourceEntryOrderByRelevanceFieldEnum = (typeof SourceEntryOrderByRelevanceFieldEnum)[keyof typeof SourceEntryOrderByRelevanceFieldEnum]


  export const SourceHashOrderByRelevanceFieldEnum: {
    hash_type: 'hash_type',
    hash_value: 'hash_value'
  };

  export type SourceHashOrderByRelevanceFieldEnum = (typeof SourceHashOrderByRelevanceFieldEnum)[keyof typeof SourceHashOrderByRelevanceFieldEnum]


  export const SourceLinkOrderByRelevanceFieldEnum: {
    url: 'url'
  };

  export type SourceLinkOrderByRelevanceFieldEnum = (typeof SourceLinkOrderByRelevanceFieldEnum)[keyof typeof SourceLinkOrderByRelevanceFieldEnum]


  export const SourceMapOsStringOrderByRelevanceFieldEnum: {
    os_string: 'os_string'
  };

  export type SourceMapOsStringOrderByRelevanceFieldEnum = (typeof SourceMapOsStringOrderByRelevanceFieldEnum)[keyof typeof SourceMapOsStringOrderByRelevanceFieldEnum]


  export const SourcePrequisiteBuildOrderByRelevanceFieldEnum: {
    build: 'build'
  };

  export type SourcePrequisiteBuildOrderByRelevanceFieldEnum = (typeof SourcePrequisiteBuildOrderByRelevanceFieldEnum)[keyof typeof SourcePrequisiteBuildOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ColorLookupWhereInput = {
    AND?: ColorLookupWhereInput | ColorLookupWhereInput[]
    OR?: ColorLookupWhereInput[]
    NOT?: ColorLookupWhereInput | ColorLookupWhereInput[]
    id?: IntFilter<"ColorLookup"> | number
    name?: StringFilter<"ColorLookup"> | string
    DeviceImageColors?: DeviceImageColorsListRelationFilter
  }

  export type ColorLookupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DeviceImageColors?: DeviceImageColorsOrderByRelationAggregateInput
    _relevance?: ColorLookupOrderByRelevanceInput
  }

  export type ColorLookupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ColorLookupWhereInput | ColorLookupWhereInput[]
    OR?: ColorLookupWhereInput[]
    NOT?: ColorLookupWhereInput | ColorLookupWhereInput[]
    name?: StringFilter<"ColorLookup"> | string
    DeviceImageColors?: DeviceImageColorsListRelationFilter
  }, "id">

  export type ColorLookupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ColorLookupCountOrderByAggregateInput
    _avg?: ColorLookupAvgOrderByAggregateInput
    _max?: ColorLookupMaxOrderByAggregateInput
    _min?: ColorLookupMinOrderByAggregateInput
    _sum?: ColorLookupSumOrderByAggregateInput
  }

  export type ColorLookupScalarWhereWithAggregatesInput = {
    AND?: ColorLookupScalarWhereWithAggregatesInput | ColorLookupScalarWhereWithAggregatesInput[]
    OR?: ColorLookupScalarWhereWithAggregatesInput[]
    NOT?: ColorLookupScalarWhereWithAggregatesInput | ColorLookupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ColorLookup"> | number
    name?: StringWithAggregatesFilter<"ColorLookup"> | string
  }

  export type DeviceEntryWhereInput = {
    AND?: DeviceEntryWhereInput | DeviceEntryWhereInput[]
    OR?: DeviceEntryWhereInput[]
    NOT?: DeviceEntryWhereInput | DeviceEntryWhereInput[]
    id?: IntFilter<"DeviceEntry"> | number
    name?: StringFilter<"DeviceEntry"> | string
    category_id?: IntFilter<"DeviceEntry"> | number
    image_id?: IntNullableFilter<"DeviceEntry"> | number | null
    is_internal?: BoolNullableFilter<"DeviceEntry"> | boolean | null
    legacy_unique_key?: StringNullableFilter<"DeviceEntry"> | string | null
    DeviceLookupCategory?: XOR<DeviceLookupCategoryScalarRelationFilter, DeviceLookupCategoryWhereInput>
    DeviceLookupImage?: XOR<DeviceLookupImageNullableScalarRelationFilter, DeviceLookupImageWhereInput> | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceListRelationFilter
    DeviceMapArchitecture?: DeviceMapArchitectureListRelationFilter
    DeviceMapIdentifier?: DeviceMapIdentifierListRelationFilter
    DeviceMapModel?: DeviceMapModelListRelationFilter
    DeviceMapRelease?: DeviceMapReleaseListRelationFilter
    DeviceMapSoc?: DeviceMapSocListRelationFilter
    MapDeviceOs?: MapDeviceOsListRelationFilter
    OsEntryPreinstalled?: OsEntryPreinstalledListRelationFilter
    SourceMapDevice?: SourceMapDeviceListRelationFilter
  }

  export type DeviceEntryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    DeviceLookupCategory?: DeviceLookupCategoryOrderByWithRelationInput
    DeviceLookupImage?: DeviceLookupImageOrderByWithRelationInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceOrderByRelationAggregateInput
    DeviceMapArchitecture?: DeviceMapArchitectureOrderByRelationAggregateInput
    DeviceMapIdentifier?: DeviceMapIdentifierOrderByRelationAggregateInput
    DeviceMapModel?: DeviceMapModelOrderByRelationAggregateInput
    DeviceMapRelease?: DeviceMapReleaseOrderByRelationAggregateInput
    DeviceMapSoc?: DeviceMapSocOrderByRelationAggregateInput
    MapDeviceOs?: MapDeviceOsOrderByRelationAggregateInput
    OsEntryPreinstalled?: OsEntryPreinstalledOrderByRelationAggregateInput
    SourceMapDevice?: SourceMapDeviceOrderByRelationAggregateInput
    _relevance?: DeviceEntryOrderByRelevanceInput
  }

  export type DeviceEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceEntryWhereInput | DeviceEntryWhereInput[]
    OR?: DeviceEntryWhereInput[]
    NOT?: DeviceEntryWhereInput | DeviceEntryWhereInput[]
    name?: StringFilter<"DeviceEntry"> | string
    category_id?: IntFilter<"DeviceEntry"> | number
    image_id?: IntNullableFilter<"DeviceEntry"> | number | null
    is_internal?: BoolNullableFilter<"DeviceEntry"> | boolean | null
    legacy_unique_key?: StringNullableFilter<"DeviceEntry"> | string | null
    DeviceLookupCategory?: XOR<DeviceLookupCategoryScalarRelationFilter, DeviceLookupCategoryWhereInput>
    DeviceLookupImage?: XOR<DeviceLookupImageNullableScalarRelationFilter, DeviceLookupImageWhereInput> | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceListRelationFilter
    DeviceMapArchitecture?: DeviceMapArchitectureListRelationFilter
    DeviceMapIdentifier?: DeviceMapIdentifierListRelationFilter
    DeviceMapModel?: DeviceMapModelListRelationFilter
    DeviceMapRelease?: DeviceMapReleaseListRelationFilter
    DeviceMapSoc?: DeviceMapSocListRelationFilter
    MapDeviceOs?: MapDeviceOsListRelationFilter
    OsEntryPreinstalled?: OsEntryPreinstalledListRelationFilter
    SourceMapDevice?: SourceMapDeviceListRelationFilter
  }, "id">

  export type DeviceEntryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    _count?: DeviceEntryCountOrderByAggregateInput
    _avg?: DeviceEntryAvgOrderByAggregateInput
    _max?: DeviceEntryMaxOrderByAggregateInput
    _min?: DeviceEntryMinOrderByAggregateInput
    _sum?: DeviceEntrySumOrderByAggregateInput
  }

  export type DeviceEntryScalarWhereWithAggregatesInput = {
    AND?: DeviceEntryScalarWhereWithAggregatesInput | DeviceEntryScalarWhereWithAggregatesInput[]
    OR?: DeviceEntryScalarWhereWithAggregatesInput[]
    NOT?: DeviceEntryScalarWhereWithAggregatesInput | DeviceEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceEntry"> | number
    name?: StringWithAggregatesFilter<"DeviceEntry"> | string
    category_id?: IntWithAggregatesFilter<"DeviceEntry"> | number
    image_id?: IntNullableWithAggregatesFilter<"DeviceEntry"> | number | null
    is_internal?: BoolNullableWithAggregatesFilter<"DeviceEntry"> | boolean | null
    legacy_unique_key?: StringNullableWithAggregatesFilter<"DeviceEntry"> | string | null
  }

  export type DeviceGroupEntryWhereInput = {
    AND?: DeviceGroupEntryWhereInput | DeviceGroupEntryWhereInput[]
    OR?: DeviceGroupEntryWhereInput[]
    NOT?: DeviceGroupEntryWhereInput | DeviceGroupEntryWhereInput[]
    id?: IntFilter<"DeviceGroupEntry"> | number
    name?: StringFilter<"DeviceGroupEntry"> | string
    category_id?: IntNullableFilter<"DeviceGroupEntry"> | number | null
    image_id?: IntNullableFilter<"DeviceGroupEntry"> | number | null
    is_internal?: BoolNullableFilter<"DeviceGroupEntry"> | boolean | null
    legacy_unique_key?: StringNullableFilter<"DeviceGroupEntry"> | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceListRelationFilter
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupListRelationFilter
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupListRelationFilter
  }

  export type DeviceGroupEntryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrderInput | SortOrder
    image_id?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    DeviceGroupMapDevice?: DeviceGroupMapDeviceOrderByRelationAggregateInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupOrderByRelationAggregateInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupOrderByRelationAggregateInput
    _relevance?: DeviceGroupEntryOrderByRelevanceInput
  }

  export type DeviceGroupEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceGroupEntryWhereInput | DeviceGroupEntryWhereInput[]
    OR?: DeviceGroupEntryWhereInput[]
    NOT?: DeviceGroupEntryWhereInput | DeviceGroupEntryWhereInput[]
    name?: StringFilter<"DeviceGroupEntry"> | string
    category_id?: IntNullableFilter<"DeviceGroupEntry"> | number | null
    image_id?: IntNullableFilter<"DeviceGroupEntry"> | number | null
    is_internal?: BoolNullableFilter<"DeviceGroupEntry"> | boolean | null
    legacy_unique_key?: StringNullableFilter<"DeviceGroupEntry"> | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceListRelationFilter
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupListRelationFilter
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupListRelationFilter
  }, "id">

  export type DeviceGroupEntryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrderInput | SortOrder
    image_id?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    _count?: DeviceGroupEntryCountOrderByAggregateInput
    _avg?: DeviceGroupEntryAvgOrderByAggregateInput
    _max?: DeviceGroupEntryMaxOrderByAggregateInput
    _min?: DeviceGroupEntryMinOrderByAggregateInput
    _sum?: DeviceGroupEntrySumOrderByAggregateInput
  }

  export type DeviceGroupEntryScalarWhereWithAggregatesInput = {
    AND?: DeviceGroupEntryScalarWhereWithAggregatesInput | DeviceGroupEntryScalarWhereWithAggregatesInput[]
    OR?: DeviceGroupEntryScalarWhereWithAggregatesInput[]
    NOT?: DeviceGroupEntryScalarWhereWithAggregatesInput | DeviceGroupEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceGroupEntry"> | number
    name?: StringWithAggregatesFilter<"DeviceGroupEntry"> | string
    category_id?: IntNullableWithAggregatesFilter<"DeviceGroupEntry"> | number | null
    image_id?: IntNullableWithAggregatesFilter<"DeviceGroupEntry"> | number | null
    is_internal?: BoolNullableWithAggregatesFilter<"DeviceGroupEntry"> | boolean | null
    legacy_unique_key?: StringNullableWithAggregatesFilter<"DeviceGroupEntry"> | string | null
  }

  export type DeviceGroupMapDeviceWhereInput = {
    AND?: DeviceGroupMapDeviceWhereInput | DeviceGroupMapDeviceWhereInput[]
    OR?: DeviceGroupMapDeviceWhereInput[]
    NOT?: DeviceGroupMapDeviceWhereInput | DeviceGroupMapDeviceWhereInput[]
    group_id?: IntFilter<"DeviceGroupMapDevice"> | number
    device_id?: IntFilter<"DeviceGroupMapDevice"> | number
    DeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }

  export type DeviceGroupMapDeviceOrderByWithRelationInput = {
    group_id?: SortOrder
    device_id?: SortOrder
    DeviceGroupEntry?: DeviceGroupEntryOrderByWithRelationInput
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
  }

  export type DeviceGroupMapDeviceWhereUniqueInput = Prisma.AtLeast<{
    group_id_device_id?: DeviceGroupMapDeviceGroup_idDevice_idCompoundUniqueInput
    AND?: DeviceGroupMapDeviceWhereInput | DeviceGroupMapDeviceWhereInput[]
    OR?: DeviceGroupMapDeviceWhereInput[]
    NOT?: DeviceGroupMapDeviceWhereInput | DeviceGroupMapDeviceWhereInput[]
    group_id?: IntFilter<"DeviceGroupMapDevice"> | number
    device_id?: IntFilter<"DeviceGroupMapDevice"> | number
    DeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }, "group_id_device_id">

  export type DeviceGroupMapDeviceOrderByWithAggregationInput = {
    group_id?: SortOrder
    device_id?: SortOrder
    _count?: DeviceGroupMapDeviceCountOrderByAggregateInput
    _avg?: DeviceGroupMapDeviceAvgOrderByAggregateInput
    _max?: DeviceGroupMapDeviceMaxOrderByAggregateInput
    _min?: DeviceGroupMapDeviceMinOrderByAggregateInput
    _sum?: DeviceGroupMapDeviceSumOrderByAggregateInput
  }

  export type DeviceGroupMapDeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceGroupMapDeviceScalarWhereWithAggregatesInput | DeviceGroupMapDeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceGroupMapDeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceGroupMapDeviceScalarWhereWithAggregatesInput | DeviceGroupMapDeviceScalarWhereWithAggregatesInput[]
    group_id?: IntWithAggregatesFilter<"DeviceGroupMapDevice"> | number
    device_id?: IntWithAggregatesFilter<"DeviceGroupMapDevice"> | number
  }

  export type DeviceGroupMapDeviceGroupWhereInput = {
    AND?: DeviceGroupMapDeviceGroupWhereInput | DeviceGroupMapDeviceGroupWhereInput[]
    OR?: DeviceGroupMapDeviceGroupWhereInput[]
    NOT?: DeviceGroupMapDeviceGroupWhereInput | DeviceGroupMapDeviceGroupWhereInput[]
    parent_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
    child_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
  }

  export type DeviceGroupMapDeviceGroupOrderByWithRelationInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupEntryOrderByWithRelationInput
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupEntryOrderByWithRelationInput
  }

  export type DeviceGroupMapDeviceGroupWhereUniqueInput = Prisma.AtLeast<{
    parent_group_id_child_group_id?: DeviceGroupMapDeviceGroupParent_group_idChild_group_idCompoundUniqueInput
    AND?: DeviceGroupMapDeviceGroupWhereInput | DeviceGroupMapDeviceGroupWhereInput[]
    OR?: DeviceGroupMapDeviceGroupWhereInput[]
    NOT?: DeviceGroupMapDeviceGroupWhereInput | DeviceGroupMapDeviceGroupWhereInput[]
    parent_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
    child_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: XOR<DeviceGroupEntryScalarRelationFilter, DeviceGroupEntryWhereInput>
  }, "parent_group_id_child_group_id">

  export type DeviceGroupMapDeviceGroupOrderByWithAggregationInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
    _count?: DeviceGroupMapDeviceGroupCountOrderByAggregateInput
    _avg?: DeviceGroupMapDeviceGroupAvgOrderByAggregateInput
    _max?: DeviceGroupMapDeviceGroupMaxOrderByAggregateInput
    _min?: DeviceGroupMapDeviceGroupMinOrderByAggregateInput
    _sum?: DeviceGroupMapDeviceGroupSumOrderByAggregateInput
  }

  export type DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput = {
    AND?: DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput | DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput[]
    OR?: DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput[]
    NOT?: DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput | DeviceGroupMapDeviceGroupScalarWhereWithAggregatesInput[]
    parent_group_id?: IntWithAggregatesFilter<"DeviceGroupMapDeviceGroup"> | number
    child_group_id?: IntWithAggregatesFilter<"DeviceGroupMapDeviceGroup"> | number
  }

  export type DeviceImageColorsWhereInput = {
    AND?: DeviceImageColorsWhereInput | DeviceImageColorsWhereInput[]
    OR?: DeviceImageColorsWhereInput[]
    NOT?: DeviceImageColorsWhereInput | DeviceImageColorsWhereInput[]
    device_image_id?: IntFilter<"DeviceImageColors"> | number
    color_id?: IntFilter<"DeviceImageColors"> | number
    dark_mode?: BoolNullableFilter<"DeviceImageColors"> | boolean | null
    DeviceLookupImage?: XOR<DeviceLookupImageScalarRelationFilter, DeviceLookupImageWhereInput>
    ColorLookup?: XOR<ColorLookupScalarRelationFilter, ColorLookupWhereInput>
  }

  export type DeviceImageColorsOrderByWithRelationInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
    dark_mode?: SortOrderInput | SortOrder
    DeviceLookupImage?: DeviceLookupImageOrderByWithRelationInput
    ColorLookup?: ColorLookupOrderByWithRelationInput
  }

  export type DeviceImageColorsWhereUniqueInput = Prisma.AtLeast<{
    device_image_id_color_id?: DeviceImageColorsDevice_image_idColor_idCompoundUniqueInput
    AND?: DeviceImageColorsWhereInput | DeviceImageColorsWhereInput[]
    OR?: DeviceImageColorsWhereInput[]
    NOT?: DeviceImageColorsWhereInput | DeviceImageColorsWhereInput[]
    device_image_id?: IntFilter<"DeviceImageColors"> | number
    color_id?: IntFilter<"DeviceImageColors"> | number
    dark_mode?: BoolNullableFilter<"DeviceImageColors"> | boolean | null
    DeviceLookupImage?: XOR<DeviceLookupImageScalarRelationFilter, DeviceLookupImageWhereInput>
    ColorLookup?: XOR<ColorLookupScalarRelationFilter, ColorLookupWhereInput>
  }, "device_image_id_color_id">

  export type DeviceImageColorsOrderByWithAggregationInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
    dark_mode?: SortOrderInput | SortOrder
    _count?: DeviceImageColorsCountOrderByAggregateInput
    _avg?: DeviceImageColorsAvgOrderByAggregateInput
    _max?: DeviceImageColorsMaxOrderByAggregateInput
    _min?: DeviceImageColorsMinOrderByAggregateInput
    _sum?: DeviceImageColorsSumOrderByAggregateInput
  }

  export type DeviceImageColorsScalarWhereWithAggregatesInput = {
    AND?: DeviceImageColorsScalarWhereWithAggregatesInput | DeviceImageColorsScalarWhereWithAggregatesInput[]
    OR?: DeviceImageColorsScalarWhereWithAggregatesInput[]
    NOT?: DeviceImageColorsScalarWhereWithAggregatesInput | DeviceImageColorsScalarWhereWithAggregatesInput[]
    device_image_id?: IntWithAggregatesFilter<"DeviceImageColors"> | number
    color_id?: IntWithAggregatesFilter<"DeviceImageColors"> | number
    dark_mode?: BoolNullableWithAggregatesFilter<"DeviceImageColors"> | boolean | null
  }

  export type DeviceLookupArchitectureWhereInput = {
    AND?: DeviceLookupArchitectureWhereInput | DeviceLookupArchitectureWhereInput[]
    OR?: DeviceLookupArchitectureWhereInput[]
    NOT?: DeviceLookupArchitectureWhereInput | DeviceLookupArchitectureWhereInput[]
    id?: IntFilter<"DeviceLookupArchitecture"> | number
    name?: StringFilter<"DeviceLookupArchitecture"> | string
    DeviceMapArchitecture?: DeviceMapArchitectureListRelationFilter
  }

  export type DeviceLookupArchitectureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DeviceMapArchitecture?: DeviceMapArchitectureOrderByRelationAggregateInput
    _relevance?: DeviceLookupArchitectureOrderByRelevanceInput
  }

  export type DeviceLookupArchitectureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceLookupArchitectureWhereInput | DeviceLookupArchitectureWhereInput[]
    OR?: DeviceLookupArchitectureWhereInput[]
    NOT?: DeviceLookupArchitectureWhereInput | DeviceLookupArchitectureWhereInput[]
    name?: StringFilter<"DeviceLookupArchitecture"> | string
    DeviceMapArchitecture?: DeviceMapArchitectureListRelationFilter
  }, "id">

  export type DeviceLookupArchitectureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeviceLookupArchitectureCountOrderByAggregateInput
    _avg?: DeviceLookupArchitectureAvgOrderByAggregateInput
    _max?: DeviceLookupArchitectureMaxOrderByAggregateInput
    _min?: DeviceLookupArchitectureMinOrderByAggregateInput
    _sum?: DeviceLookupArchitectureSumOrderByAggregateInput
  }

  export type DeviceLookupArchitectureScalarWhereWithAggregatesInput = {
    AND?: DeviceLookupArchitectureScalarWhereWithAggregatesInput | DeviceLookupArchitectureScalarWhereWithAggregatesInput[]
    OR?: DeviceLookupArchitectureScalarWhereWithAggregatesInput[]
    NOT?: DeviceLookupArchitectureScalarWhereWithAggregatesInput | DeviceLookupArchitectureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceLookupArchitecture"> | number
    name?: StringWithAggregatesFilter<"DeviceLookupArchitecture"> | string
  }

  export type DeviceLookupCategoryWhereInput = {
    AND?: DeviceLookupCategoryWhereInput | DeviceLookupCategoryWhereInput[]
    OR?: DeviceLookupCategoryWhereInput[]
    NOT?: DeviceLookupCategoryWhereInput | DeviceLookupCategoryWhereInput[]
    id?: IntFilter<"DeviceLookupCategory"> | number
    name?: StringFilter<"DeviceLookupCategory"> | string
    DeviceEntry?: DeviceEntryListRelationFilter
  }

  export type DeviceLookupCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DeviceEntry?: DeviceEntryOrderByRelationAggregateInput
    _relevance?: DeviceLookupCategoryOrderByRelevanceInput
  }

  export type DeviceLookupCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceLookupCategoryWhereInput | DeviceLookupCategoryWhereInput[]
    OR?: DeviceLookupCategoryWhereInput[]
    NOT?: DeviceLookupCategoryWhereInput | DeviceLookupCategoryWhereInput[]
    name?: StringFilter<"DeviceLookupCategory"> | string
    DeviceEntry?: DeviceEntryListRelationFilter
  }, "id">

  export type DeviceLookupCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeviceLookupCategoryCountOrderByAggregateInput
    _avg?: DeviceLookupCategoryAvgOrderByAggregateInput
    _max?: DeviceLookupCategoryMaxOrderByAggregateInput
    _min?: DeviceLookupCategoryMinOrderByAggregateInput
    _sum?: DeviceLookupCategorySumOrderByAggregateInput
  }

  export type DeviceLookupCategoryScalarWhereWithAggregatesInput = {
    AND?: DeviceLookupCategoryScalarWhereWithAggregatesInput | DeviceLookupCategoryScalarWhereWithAggregatesInput[]
    OR?: DeviceLookupCategoryScalarWhereWithAggregatesInput[]
    NOT?: DeviceLookupCategoryScalarWhereWithAggregatesInput | DeviceLookupCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceLookupCategory"> | number
    name?: StringWithAggregatesFilter<"DeviceLookupCategory"> | string
  }

  export type DeviceLookupImageWhereInput = {
    AND?: DeviceLookupImageWhereInput | DeviceLookupImageWhereInput[]
    OR?: DeviceLookupImageWhereInput[]
    NOT?: DeviceLookupImageWhereInput | DeviceLookupImageWhereInput[]
    id?: IntFilter<"DeviceLookupImage"> | number
    name?: StringFilter<"DeviceLookupImage"> | string
    DeviceEntry?: DeviceEntryListRelationFilter
    DeviceImageColors?: DeviceImageColorsListRelationFilter
  }

  export type DeviceLookupImageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DeviceEntry?: DeviceEntryOrderByRelationAggregateInput
    DeviceImageColors?: DeviceImageColorsOrderByRelationAggregateInput
    _relevance?: DeviceLookupImageOrderByRelevanceInput
  }

  export type DeviceLookupImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceLookupImageWhereInput | DeviceLookupImageWhereInput[]
    OR?: DeviceLookupImageWhereInput[]
    NOT?: DeviceLookupImageWhereInput | DeviceLookupImageWhereInput[]
    name?: StringFilter<"DeviceLookupImage"> | string
    DeviceEntry?: DeviceEntryListRelationFilter
    DeviceImageColors?: DeviceImageColorsListRelationFilter
  }, "id">

  export type DeviceLookupImageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeviceLookupImageCountOrderByAggregateInput
    _avg?: DeviceLookupImageAvgOrderByAggregateInput
    _max?: DeviceLookupImageMaxOrderByAggregateInput
    _min?: DeviceLookupImageMinOrderByAggregateInput
    _sum?: DeviceLookupImageSumOrderByAggregateInput
  }

  export type DeviceLookupImageScalarWhereWithAggregatesInput = {
    AND?: DeviceLookupImageScalarWhereWithAggregatesInput | DeviceLookupImageScalarWhereWithAggregatesInput[]
    OR?: DeviceLookupImageScalarWhereWithAggregatesInput[]
    NOT?: DeviceLookupImageScalarWhereWithAggregatesInput | DeviceLookupImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceLookupImage"> | number
    name?: StringWithAggregatesFilter<"DeviceLookupImage"> | string
  }

  export type DeviceLookupSocWhereInput = {
    AND?: DeviceLookupSocWhereInput | DeviceLookupSocWhereInput[]
    OR?: DeviceLookupSocWhereInput[]
    NOT?: DeviceLookupSocWhereInput | DeviceLookupSocWhereInput[]
    id?: IntFilter<"DeviceLookupSoc"> | number
    name?: StringFilter<"DeviceLookupSoc"> | string
    DeviceMapSoc?: DeviceMapSocListRelationFilter
  }

  export type DeviceLookupSocOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DeviceMapSoc?: DeviceMapSocOrderByRelationAggregateInput
    _relevance?: DeviceLookupSocOrderByRelevanceInput
  }

  export type DeviceLookupSocWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceLookupSocWhereInput | DeviceLookupSocWhereInput[]
    OR?: DeviceLookupSocWhereInput[]
    NOT?: DeviceLookupSocWhereInput | DeviceLookupSocWhereInput[]
    name?: StringFilter<"DeviceLookupSoc"> | string
    DeviceMapSoc?: DeviceMapSocListRelationFilter
  }, "id">

  export type DeviceLookupSocOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DeviceLookupSocCountOrderByAggregateInput
    _avg?: DeviceLookupSocAvgOrderByAggregateInput
    _max?: DeviceLookupSocMaxOrderByAggregateInput
    _min?: DeviceLookupSocMinOrderByAggregateInput
    _sum?: DeviceLookupSocSumOrderByAggregateInput
  }

  export type DeviceLookupSocScalarWhereWithAggregatesInput = {
    AND?: DeviceLookupSocScalarWhereWithAggregatesInput | DeviceLookupSocScalarWhereWithAggregatesInput[]
    OR?: DeviceLookupSocScalarWhereWithAggregatesInput[]
    NOT?: DeviceLookupSocScalarWhereWithAggregatesInput | DeviceLookupSocScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceLookupSoc"> | number
    name?: StringWithAggregatesFilter<"DeviceLookupSoc"> | string
  }

  export type DeviceMapArchitectureWhereInput = {
    AND?: DeviceMapArchitectureWhereInput | DeviceMapArchitectureWhereInput[]
    OR?: DeviceMapArchitectureWhereInput[]
    NOT?: DeviceMapArchitectureWhereInput | DeviceMapArchitectureWhereInput[]
    device_id?: IntFilter<"DeviceMapArchitecture"> | number
    architecture_id?: IntFilter<"DeviceMapArchitecture"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    DeviceLookupArchitecture?: XOR<DeviceLookupArchitectureScalarRelationFilter, DeviceLookupArchitectureWhereInput>
  }

  export type DeviceMapArchitectureOrderByWithRelationInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
    DeviceLookupArchitecture?: DeviceLookupArchitectureOrderByWithRelationInput
  }

  export type DeviceMapArchitectureWhereUniqueInput = Prisma.AtLeast<{
    device_id_architecture_id?: DeviceMapArchitectureDevice_idArchitecture_idCompoundUniqueInput
    AND?: DeviceMapArchitectureWhereInput | DeviceMapArchitectureWhereInput[]
    OR?: DeviceMapArchitectureWhereInput[]
    NOT?: DeviceMapArchitectureWhereInput | DeviceMapArchitectureWhereInput[]
    device_id?: IntFilter<"DeviceMapArchitecture"> | number
    architecture_id?: IntFilter<"DeviceMapArchitecture"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    DeviceLookupArchitecture?: XOR<DeviceLookupArchitectureScalarRelationFilter, DeviceLookupArchitectureWhereInput>
  }, "device_id_architecture_id">

  export type DeviceMapArchitectureOrderByWithAggregationInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
    _count?: DeviceMapArchitectureCountOrderByAggregateInput
    _avg?: DeviceMapArchitectureAvgOrderByAggregateInput
    _max?: DeviceMapArchitectureMaxOrderByAggregateInput
    _min?: DeviceMapArchitectureMinOrderByAggregateInput
    _sum?: DeviceMapArchitectureSumOrderByAggregateInput
  }

  export type DeviceMapArchitectureScalarWhereWithAggregatesInput = {
    AND?: DeviceMapArchitectureScalarWhereWithAggregatesInput | DeviceMapArchitectureScalarWhereWithAggregatesInput[]
    OR?: DeviceMapArchitectureScalarWhereWithAggregatesInput[]
    NOT?: DeviceMapArchitectureScalarWhereWithAggregatesInput | DeviceMapArchitectureScalarWhereWithAggregatesInput[]
    device_id?: IntWithAggregatesFilter<"DeviceMapArchitecture"> | number
    architecture_id?: IntWithAggregatesFilter<"DeviceMapArchitecture"> | number
  }

  export type DeviceMapIdentifierWhereInput = {
    AND?: DeviceMapIdentifierWhereInput | DeviceMapIdentifierWhereInput[]
    OR?: DeviceMapIdentifierWhereInput[]
    NOT?: DeviceMapIdentifierWhereInput | DeviceMapIdentifierWhereInput[]
    device_id?: IntFilter<"DeviceMapIdentifier"> | number
    identifier?: StringFilter<"DeviceMapIdentifier"> | string
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }

  export type DeviceMapIdentifierOrderByWithRelationInput = {
    device_id?: SortOrder
    identifier?: SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
    _relevance?: DeviceMapIdentifierOrderByRelevanceInput
  }

  export type DeviceMapIdentifierWhereUniqueInput = Prisma.AtLeast<{
    device_id_identifier?: DeviceMapIdentifierDevice_idIdentifierCompoundUniqueInput
    AND?: DeviceMapIdentifierWhereInput | DeviceMapIdentifierWhereInput[]
    OR?: DeviceMapIdentifierWhereInput[]
    NOT?: DeviceMapIdentifierWhereInput | DeviceMapIdentifierWhereInput[]
    device_id?: IntFilter<"DeviceMapIdentifier"> | number
    identifier?: StringFilter<"DeviceMapIdentifier"> | string
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }, "device_id_identifier">

  export type DeviceMapIdentifierOrderByWithAggregationInput = {
    device_id?: SortOrder
    identifier?: SortOrder
    _count?: DeviceMapIdentifierCountOrderByAggregateInput
    _avg?: DeviceMapIdentifierAvgOrderByAggregateInput
    _max?: DeviceMapIdentifierMaxOrderByAggregateInput
    _min?: DeviceMapIdentifierMinOrderByAggregateInput
    _sum?: DeviceMapIdentifierSumOrderByAggregateInput
  }

  export type DeviceMapIdentifierScalarWhereWithAggregatesInput = {
    AND?: DeviceMapIdentifierScalarWhereWithAggregatesInput | DeviceMapIdentifierScalarWhereWithAggregatesInput[]
    OR?: DeviceMapIdentifierScalarWhereWithAggregatesInput[]
    NOT?: DeviceMapIdentifierScalarWhereWithAggregatesInput | DeviceMapIdentifierScalarWhereWithAggregatesInput[]
    device_id?: IntWithAggregatesFilter<"DeviceMapIdentifier"> | number
    identifier?: StringWithAggregatesFilter<"DeviceMapIdentifier"> | string
  }

  export type DeviceMapModelWhereInput = {
    AND?: DeviceMapModelWhereInput | DeviceMapModelWhereInput[]
    OR?: DeviceMapModelWhereInput[]
    NOT?: DeviceMapModelWhereInput | DeviceMapModelWhereInput[]
    device_id?: IntFilter<"DeviceMapModel"> | number
    model?: StringFilter<"DeviceMapModel"> | string
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }

  export type DeviceMapModelOrderByWithRelationInput = {
    device_id?: SortOrder
    model?: SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
    _relevance?: DeviceMapModelOrderByRelevanceInput
  }

  export type DeviceMapModelWhereUniqueInput = Prisma.AtLeast<{
    device_id_model?: DeviceMapModelDevice_idModelCompoundUniqueInput
    AND?: DeviceMapModelWhereInput | DeviceMapModelWhereInput[]
    OR?: DeviceMapModelWhereInput[]
    NOT?: DeviceMapModelWhereInput | DeviceMapModelWhereInput[]
    device_id?: IntFilter<"DeviceMapModel"> | number
    model?: StringFilter<"DeviceMapModel"> | string
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }, "device_id_model">

  export type DeviceMapModelOrderByWithAggregationInput = {
    device_id?: SortOrder
    model?: SortOrder
    _count?: DeviceMapModelCountOrderByAggregateInput
    _avg?: DeviceMapModelAvgOrderByAggregateInput
    _max?: DeviceMapModelMaxOrderByAggregateInput
    _min?: DeviceMapModelMinOrderByAggregateInput
    _sum?: DeviceMapModelSumOrderByAggregateInput
  }

  export type DeviceMapModelScalarWhereWithAggregatesInput = {
    AND?: DeviceMapModelScalarWhereWithAggregatesInput | DeviceMapModelScalarWhereWithAggregatesInput[]
    OR?: DeviceMapModelScalarWhereWithAggregatesInput[]
    NOT?: DeviceMapModelScalarWhereWithAggregatesInput | DeviceMapModelScalarWhereWithAggregatesInput[]
    device_id?: IntWithAggregatesFilter<"DeviceMapModel"> | number
    model?: StringWithAggregatesFilter<"DeviceMapModel"> | string
  }

  export type DeviceMapReleaseWhereInput = {
    AND?: DeviceMapReleaseWhereInput | DeviceMapReleaseWhereInput[]
    OR?: DeviceMapReleaseWhereInput[]
    NOT?: DeviceMapReleaseWhereInput | DeviceMapReleaseWhereInput[]
    id?: IntFilter<"DeviceMapRelease"> | number
    device_id?: IntNullableFilter<"DeviceMapRelease"> | number | null
    datetime?: DateTimeNullableFilter<"DeviceMapRelease"> | Date | string | null
    depth?: IntNullableFilter<"DeviceMapRelease"> | number | null
    DeviceEntry?: XOR<DeviceEntryNullableScalarRelationFilter, DeviceEntryWhereInput> | null
  }

  export type DeviceMapReleaseOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    datetime?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
  }

  export type DeviceMapReleaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceMapReleaseWhereInput | DeviceMapReleaseWhereInput[]
    OR?: DeviceMapReleaseWhereInput[]
    NOT?: DeviceMapReleaseWhereInput | DeviceMapReleaseWhereInput[]
    device_id?: IntNullableFilter<"DeviceMapRelease"> | number | null
    datetime?: DateTimeNullableFilter<"DeviceMapRelease"> | Date | string | null
    depth?: IntNullableFilter<"DeviceMapRelease"> | number | null
    DeviceEntry?: XOR<DeviceEntryNullableScalarRelationFilter, DeviceEntryWhereInput> | null
  }, "id">

  export type DeviceMapReleaseOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    datetime?: SortOrderInput | SortOrder
    depth?: SortOrderInput | SortOrder
    _count?: DeviceMapReleaseCountOrderByAggregateInput
    _avg?: DeviceMapReleaseAvgOrderByAggregateInput
    _max?: DeviceMapReleaseMaxOrderByAggregateInput
    _min?: DeviceMapReleaseMinOrderByAggregateInput
    _sum?: DeviceMapReleaseSumOrderByAggregateInput
  }

  export type DeviceMapReleaseScalarWhereWithAggregatesInput = {
    AND?: DeviceMapReleaseScalarWhereWithAggregatesInput | DeviceMapReleaseScalarWhereWithAggregatesInput[]
    OR?: DeviceMapReleaseScalarWhereWithAggregatesInput[]
    NOT?: DeviceMapReleaseScalarWhereWithAggregatesInput | DeviceMapReleaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceMapRelease"> | number
    device_id?: IntNullableWithAggregatesFilter<"DeviceMapRelease"> | number | null
    datetime?: DateTimeNullableWithAggregatesFilter<"DeviceMapRelease"> | Date | string | null
    depth?: IntNullableWithAggregatesFilter<"DeviceMapRelease"> | number | null
  }

  export type DeviceMapSocWhereInput = {
    AND?: DeviceMapSocWhereInput | DeviceMapSocWhereInput[]
    OR?: DeviceMapSocWhereInput[]
    NOT?: DeviceMapSocWhereInput | DeviceMapSocWhereInput[]
    device_id?: IntFilter<"DeviceMapSoc"> | number
    soc_id?: IntFilter<"DeviceMapSoc"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    DeviceLookupSoc?: XOR<DeviceLookupSocScalarRelationFilter, DeviceLookupSocWhereInput>
  }

  export type DeviceMapSocOrderByWithRelationInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
    DeviceLookupSoc?: DeviceLookupSocOrderByWithRelationInput
  }

  export type DeviceMapSocWhereUniqueInput = Prisma.AtLeast<{
    device_id_soc_id?: DeviceMapSocDevice_idSoc_idCompoundUniqueInput
    AND?: DeviceMapSocWhereInput | DeviceMapSocWhereInput[]
    OR?: DeviceMapSocWhereInput[]
    NOT?: DeviceMapSocWhereInput | DeviceMapSocWhereInput[]
    device_id?: IntFilter<"DeviceMapSoc"> | number
    soc_id?: IntFilter<"DeviceMapSoc"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    DeviceLookupSoc?: XOR<DeviceLookupSocScalarRelationFilter, DeviceLookupSocWhereInput>
  }, "device_id_soc_id">

  export type DeviceMapSocOrderByWithAggregationInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
    _count?: DeviceMapSocCountOrderByAggregateInput
    _avg?: DeviceMapSocAvgOrderByAggregateInput
    _max?: DeviceMapSocMaxOrderByAggregateInput
    _min?: DeviceMapSocMinOrderByAggregateInput
    _sum?: DeviceMapSocSumOrderByAggregateInput
  }

  export type DeviceMapSocScalarWhereWithAggregatesInput = {
    AND?: DeviceMapSocScalarWhereWithAggregatesInput | DeviceMapSocScalarWhereWithAggregatesInput[]
    OR?: DeviceMapSocScalarWhereWithAggregatesInput[]
    NOT?: DeviceMapSocScalarWhereWithAggregatesInput | DeviceMapSocScalarWhereWithAggregatesInput[]
    device_id?: IntWithAggregatesFilter<"DeviceMapSoc"> | number
    soc_id?: IntWithAggregatesFilter<"DeviceMapSoc"> | number
  }

  export type MapDeviceOsWhereInput = {
    AND?: MapDeviceOsWhereInput | MapDeviceOsWhereInput[]
    OR?: MapDeviceOsWhereInput[]
    NOT?: MapDeviceOsWhereInput | MapDeviceOsWhereInput[]
    device_id?: IntFilter<"MapDeviceOs"> | number
    os_id?: IntFilter<"MapDeviceOs"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type MapDeviceOsOrderByWithRelationInput = {
    device_id?: SortOrder
    os_id?: SortOrder
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
    OsEntry?: OsEntryOrderByWithRelationInput
  }

  export type MapDeviceOsWhereUniqueInput = Prisma.AtLeast<{
    device_id_os_id?: MapDeviceOsDevice_idOs_idCompoundUniqueInput
    AND?: MapDeviceOsWhereInput | MapDeviceOsWhereInput[]
    OR?: MapDeviceOsWhereInput[]
    NOT?: MapDeviceOsWhereInput | MapDeviceOsWhereInput[]
    device_id?: IntFilter<"MapDeviceOs"> | number
    os_id?: IntFilter<"MapDeviceOs"> | number
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "device_id_os_id">

  export type MapDeviceOsOrderByWithAggregationInput = {
    device_id?: SortOrder
    os_id?: SortOrder
    _count?: MapDeviceOsCountOrderByAggregateInput
    _avg?: MapDeviceOsAvgOrderByAggregateInput
    _max?: MapDeviceOsMaxOrderByAggregateInput
    _min?: MapDeviceOsMinOrderByAggregateInput
    _sum?: MapDeviceOsSumOrderByAggregateInput
  }

  export type MapDeviceOsScalarWhereWithAggregatesInput = {
    AND?: MapDeviceOsScalarWhereWithAggregatesInput | MapDeviceOsScalarWhereWithAggregatesInput[]
    OR?: MapDeviceOsScalarWhereWithAggregatesInput[]
    NOT?: MapDeviceOsScalarWhereWithAggregatesInput | MapDeviceOsScalarWhereWithAggregatesInput[]
    device_id?: IntWithAggregatesFilter<"MapDeviceOs"> | number
    os_id?: IntWithAggregatesFilter<"MapDeviceOs"> | number
  }

  export type OsEntryWhereInput = {
    AND?: OsEntryWhereInput | OsEntryWhereInput[]
    OR?: OsEntryWhereInput[]
    NOT?: OsEntryWhereInput | OsEntryWhereInput[]
    id?: IntFilter<"OsEntry"> | number
    name_id?: IntFilter<"OsEntry"> | number
    version?: StringFilter<"OsEntry"> | string
    build?: StringNullableFilter<"OsEntry"> | string | null
    release_datetime?: DateTimeNullableFilter<"OsEntry"> | Date | string | null
    release_datetime_depth?: IntNullableFilter<"OsEntry"> | number | null
    is_release?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_beta?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rc?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_internal?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rsr?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_sdk?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_simulator?: BoolNullableFilter<"OsEntry"> | boolean | null
    image_id?: StringNullableFilter<"OsEntry"> | string | null
    embedded_os_build?: StringNullableFilter<"OsEntry"> | string | null
    bridge_os_build?: StringNullableFilter<"OsEntry"> | string | null
    notes?: StringNullableFilter<"OsEntry"> | string | null
    legacy_unique_key?: StringNullableFilter<"OsEntry"> | string | null
    search?: StringNullableFilter<"OsEntry"> | string | null
    MapDeviceOs?: MapDeviceOsListRelationFilter
    OsLookupName?: XOR<OsLookupNameScalarRelationFilter, OsLookupNameWhereInput>
    OsEntryBuildTrain?: OsEntryBuildTrainListRelationFilter
    OsEntryIpd?: OsEntryIpdListRelationFilter
    OsEntryOsStringMap?: OsEntryOsStringMapListRelationFilter
    OsEntryPreinstalled?: OsEntryPreinstalledListRelationFilter
    OsEntryReleaseNote?: OsEntryReleaseNoteListRelationFilter
    OsEntrySafariVersion?: OsEntrySafariVersionListRelationFilter
    OsEntrySecurityNote?: OsEntrySecurityNoteListRelationFilter
    SourceEntry?: SourceEntryListRelationFilter
  }

  export type OsEntryOrderByWithRelationInput = {
    id?: SortOrder
    name_id?: SortOrder
    version?: SortOrder
    build?: SortOrderInput | SortOrder
    release_datetime?: SortOrderInput | SortOrder
    release_datetime_depth?: SortOrderInput | SortOrder
    is_release?: SortOrderInput | SortOrder
    is_beta?: SortOrderInput | SortOrder
    is_rc?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    is_rsr?: SortOrderInput | SortOrder
    is_sdk?: SortOrderInput | SortOrder
    is_simulator?: SortOrderInput | SortOrder
    image_id?: SortOrderInput | SortOrder
    embedded_os_build?: SortOrderInput | SortOrder
    bridge_os_build?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    search?: SortOrderInput | SortOrder
    MapDeviceOs?: MapDeviceOsOrderByRelationAggregateInput
    OsLookupName?: OsLookupNameOrderByWithRelationInput
    OsEntryBuildTrain?: OsEntryBuildTrainOrderByRelationAggregateInput
    OsEntryIpd?: OsEntryIpdOrderByRelationAggregateInput
    OsEntryOsStringMap?: OsEntryOsStringMapOrderByRelationAggregateInput
    OsEntryPreinstalled?: OsEntryPreinstalledOrderByRelationAggregateInput
    OsEntryReleaseNote?: OsEntryReleaseNoteOrderByRelationAggregateInput
    OsEntrySafariVersion?: OsEntrySafariVersionOrderByRelationAggregateInput
    OsEntrySecurityNote?: OsEntrySecurityNoteOrderByRelationAggregateInput
    SourceEntry?: SourceEntryOrderByRelationAggregateInput
    _relevance?: OsEntryOrderByRelevanceInput
  }

  export type OsEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OsEntryWhereInput | OsEntryWhereInput[]
    OR?: OsEntryWhereInput[]
    NOT?: OsEntryWhereInput | OsEntryWhereInput[]
    name_id?: IntFilter<"OsEntry"> | number
    version?: StringFilter<"OsEntry"> | string
    build?: StringNullableFilter<"OsEntry"> | string | null
    release_datetime?: DateTimeNullableFilter<"OsEntry"> | Date | string | null
    release_datetime_depth?: IntNullableFilter<"OsEntry"> | number | null
    is_release?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_beta?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rc?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_internal?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rsr?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_sdk?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_simulator?: BoolNullableFilter<"OsEntry"> | boolean | null
    image_id?: StringNullableFilter<"OsEntry"> | string | null
    embedded_os_build?: StringNullableFilter<"OsEntry"> | string | null
    bridge_os_build?: StringNullableFilter<"OsEntry"> | string | null
    notes?: StringNullableFilter<"OsEntry"> | string | null
    legacy_unique_key?: StringNullableFilter<"OsEntry"> | string | null
    search?: StringNullableFilter<"OsEntry"> | string | null
    MapDeviceOs?: MapDeviceOsListRelationFilter
    OsLookupName?: XOR<OsLookupNameScalarRelationFilter, OsLookupNameWhereInput>
    OsEntryBuildTrain?: OsEntryBuildTrainListRelationFilter
    OsEntryIpd?: OsEntryIpdListRelationFilter
    OsEntryOsStringMap?: OsEntryOsStringMapListRelationFilter
    OsEntryPreinstalled?: OsEntryPreinstalledListRelationFilter
    OsEntryReleaseNote?: OsEntryReleaseNoteListRelationFilter
    OsEntrySafariVersion?: OsEntrySafariVersionListRelationFilter
    OsEntrySecurityNote?: OsEntrySecurityNoteListRelationFilter
    SourceEntry?: SourceEntryListRelationFilter
  }, "id">

  export type OsEntryOrderByWithAggregationInput = {
    id?: SortOrder
    name_id?: SortOrder
    version?: SortOrder
    build?: SortOrderInput | SortOrder
    release_datetime?: SortOrderInput | SortOrder
    release_datetime_depth?: SortOrderInput | SortOrder
    is_release?: SortOrderInput | SortOrder
    is_beta?: SortOrderInput | SortOrder
    is_rc?: SortOrderInput | SortOrder
    is_internal?: SortOrderInput | SortOrder
    is_rsr?: SortOrderInput | SortOrder
    is_sdk?: SortOrderInput | SortOrder
    is_simulator?: SortOrderInput | SortOrder
    image_id?: SortOrderInput | SortOrder
    embedded_os_build?: SortOrderInput | SortOrder
    bridge_os_build?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    legacy_unique_key?: SortOrderInput | SortOrder
    search?: SortOrderInput | SortOrder
    _count?: OsEntryCountOrderByAggregateInput
    _avg?: OsEntryAvgOrderByAggregateInput
    _max?: OsEntryMaxOrderByAggregateInput
    _min?: OsEntryMinOrderByAggregateInput
    _sum?: OsEntrySumOrderByAggregateInput
  }

  export type OsEntryScalarWhereWithAggregatesInput = {
    AND?: OsEntryScalarWhereWithAggregatesInput | OsEntryScalarWhereWithAggregatesInput[]
    OR?: OsEntryScalarWhereWithAggregatesInput[]
    NOT?: OsEntryScalarWhereWithAggregatesInput | OsEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OsEntry"> | number
    name_id?: IntWithAggregatesFilter<"OsEntry"> | number
    version?: StringWithAggregatesFilter<"OsEntry"> | string
    build?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    release_datetime?: DateTimeNullableWithAggregatesFilter<"OsEntry"> | Date | string | null
    release_datetime_depth?: IntNullableWithAggregatesFilter<"OsEntry"> | number | null
    is_release?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_beta?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_rc?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_internal?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_rsr?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_sdk?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    is_simulator?: BoolNullableWithAggregatesFilter<"OsEntry"> | boolean | null
    image_id?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    embedded_os_build?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    bridge_os_build?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    notes?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    legacy_unique_key?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
    search?: StringNullableWithAggregatesFilter<"OsEntry"> | string | null
  }

  export type OsEntryBuildTrainWhereInput = {
    AND?: OsEntryBuildTrainWhereInput | OsEntryBuildTrainWhereInput[]
    OR?: OsEntryBuildTrainWhereInput[]
    NOT?: OsEntryBuildTrainWhereInput | OsEntryBuildTrainWhereInput[]
    os_id?: IntFilter<"OsEntryBuildTrain"> | number
    build_train?: StringFilter<"OsEntryBuildTrain"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntryBuildTrainOrderByWithRelationInput = {
    os_id?: SortOrder
    build_train?: SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntryBuildTrainOrderByRelevanceInput
  }

  export type OsEntryBuildTrainWhereUniqueInput = Prisma.AtLeast<{
    os_id_build_train?: OsEntryBuildTrainOs_idBuild_trainCompoundUniqueInput
    AND?: OsEntryBuildTrainWhereInput | OsEntryBuildTrainWhereInput[]
    OR?: OsEntryBuildTrainWhereInput[]
    NOT?: OsEntryBuildTrainWhereInput | OsEntryBuildTrainWhereInput[]
    os_id?: IntFilter<"OsEntryBuildTrain"> | number
    build_train?: StringFilter<"OsEntryBuildTrain"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_build_train">

  export type OsEntryBuildTrainOrderByWithAggregationInput = {
    os_id?: SortOrder
    build_train?: SortOrder
    _count?: OsEntryBuildTrainCountOrderByAggregateInput
    _avg?: OsEntryBuildTrainAvgOrderByAggregateInput
    _max?: OsEntryBuildTrainMaxOrderByAggregateInput
    _min?: OsEntryBuildTrainMinOrderByAggregateInput
    _sum?: OsEntryBuildTrainSumOrderByAggregateInput
  }

  export type OsEntryBuildTrainScalarWhereWithAggregatesInput = {
    AND?: OsEntryBuildTrainScalarWhereWithAggregatesInput | OsEntryBuildTrainScalarWhereWithAggregatesInput[]
    OR?: OsEntryBuildTrainScalarWhereWithAggregatesInput[]
    NOT?: OsEntryBuildTrainScalarWhereWithAggregatesInput | OsEntryBuildTrainScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntryBuildTrain"> | number
    build_train?: StringWithAggregatesFilter<"OsEntryBuildTrain"> | string
  }

  export type OsEntryIpdWhereInput = {
    AND?: OsEntryIpdWhereInput | OsEntryIpdWhereInput[]
    OR?: OsEntryIpdWhereInput[]
    NOT?: OsEntryIpdWhereInput | OsEntryIpdWhereInput[]
    os_id?: IntFilter<"OsEntryIpd"> | number
    ipd_type?: StringFilter<"OsEntryIpd"> | string
    url?: StringNullableFilter<"OsEntryIpd"> | string | null
    active?: BoolNullableFilter<"OsEntryIpd"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntryIpdOrderByWithRelationInput = {
    os_id?: SortOrder
    ipd_type?: SortOrder
    url?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntryIpdOrderByRelevanceInput
  }

  export type OsEntryIpdWhereUniqueInput = Prisma.AtLeast<{
    os_id_ipd_type?: OsEntryIpdOs_idIpd_typeCompoundUniqueInput
    AND?: OsEntryIpdWhereInput | OsEntryIpdWhereInput[]
    OR?: OsEntryIpdWhereInput[]
    NOT?: OsEntryIpdWhereInput | OsEntryIpdWhereInput[]
    os_id?: IntFilter<"OsEntryIpd"> | number
    ipd_type?: StringFilter<"OsEntryIpd"> | string
    url?: StringNullableFilter<"OsEntryIpd"> | string | null
    active?: BoolNullableFilter<"OsEntryIpd"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_ipd_type">

  export type OsEntryIpdOrderByWithAggregationInput = {
    os_id?: SortOrder
    ipd_type?: SortOrder
    url?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    _count?: OsEntryIpdCountOrderByAggregateInput
    _avg?: OsEntryIpdAvgOrderByAggregateInput
    _max?: OsEntryIpdMaxOrderByAggregateInput
    _min?: OsEntryIpdMinOrderByAggregateInput
    _sum?: OsEntryIpdSumOrderByAggregateInput
  }

  export type OsEntryIpdScalarWhereWithAggregatesInput = {
    AND?: OsEntryIpdScalarWhereWithAggregatesInput | OsEntryIpdScalarWhereWithAggregatesInput[]
    OR?: OsEntryIpdScalarWhereWithAggregatesInput[]
    NOT?: OsEntryIpdScalarWhereWithAggregatesInput | OsEntryIpdScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntryIpd"> | number
    ipd_type?: StringWithAggregatesFilter<"OsEntryIpd"> | string
    url?: StringNullableWithAggregatesFilter<"OsEntryIpd"> | string | null
    active?: BoolNullableWithAggregatesFilter<"OsEntryIpd"> | boolean | null
  }

  export type OsEntryOsStringMapWhereInput = {
    AND?: OsEntryOsStringMapWhereInput | OsEntryOsStringMapWhereInput[]
    OR?: OsEntryOsStringMapWhereInput[]
    NOT?: OsEntryOsStringMapWhereInput | OsEntryOsStringMapWhereInput[]
    os_id?: IntFilter<"OsEntryOsStringMap"> | number
    os_string?: StringFilter<"OsEntryOsStringMap"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntryOsStringMapOrderByWithRelationInput = {
    os_id?: SortOrder
    os_string?: SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntryOsStringMapOrderByRelevanceInput
  }

  export type OsEntryOsStringMapWhereUniqueInput = Prisma.AtLeast<{
    os_id_os_string?: OsEntryOsStringMapOs_idOs_stringCompoundUniqueInput
    AND?: OsEntryOsStringMapWhereInput | OsEntryOsStringMapWhereInput[]
    OR?: OsEntryOsStringMapWhereInput[]
    NOT?: OsEntryOsStringMapWhereInput | OsEntryOsStringMapWhereInput[]
    os_id?: IntFilter<"OsEntryOsStringMap"> | number
    os_string?: StringFilter<"OsEntryOsStringMap"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_os_string">

  export type OsEntryOsStringMapOrderByWithAggregationInput = {
    os_id?: SortOrder
    os_string?: SortOrder
    _count?: OsEntryOsStringMapCountOrderByAggregateInput
    _avg?: OsEntryOsStringMapAvgOrderByAggregateInput
    _max?: OsEntryOsStringMapMaxOrderByAggregateInput
    _min?: OsEntryOsStringMapMinOrderByAggregateInput
    _sum?: OsEntryOsStringMapSumOrderByAggregateInput
  }

  export type OsEntryOsStringMapScalarWhereWithAggregatesInput = {
    AND?: OsEntryOsStringMapScalarWhereWithAggregatesInput | OsEntryOsStringMapScalarWhereWithAggregatesInput[]
    OR?: OsEntryOsStringMapScalarWhereWithAggregatesInput[]
    NOT?: OsEntryOsStringMapScalarWhereWithAggregatesInput | OsEntryOsStringMapScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntryOsStringMap"> | number
    os_string?: StringWithAggregatesFilter<"OsEntryOsStringMap"> | string
  }

  export type OsEntryPreinstalledWhereInput = {
    AND?: OsEntryPreinstalledWhereInput | OsEntryPreinstalledWhereInput[]
    OR?: OsEntryPreinstalledWhereInput[]
    NOT?: OsEntryPreinstalledWhereInput | OsEntryPreinstalledWhereInput[]
    os_id?: IntFilter<"OsEntryPreinstalled"> | number
    device_id?: IntFilter<"OsEntryPreinstalled"> | number
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }

  export type OsEntryPreinstalledOrderByWithRelationInput = {
    os_id?: SortOrder
    device_id?: SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
  }

  export type OsEntryPreinstalledWhereUniqueInput = Prisma.AtLeast<{
    os_id_device_id?: OsEntryPreinstalledOs_idDevice_idCompoundUniqueInput
    AND?: OsEntryPreinstalledWhereInput | OsEntryPreinstalledWhereInput[]
    OR?: OsEntryPreinstalledWhereInput[]
    NOT?: OsEntryPreinstalledWhereInput | OsEntryPreinstalledWhereInput[]
    os_id?: IntFilter<"OsEntryPreinstalled"> | number
    device_id?: IntFilter<"OsEntryPreinstalled"> | number
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }, "os_id_device_id">

  export type OsEntryPreinstalledOrderByWithAggregationInput = {
    os_id?: SortOrder
    device_id?: SortOrder
    _count?: OsEntryPreinstalledCountOrderByAggregateInput
    _avg?: OsEntryPreinstalledAvgOrderByAggregateInput
    _max?: OsEntryPreinstalledMaxOrderByAggregateInput
    _min?: OsEntryPreinstalledMinOrderByAggregateInput
    _sum?: OsEntryPreinstalledSumOrderByAggregateInput
  }

  export type OsEntryPreinstalledScalarWhereWithAggregatesInput = {
    AND?: OsEntryPreinstalledScalarWhereWithAggregatesInput | OsEntryPreinstalledScalarWhereWithAggregatesInput[]
    OR?: OsEntryPreinstalledScalarWhereWithAggregatesInput[]
    NOT?: OsEntryPreinstalledScalarWhereWithAggregatesInput | OsEntryPreinstalledScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntryPreinstalled"> | number
    device_id?: IntWithAggregatesFilter<"OsEntryPreinstalled"> | number
  }

  export type OsEntryReleaseNoteWhereInput = {
    AND?: OsEntryReleaseNoteWhereInput | OsEntryReleaseNoteWhereInput[]
    OR?: OsEntryReleaseNoteWhereInput[]
    NOT?: OsEntryReleaseNoteWhereInput | OsEntryReleaseNoteWhereInput[]
    os_id?: IntFilter<"OsEntryReleaseNote"> | number
    url?: StringFilter<"OsEntryReleaseNote"> | string
    active?: BoolNullableFilter<"OsEntryReleaseNote"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntryReleaseNoteOrderByWithRelationInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntryReleaseNoteOrderByRelevanceInput
  }

  export type OsEntryReleaseNoteWhereUniqueInput = Prisma.AtLeast<{
    os_id_url?: OsEntryReleaseNoteOs_idUrlCompoundUniqueInput
    AND?: OsEntryReleaseNoteWhereInput | OsEntryReleaseNoteWhereInput[]
    OR?: OsEntryReleaseNoteWhereInput[]
    NOT?: OsEntryReleaseNoteWhereInput | OsEntryReleaseNoteWhereInput[]
    os_id?: IntFilter<"OsEntryReleaseNote"> | number
    url?: StringFilter<"OsEntryReleaseNote"> | string
    active?: BoolNullableFilter<"OsEntryReleaseNote"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_url">

  export type OsEntryReleaseNoteOrderByWithAggregationInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: OsEntryReleaseNoteCountOrderByAggregateInput
    _avg?: OsEntryReleaseNoteAvgOrderByAggregateInput
    _max?: OsEntryReleaseNoteMaxOrderByAggregateInput
    _min?: OsEntryReleaseNoteMinOrderByAggregateInput
    _sum?: OsEntryReleaseNoteSumOrderByAggregateInput
  }

  export type OsEntryReleaseNoteScalarWhereWithAggregatesInput = {
    AND?: OsEntryReleaseNoteScalarWhereWithAggregatesInput | OsEntryReleaseNoteScalarWhereWithAggregatesInput[]
    OR?: OsEntryReleaseNoteScalarWhereWithAggregatesInput[]
    NOT?: OsEntryReleaseNoteScalarWhereWithAggregatesInput | OsEntryReleaseNoteScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntryReleaseNote"> | number
    url?: StringWithAggregatesFilter<"OsEntryReleaseNote"> | string
    active?: BoolNullableWithAggregatesFilter<"OsEntryReleaseNote"> | boolean | null
  }

  export type OsEntrySafariVersionWhereInput = {
    AND?: OsEntrySafariVersionWhereInput | OsEntrySafariVersionWhereInput[]
    OR?: OsEntrySafariVersionWhereInput[]
    NOT?: OsEntrySafariVersionWhereInput | OsEntrySafariVersionWhereInput[]
    os_id?: IntFilter<"OsEntrySafariVersion"> | number
    version?: StringFilter<"OsEntrySafariVersion"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntrySafariVersionOrderByWithRelationInput = {
    os_id?: SortOrder
    version?: SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntrySafariVersionOrderByRelevanceInput
  }

  export type OsEntrySafariVersionWhereUniqueInput = Prisma.AtLeast<{
    os_id_version?: OsEntrySafariVersionOs_idVersionCompoundUniqueInput
    AND?: OsEntrySafariVersionWhereInput | OsEntrySafariVersionWhereInput[]
    OR?: OsEntrySafariVersionWhereInput[]
    NOT?: OsEntrySafariVersionWhereInput | OsEntrySafariVersionWhereInput[]
    os_id?: IntFilter<"OsEntrySafariVersion"> | number
    version?: StringFilter<"OsEntrySafariVersion"> | string
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_version">

  export type OsEntrySafariVersionOrderByWithAggregationInput = {
    os_id?: SortOrder
    version?: SortOrder
    _count?: OsEntrySafariVersionCountOrderByAggregateInput
    _avg?: OsEntrySafariVersionAvgOrderByAggregateInput
    _max?: OsEntrySafariVersionMaxOrderByAggregateInput
    _min?: OsEntrySafariVersionMinOrderByAggregateInput
    _sum?: OsEntrySafariVersionSumOrderByAggregateInput
  }

  export type OsEntrySafariVersionScalarWhereWithAggregatesInput = {
    AND?: OsEntrySafariVersionScalarWhereWithAggregatesInput | OsEntrySafariVersionScalarWhereWithAggregatesInput[]
    OR?: OsEntrySafariVersionScalarWhereWithAggregatesInput[]
    NOT?: OsEntrySafariVersionScalarWhereWithAggregatesInput | OsEntrySafariVersionScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntrySafariVersion"> | number
    version?: StringWithAggregatesFilter<"OsEntrySafariVersion"> | string
  }

  export type OsEntrySecurityNoteWhereInput = {
    AND?: OsEntrySecurityNoteWhereInput | OsEntrySecurityNoteWhereInput[]
    OR?: OsEntrySecurityNoteWhereInput[]
    NOT?: OsEntrySecurityNoteWhereInput | OsEntrySecurityNoteWhereInput[]
    os_id?: IntFilter<"OsEntrySecurityNote"> | number
    url?: StringFilter<"OsEntrySecurityNote"> | string
    active?: BoolNullableFilter<"OsEntrySecurityNote"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }

  export type OsEntrySecurityNoteOrderByWithRelationInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    _relevance?: OsEntrySecurityNoteOrderByRelevanceInput
  }

  export type OsEntrySecurityNoteWhereUniqueInput = Prisma.AtLeast<{
    os_id_url?: OsEntrySecurityNoteOs_idUrlCompoundUniqueInput
    AND?: OsEntrySecurityNoteWhereInput | OsEntrySecurityNoteWhereInput[]
    OR?: OsEntrySecurityNoteWhereInput[]
    NOT?: OsEntrySecurityNoteWhereInput | OsEntrySecurityNoteWhereInput[]
    os_id?: IntFilter<"OsEntrySecurityNote"> | number
    url?: StringFilter<"OsEntrySecurityNote"> | string
    active?: BoolNullableFilter<"OsEntrySecurityNote"> | boolean | null
    OsEntry?: XOR<OsEntryScalarRelationFilter, OsEntryWhereInput>
  }, "os_id_url">

  export type OsEntrySecurityNoteOrderByWithAggregationInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: OsEntrySecurityNoteCountOrderByAggregateInput
    _avg?: OsEntrySecurityNoteAvgOrderByAggregateInput
    _max?: OsEntrySecurityNoteMaxOrderByAggregateInput
    _min?: OsEntrySecurityNoteMinOrderByAggregateInput
    _sum?: OsEntrySecurityNoteSumOrderByAggregateInput
  }

  export type OsEntrySecurityNoteScalarWhereWithAggregatesInput = {
    AND?: OsEntrySecurityNoteScalarWhereWithAggregatesInput | OsEntrySecurityNoteScalarWhereWithAggregatesInput[]
    OR?: OsEntrySecurityNoteScalarWhereWithAggregatesInput[]
    NOT?: OsEntrySecurityNoteScalarWhereWithAggregatesInput | OsEntrySecurityNoteScalarWhereWithAggregatesInput[]
    os_id?: IntWithAggregatesFilter<"OsEntrySecurityNote"> | number
    url?: StringWithAggregatesFilter<"OsEntrySecurityNote"> | string
    active?: BoolNullableWithAggregatesFilter<"OsEntrySecurityNote"> | boolean | null
  }

  export type OsLookupNameWhereInput = {
    AND?: OsLookupNameWhereInput | OsLookupNameWhereInput[]
    OR?: OsLookupNameWhereInput[]
    NOT?: OsLookupNameWhereInput | OsLookupNameWhereInput[]
    id?: IntFilter<"OsLookupName"> | number
    name?: StringFilter<"OsLookupName"> | string
    priority?: IntNullableFilter<"OsLookupName"> | number | null
    OsEntry?: OsEntryListRelationFilter
  }

  export type OsLookupNameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    priority?: SortOrderInput | SortOrder
    OsEntry?: OsEntryOrderByRelationAggregateInput
    _relevance?: OsLookupNameOrderByRelevanceInput
  }

  export type OsLookupNameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: OsLookupNameWhereInput | OsLookupNameWhereInput[]
    OR?: OsLookupNameWhereInput[]
    NOT?: OsLookupNameWhereInput | OsLookupNameWhereInput[]
    priority?: IntNullableFilter<"OsLookupName"> | number | null
    OsEntry?: OsEntryListRelationFilter
  }, "id" | "name">

  export type OsLookupNameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    priority?: SortOrderInput | SortOrder
    _count?: OsLookupNameCountOrderByAggregateInput
    _avg?: OsLookupNameAvgOrderByAggregateInput
    _max?: OsLookupNameMaxOrderByAggregateInput
    _min?: OsLookupNameMinOrderByAggregateInput
    _sum?: OsLookupNameSumOrderByAggregateInput
  }

  export type OsLookupNameScalarWhereWithAggregatesInput = {
    AND?: OsLookupNameScalarWhereWithAggregatesInput | OsLookupNameScalarWhereWithAggregatesInput[]
    OR?: OsLookupNameScalarWhereWithAggregatesInput[]
    NOT?: OsLookupNameScalarWhereWithAggregatesInput | OsLookupNameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OsLookupName"> | number
    name?: StringWithAggregatesFilter<"OsLookupName"> | string
    priority?: IntNullableWithAggregatesFilter<"OsLookupName"> | number | null
  }

  export type SourceEntryWhereInput = {
    AND?: SourceEntryWhereInput | SourceEntryWhereInput[]
    OR?: SourceEntryWhereInput[]
    NOT?: SourceEntryWhereInput | SourceEntryWhereInput[]
    id?: IntFilter<"SourceEntry"> | number
    os_id?: IntNullableFilter<"SourceEntry"> | number | null
    source_type?: StringNullableFilter<"SourceEntry"> | string | null
    skip_update_links?: BoolNullableFilter<"SourceEntry"> | boolean | null
    size?: BigIntNullableFilter<"SourceEntry"> | bigint | number | null
    windows_update_id?: StringNullableFilter<"SourceEntry"> | string | null
    windows_revision_id?: StringNullableFilter<"SourceEntry"> | string | null
    OsEntry?: XOR<OsEntryNullableScalarRelationFilter, OsEntryWhereInput> | null
    SourceHash?: SourceHashListRelationFilter
    SourceLink?: SourceLinkListRelationFilter
    SourceMapDevice?: SourceMapDeviceListRelationFilter
    SourcePrequisiteBuild?: SourcePrequisiteBuildListRelationFilter
  }

  export type SourceEntryOrderByWithRelationInput = {
    id?: SortOrder
    os_id?: SortOrderInput | SortOrder
    source_type?: SortOrderInput | SortOrder
    skip_update_links?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    windows_update_id?: SortOrderInput | SortOrder
    windows_revision_id?: SortOrderInput | SortOrder
    OsEntry?: OsEntryOrderByWithRelationInput
    SourceHash?: SourceHashOrderByRelationAggregateInput
    SourceLink?: SourceLinkOrderByRelationAggregateInput
    SourceMapDevice?: SourceMapDeviceOrderByRelationAggregateInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildOrderByRelationAggregateInput
    _relevance?: SourceEntryOrderByRelevanceInput
  }

  export type SourceEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SourceEntryWhereInput | SourceEntryWhereInput[]
    OR?: SourceEntryWhereInput[]
    NOT?: SourceEntryWhereInput | SourceEntryWhereInput[]
    os_id?: IntNullableFilter<"SourceEntry"> | number | null
    source_type?: StringNullableFilter<"SourceEntry"> | string | null
    skip_update_links?: BoolNullableFilter<"SourceEntry"> | boolean | null
    size?: BigIntNullableFilter<"SourceEntry"> | bigint | number | null
    windows_update_id?: StringNullableFilter<"SourceEntry"> | string | null
    windows_revision_id?: StringNullableFilter<"SourceEntry"> | string | null
    OsEntry?: XOR<OsEntryNullableScalarRelationFilter, OsEntryWhereInput> | null
    SourceHash?: SourceHashListRelationFilter
    SourceLink?: SourceLinkListRelationFilter
    SourceMapDevice?: SourceMapDeviceListRelationFilter
    SourcePrequisiteBuild?: SourcePrequisiteBuildListRelationFilter
  }, "id">

  export type SourceEntryOrderByWithAggregationInput = {
    id?: SortOrder
    os_id?: SortOrderInput | SortOrder
    source_type?: SortOrderInput | SortOrder
    skip_update_links?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    windows_update_id?: SortOrderInput | SortOrder
    windows_revision_id?: SortOrderInput | SortOrder
    _count?: SourceEntryCountOrderByAggregateInput
    _avg?: SourceEntryAvgOrderByAggregateInput
    _max?: SourceEntryMaxOrderByAggregateInput
    _min?: SourceEntryMinOrderByAggregateInput
    _sum?: SourceEntrySumOrderByAggregateInput
  }

  export type SourceEntryScalarWhereWithAggregatesInput = {
    AND?: SourceEntryScalarWhereWithAggregatesInput | SourceEntryScalarWhereWithAggregatesInput[]
    OR?: SourceEntryScalarWhereWithAggregatesInput[]
    NOT?: SourceEntryScalarWhereWithAggregatesInput | SourceEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SourceEntry"> | number
    os_id?: IntNullableWithAggregatesFilter<"SourceEntry"> | number | null
    source_type?: StringNullableWithAggregatesFilter<"SourceEntry"> | string | null
    skip_update_links?: BoolNullableWithAggregatesFilter<"SourceEntry"> | boolean | null
    size?: BigIntNullableWithAggregatesFilter<"SourceEntry"> | bigint | number | null
    windows_update_id?: StringNullableWithAggregatesFilter<"SourceEntry"> | string | null
    windows_revision_id?: StringNullableWithAggregatesFilter<"SourceEntry"> | string | null
  }

  export type SourceHashWhereInput = {
    AND?: SourceHashWhereInput | SourceHashWhereInput[]
    OR?: SourceHashWhereInput[]
    NOT?: SourceHashWhereInput | SourceHashWhereInput[]
    source_id?: IntFilter<"SourceHash"> | number
    hash_type?: StringFilter<"SourceHash"> | string
    hash_value?: StringNullableFilter<"SourceHash"> | string | null
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }

  export type SourceHashOrderByWithRelationInput = {
    source_id?: SortOrder
    hash_type?: SortOrder
    hash_value?: SortOrderInput | SortOrder
    SourceEntry?: SourceEntryOrderByWithRelationInput
    _relevance?: SourceHashOrderByRelevanceInput
  }

  export type SourceHashWhereUniqueInput = Prisma.AtLeast<{
    source_id_hash_type?: SourceHashSource_idHash_typeCompoundUniqueInput
    AND?: SourceHashWhereInput | SourceHashWhereInput[]
    OR?: SourceHashWhereInput[]
    NOT?: SourceHashWhereInput | SourceHashWhereInput[]
    source_id?: IntFilter<"SourceHash"> | number
    hash_type?: StringFilter<"SourceHash"> | string
    hash_value?: StringNullableFilter<"SourceHash"> | string | null
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }, "source_id_hash_type">

  export type SourceHashOrderByWithAggregationInput = {
    source_id?: SortOrder
    hash_type?: SortOrder
    hash_value?: SortOrderInput | SortOrder
    _count?: SourceHashCountOrderByAggregateInput
    _avg?: SourceHashAvgOrderByAggregateInput
    _max?: SourceHashMaxOrderByAggregateInput
    _min?: SourceHashMinOrderByAggregateInput
    _sum?: SourceHashSumOrderByAggregateInput
  }

  export type SourceHashScalarWhereWithAggregatesInput = {
    AND?: SourceHashScalarWhereWithAggregatesInput | SourceHashScalarWhereWithAggregatesInput[]
    OR?: SourceHashScalarWhereWithAggregatesInput[]
    NOT?: SourceHashScalarWhereWithAggregatesInput | SourceHashScalarWhereWithAggregatesInput[]
    source_id?: IntWithAggregatesFilter<"SourceHash"> | number
    hash_type?: StringWithAggregatesFilter<"SourceHash"> | string
    hash_value?: StringNullableWithAggregatesFilter<"SourceHash"> | string | null
  }

  export type SourceLinkWhereInput = {
    AND?: SourceLinkWhereInput | SourceLinkWhereInput[]
    OR?: SourceLinkWhereInput[]
    NOT?: SourceLinkWhereInput | SourceLinkWhereInput[]
    source_id?: IntFilter<"SourceLink"> | number
    url?: StringFilter<"SourceLink"> | string
    active?: BoolNullableFilter<"SourceLink"> | boolean | null
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }

  export type SourceLinkOrderByWithRelationInput = {
    source_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    SourceEntry?: SourceEntryOrderByWithRelationInput
    _relevance?: SourceLinkOrderByRelevanceInput
  }

  export type SourceLinkWhereUniqueInput = Prisma.AtLeast<{
    source_id_url?: SourceLinkSource_idUrlCompoundUniqueInput
    AND?: SourceLinkWhereInput | SourceLinkWhereInput[]
    OR?: SourceLinkWhereInput[]
    NOT?: SourceLinkWhereInput | SourceLinkWhereInput[]
    source_id?: IntFilter<"SourceLink"> | number
    url?: StringFilter<"SourceLink"> | string
    active?: BoolNullableFilter<"SourceLink"> | boolean | null
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }, "source_id_url">

  export type SourceLinkOrderByWithAggregationInput = {
    source_id?: SortOrder
    url?: SortOrder
    active?: SortOrderInput | SortOrder
    _count?: SourceLinkCountOrderByAggregateInput
    _avg?: SourceLinkAvgOrderByAggregateInput
    _max?: SourceLinkMaxOrderByAggregateInput
    _min?: SourceLinkMinOrderByAggregateInput
    _sum?: SourceLinkSumOrderByAggregateInput
  }

  export type SourceLinkScalarWhereWithAggregatesInput = {
    AND?: SourceLinkScalarWhereWithAggregatesInput | SourceLinkScalarWhereWithAggregatesInput[]
    OR?: SourceLinkScalarWhereWithAggregatesInput[]
    NOT?: SourceLinkScalarWhereWithAggregatesInput | SourceLinkScalarWhereWithAggregatesInput[]
    source_id?: IntWithAggregatesFilter<"SourceLink"> | number
    url?: StringWithAggregatesFilter<"SourceLink"> | string
    active?: BoolNullableWithAggregatesFilter<"SourceLink"> | boolean | null
  }

  export type SourceMapDeviceWhereInput = {
    AND?: SourceMapDeviceWhereInput | SourceMapDeviceWhereInput[]
    OR?: SourceMapDeviceWhereInput[]
    NOT?: SourceMapDeviceWhereInput | SourceMapDeviceWhereInput[]
    source_id?: IntFilter<"SourceMapDevice"> | number
    device_id?: IntFilter<"SourceMapDevice"> | number
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }

  export type SourceMapDeviceOrderByWithRelationInput = {
    source_id?: SortOrder
    device_id?: SortOrder
    SourceEntry?: SourceEntryOrderByWithRelationInput
    DeviceEntry?: DeviceEntryOrderByWithRelationInput
  }

  export type SourceMapDeviceWhereUniqueInput = Prisma.AtLeast<{
    source_id_device_id?: SourceMapDeviceSource_idDevice_idCompoundUniqueInput
    AND?: SourceMapDeviceWhereInput | SourceMapDeviceWhereInput[]
    OR?: SourceMapDeviceWhereInput[]
    NOT?: SourceMapDeviceWhereInput | SourceMapDeviceWhereInput[]
    source_id?: IntFilter<"SourceMapDevice"> | number
    device_id?: IntFilter<"SourceMapDevice"> | number
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
    DeviceEntry?: XOR<DeviceEntryScalarRelationFilter, DeviceEntryWhereInput>
  }, "source_id_device_id">

  export type SourceMapDeviceOrderByWithAggregationInput = {
    source_id?: SortOrder
    device_id?: SortOrder
    _count?: SourceMapDeviceCountOrderByAggregateInput
    _avg?: SourceMapDeviceAvgOrderByAggregateInput
    _max?: SourceMapDeviceMaxOrderByAggregateInput
    _min?: SourceMapDeviceMinOrderByAggregateInput
    _sum?: SourceMapDeviceSumOrderByAggregateInput
  }

  export type SourceMapDeviceScalarWhereWithAggregatesInput = {
    AND?: SourceMapDeviceScalarWhereWithAggregatesInput | SourceMapDeviceScalarWhereWithAggregatesInput[]
    OR?: SourceMapDeviceScalarWhereWithAggregatesInput[]
    NOT?: SourceMapDeviceScalarWhereWithAggregatesInput | SourceMapDeviceScalarWhereWithAggregatesInput[]
    source_id?: IntWithAggregatesFilter<"SourceMapDevice"> | number
    device_id?: IntWithAggregatesFilter<"SourceMapDevice"> | number
  }

  export type SourceMapOsStringWhereInput = {
    AND?: SourceMapOsStringWhereInput | SourceMapOsStringWhereInput[]
    OR?: SourceMapOsStringWhereInput[]
    NOT?: SourceMapOsStringWhereInput | SourceMapOsStringWhereInput[]
    source_id?: IntFilter<"SourceMapOsString"> | number
    os_string?: StringFilter<"SourceMapOsString"> | string
  }

  export type SourceMapOsStringOrderByWithRelationInput = {
    source_id?: SortOrder
    os_string?: SortOrder
    _relevance?: SourceMapOsStringOrderByRelevanceInput
  }

  export type SourceMapOsStringWhereUniqueInput = Prisma.AtLeast<{
    source_id_os_string?: SourceMapOsStringSource_idOs_stringCompoundUniqueInput
    AND?: SourceMapOsStringWhereInput | SourceMapOsStringWhereInput[]
    OR?: SourceMapOsStringWhereInput[]
    NOT?: SourceMapOsStringWhereInput | SourceMapOsStringWhereInput[]
    source_id?: IntFilter<"SourceMapOsString"> | number
    os_string?: StringFilter<"SourceMapOsString"> | string
  }, "source_id_os_string">

  export type SourceMapOsStringOrderByWithAggregationInput = {
    source_id?: SortOrder
    os_string?: SortOrder
    _count?: SourceMapOsStringCountOrderByAggregateInput
    _avg?: SourceMapOsStringAvgOrderByAggregateInput
    _max?: SourceMapOsStringMaxOrderByAggregateInput
    _min?: SourceMapOsStringMinOrderByAggregateInput
    _sum?: SourceMapOsStringSumOrderByAggregateInput
  }

  export type SourceMapOsStringScalarWhereWithAggregatesInput = {
    AND?: SourceMapOsStringScalarWhereWithAggregatesInput | SourceMapOsStringScalarWhereWithAggregatesInput[]
    OR?: SourceMapOsStringScalarWhereWithAggregatesInput[]
    NOT?: SourceMapOsStringScalarWhereWithAggregatesInput | SourceMapOsStringScalarWhereWithAggregatesInput[]
    source_id?: IntWithAggregatesFilter<"SourceMapOsString"> | number
    os_string?: StringWithAggregatesFilter<"SourceMapOsString"> | string
  }

  export type SourcePrequisiteBuildWhereInput = {
    AND?: SourcePrequisiteBuildWhereInput | SourcePrequisiteBuildWhereInput[]
    OR?: SourcePrequisiteBuildWhereInput[]
    NOT?: SourcePrequisiteBuildWhereInput | SourcePrequisiteBuildWhereInput[]
    source_id?: IntFilter<"SourcePrequisiteBuild"> | number
    build?: StringFilter<"SourcePrequisiteBuild"> | string
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }

  export type SourcePrequisiteBuildOrderByWithRelationInput = {
    source_id?: SortOrder
    build?: SortOrder
    SourceEntry?: SourceEntryOrderByWithRelationInput
    _relevance?: SourcePrequisiteBuildOrderByRelevanceInput
  }

  export type SourcePrequisiteBuildWhereUniqueInput = Prisma.AtLeast<{
    source_id_build?: SourcePrequisiteBuildSource_idBuildCompoundUniqueInput
    AND?: SourcePrequisiteBuildWhereInput | SourcePrequisiteBuildWhereInput[]
    OR?: SourcePrequisiteBuildWhereInput[]
    NOT?: SourcePrequisiteBuildWhereInput | SourcePrequisiteBuildWhereInput[]
    source_id?: IntFilter<"SourcePrequisiteBuild"> | number
    build?: StringFilter<"SourcePrequisiteBuild"> | string
    SourceEntry?: XOR<SourceEntryScalarRelationFilter, SourceEntryWhereInput>
  }, "source_id_build">

  export type SourcePrequisiteBuildOrderByWithAggregationInput = {
    source_id?: SortOrder
    build?: SortOrder
    _count?: SourcePrequisiteBuildCountOrderByAggregateInput
    _avg?: SourcePrequisiteBuildAvgOrderByAggregateInput
    _max?: SourcePrequisiteBuildMaxOrderByAggregateInput
    _min?: SourcePrequisiteBuildMinOrderByAggregateInput
    _sum?: SourcePrequisiteBuildSumOrderByAggregateInput
  }

  export type SourcePrequisiteBuildScalarWhereWithAggregatesInput = {
    AND?: SourcePrequisiteBuildScalarWhereWithAggregatesInput | SourcePrequisiteBuildScalarWhereWithAggregatesInput[]
    OR?: SourcePrequisiteBuildScalarWhereWithAggregatesInput[]
    NOT?: SourcePrequisiteBuildScalarWhereWithAggregatesInput | SourcePrequisiteBuildScalarWhereWithAggregatesInput[]
    source_id?: IntWithAggregatesFilter<"SourcePrequisiteBuild"> | number
    build?: StringWithAggregatesFilter<"SourcePrequisiteBuild"> | string
  }

  export type ColorLookupCreateInput = {
    name: string
    DeviceImageColors?: DeviceImageColorsCreateNestedManyWithoutColorLookupInput
  }

  export type ColorLookupUncheckedCreateInput = {
    id?: number
    name: string
    DeviceImageColors?: DeviceImageColorsUncheckedCreateNestedManyWithoutColorLookupInput
  }

  export type ColorLookupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceImageColors?: DeviceImageColorsUpdateManyWithoutColorLookupNestedInput
  }

  export type ColorLookupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceImageColors?: DeviceImageColorsUncheckedUpdateManyWithoutColorLookupNestedInput
  }

  export type ColorLookupCreateManyInput = {
    id?: number
    name: string
  }

  export type ColorLookupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ColorLookupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceEntryCreateInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryCreateManyInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
  }

  export type DeviceEntryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceGroupEntryCreateInput = {
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryUncheckedCreateInput = {
    id?: number
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryCreateManyInput = {
    id?: number
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
  }

  export type DeviceGroupEntryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceGroupEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceGroupMapDeviceCreateInput = {
    DeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput
  }

  export type DeviceGroupMapDeviceUncheckedCreateInput = {
    group_id: number
    device_id: number
  }

  export type DeviceGroupMapDeviceUpdateInput = {
    DeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput
  }

  export type DeviceGroupMapDeviceUncheckedUpdateInput = {
    group_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceCreateManyInput = {
    group_id: number
    device_id: number
  }

  export type DeviceGroupMapDeviceUpdateManyMutationInput = {

  }

  export type DeviceGroupMapDeviceUncheckedUpdateManyInput = {
    group_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupCreateInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedCreateInput = {
    parent_group_id: number
    child_group_id: number
  }

  export type DeviceGroupMapDeviceGroupUpdateInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateInput = {
    parent_group_id?: IntFieldUpdateOperationsInput | number
    child_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupCreateManyInput = {
    parent_group_id: number
    child_group_id: number
  }

  export type DeviceGroupMapDeviceGroupUpdateManyMutationInput = {

  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateManyInput = {
    parent_group_id?: IntFieldUpdateOperationsInput | number
    child_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceImageColorsCreateInput = {
    dark_mode?: boolean | null
    DeviceLookupImage: DeviceLookupImageCreateNestedOneWithoutDeviceImageColorsInput
    ColorLookup: ColorLookupCreateNestedOneWithoutDeviceImageColorsInput
  }

  export type DeviceImageColorsUncheckedCreateInput = {
    device_image_id: number
    color_id: number
    dark_mode?: boolean | null
  }

  export type DeviceImageColorsUpdateInput = {
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    DeviceLookupImage?: DeviceLookupImageUpdateOneRequiredWithoutDeviceImageColorsNestedInput
    ColorLookup?: ColorLookupUpdateOneRequiredWithoutDeviceImageColorsNestedInput
  }

  export type DeviceImageColorsUncheckedUpdateInput = {
    device_image_id?: IntFieldUpdateOperationsInput | number
    color_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceImageColorsCreateManyInput = {
    device_image_id: number
    color_id: number
    dark_mode?: boolean | null
  }

  export type DeviceImageColorsUpdateManyMutationInput = {
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceImageColorsUncheckedUpdateManyInput = {
    device_image_id?: IntFieldUpdateOperationsInput | number
    color_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceLookupArchitectureCreateInput = {
    name: string
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceLookupArchitectureInput
  }

  export type DeviceLookupArchitectureUncheckedCreateInput = {
    id?: number
    name: string
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceLookupArchitectureInput
  }

  export type DeviceLookupArchitectureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceLookupArchitectureNestedInput
  }

  export type DeviceLookupArchitectureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceLookupArchitectureNestedInput
  }

  export type DeviceLookupArchitectureCreateManyInput = {
    id?: number
    name: string
  }

  export type DeviceLookupArchitectureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupArchitectureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupCategoryCreateInput = {
    name: string
    DeviceEntry?: DeviceEntryCreateNestedManyWithoutDeviceLookupCategoryInput
  }

  export type DeviceLookupCategoryUncheckedCreateInput = {
    id?: number
    name: string
    DeviceEntry?: DeviceEntryUncheckedCreateNestedManyWithoutDeviceLookupCategoryInput
  }

  export type DeviceLookupCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUpdateManyWithoutDeviceLookupCategoryNestedInput
  }

  export type DeviceLookupCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUncheckedUpdateManyWithoutDeviceLookupCategoryNestedInput
  }

  export type DeviceLookupCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type DeviceLookupCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupImageCreateInput = {
    name: string
    DeviceEntry?: DeviceEntryCreateNestedManyWithoutDeviceLookupImageInput
    DeviceImageColors?: DeviceImageColorsCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageUncheckedCreateInput = {
    id?: number
    name: string
    DeviceEntry?: DeviceEntryUncheckedCreateNestedManyWithoutDeviceLookupImageInput
    DeviceImageColors?: DeviceImageColorsUncheckedCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUpdateManyWithoutDeviceLookupImageNestedInput
    DeviceImageColors?: DeviceImageColorsUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type DeviceLookupImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUncheckedUpdateManyWithoutDeviceLookupImageNestedInput
    DeviceImageColors?: DeviceImageColorsUncheckedUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type DeviceLookupImageCreateManyInput = {
    id?: number
    name: string
  }

  export type DeviceLookupImageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupSocCreateInput = {
    name: string
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceLookupSocInput
  }

  export type DeviceLookupSocUncheckedCreateInput = {
    id?: number
    name: string
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceLookupSocInput
  }

  export type DeviceLookupSocUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceLookupSocNestedInput
  }

  export type DeviceLookupSocUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceLookupSocNestedInput
  }

  export type DeviceLookupSocCreateManyInput = {
    id?: number
    name: string
  }

  export type DeviceLookupSocUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupSocUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapArchitectureCreateInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapArchitectureInput
    DeviceLookupArchitecture: DeviceLookupArchitectureCreateNestedOneWithoutDeviceMapArchitectureInput
  }

  export type DeviceMapArchitectureUncheckedCreateInput = {
    device_id: number
    architecture_id: number
  }

  export type DeviceMapArchitectureUpdateInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput
    DeviceLookupArchitecture?: DeviceLookupArchitectureUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput
  }

  export type DeviceMapArchitectureUncheckedUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    architecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapArchitectureCreateManyInput = {
    device_id: number
    architecture_id: number
  }

  export type DeviceMapArchitectureUpdateManyMutationInput = {

  }

  export type DeviceMapArchitectureUncheckedUpdateManyInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    architecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapIdentifierCreateInput = {
    identifier: string
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapIdentifierInput
  }

  export type DeviceMapIdentifierUncheckedCreateInput = {
    device_id: number
    identifier: string
  }

  export type DeviceMapIdentifierUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapIdentifierNestedInput
  }

  export type DeviceMapIdentifierUncheckedUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapIdentifierCreateManyInput = {
    device_id: number
    identifier: string
  }

  export type DeviceMapIdentifierUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapIdentifierUncheckedUpdateManyInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelCreateInput = {
    model: string
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapModelInput
  }

  export type DeviceMapModelUncheckedCreateInput = {
    device_id: number
    model: string
  }

  export type DeviceMapModelUpdateInput = {
    model?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapModelNestedInput
  }

  export type DeviceMapModelUncheckedUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelCreateManyInput = {
    device_id: number
    model: string
  }

  export type DeviceMapModelUpdateManyMutationInput = {
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelUncheckedUpdateManyInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapReleaseCreateInput = {
    datetime?: Date | string | null
    depth?: number | null
    DeviceEntry?: DeviceEntryCreateNestedOneWithoutDeviceMapReleaseInput
  }

  export type DeviceMapReleaseUncheckedCreateInput = {
    id?: number
    device_id?: number | null
    datetime?: Date | string | null
    depth?: number | null
  }

  export type DeviceMapReleaseUpdateInput = {
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    DeviceEntry?: DeviceEntryUpdateOneWithoutDeviceMapReleaseNestedInput
  }

  export type DeviceMapReleaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapReleaseCreateManyInput = {
    id?: number
    device_id?: number | null
    datetime?: Date | string | null
    depth?: number | null
  }

  export type DeviceMapReleaseUpdateManyMutationInput = {
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapReleaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapSocCreateInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapSocInput
    DeviceLookupSoc: DeviceLookupSocCreateNestedOneWithoutDeviceMapSocInput
  }

  export type DeviceMapSocUncheckedCreateInput = {
    device_id: number
    soc_id: number
  }

  export type DeviceMapSocUpdateInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapSocNestedInput
    DeviceLookupSoc?: DeviceLookupSocUpdateOneRequiredWithoutDeviceMapSocNestedInput
  }

  export type DeviceMapSocUncheckedUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    soc_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapSocCreateManyInput = {
    device_id: number
    soc_id: number
  }

  export type DeviceMapSocUpdateManyMutationInput = {

  }

  export type DeviceMapSocUncheckedUpdateManyInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    soc_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsCreateInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutMapDeviceOsInput
    OsEntry: OsEntryCreateNestedOneWithoutMapDeviceOsInput
  }

  export type MapDeviceOsUncheckedCreateInput = {
    device_id: number
    os_id: number
  }

  export type MapDeviceOsUpdateInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput
    OsEntry?: OsEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput
  }

  export type MapDeviceOsUncheckedUpdateInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsCreateManyInput = {
    device_id: number
    os_id: number
  }

  export type MapDeviceOsUpdateManyMutationInput = {

  }

  export type MapDeviceOsUncheckedUpdateManyInput = {
    device_id?: IntFieldUpdateOperationsInput | number
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryCreateInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateManyInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
  }

  export type OsEntryUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OsEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OsEntryBuildTrainCreateInput = {
    build_train: string
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryBuildTrainInput
  }

  export type OsEntryBuildTrainUncheckedCreateInput = {
    os_id: number
    build_train: string
  }

  export type OsEntryBuildTrainUpdateInput = {
    build_train?: StringFieldUpdateOperationsInput | string
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryBuildTrainNestedInput
  }

  export type OsEntryBuildTrainUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryBuildTrainCreateManyInput = {
    os_id: number
    build_train: string
  }

  export type OsEntryBuildTrainUpdateManyMutationInput = {
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryBuildTrainUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryIpdCreateInput = {
    ipd_type: string
    url?: string | null
    active?: boolean | null
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryIpdInput
  }

  export type OsEntryIpdUncheckedCreateInput = {
    os_id: number
    ipd_type: string
    url?: string | null
    active?: boolean | null
  }

  export type OsEntryIpdUpdateInput = {
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryIpdNestedInput
  }

  export type OsEntryIpdUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryIpdCreateManyInput = {
    os_id: number
    ipd_type: string
    url?: string | null
    active?: boolean | null
  }

  export type OsEntryIpdUpdateManyMutationInput = {
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryIpdUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryOsStringMapCreateInput = {
    os_string: string
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryOsStringMapInput
  }

  export type OsEntryOsStringMapUncheckedCreateInput = {
    os_id: number
    os_string: string
  }

  export type OsEntryOsStringMapUpdateInput = {
    os_string?: StringFieldUpdateOperationsInput | string
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryOsStringMapNestedInput
  }

  export type OsEntryOsStringMapUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryOsStringMapCreateManyInput = {
    os_id: number
    os_string: string
  }

  export type OsEntryOsStringMapUpdateManyMutationInput = {
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryOsStringMapUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryPreinstalledCreateInput = {
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryPreinstalledInput
    DeviceEntry: DeviceEntryCreateNestedOneWithoutOsEntryPreinstalledInput
  }

  export type OsEntryPreinstalledUncheckedCreateInput = {
    os_id: number
    device_id: number
  }

  export type OsEntryPreinstalledUpdateInput = {
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput
  }

  export type OsEntryPreinstalledUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryPreinstalledCreateManyInput = {
    os_id: number
    device_id: number
  }

  export type OsEntryPreinstalledUpdateManyMutationInput = {

  }

  export type OsEntryPreinstalledUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryReleaseNoteCreateInput = {
    url: string
    active?: boolean | null
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryReleaseNoteInput
  }

  export type OsEntryReleaseNoteUncheckedCreateInput = {
    os_id: number
    url: string
    active?: boolean | null
  }

  export type OsEntryReleaseNoteUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryReleaseNoteNestedInput
  }

  export type OsEntryReleaseNoteUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryReleaseNoteCreateManyInput = {
    os_id: number
    url: string
    active?: boolean | null
  }

  export type OsEntryReleaseNoteUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryReleaseNoteUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySafariVersionCreateInput = {
    version: string
    OsEntry: OsEntryCreateNestedOneWithoutOsEntrySafariVersionInput
  }

  export type OsEntrySafariVersionUncheckedCreateInput = {
    os_id: number
    version: string
  }

  export type OsEntrySafariVersionUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntrySafariVersionNestedInput
  }

  export type OsEntrySafariVersionUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySafariVersionCreateManyInput = {
    os_id: number
    version: string
  }

  export type OsEntrySafariVersionUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySafariVersionUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySecurityNoteCreateInput = {
    url: string
    active?: boolean | null
    OsEntry: OsEntryCreateNestedOneWithoutOsEntrySecurityNoteInput
  }

  export type OsEntrySecurityNoteUncheckedCreateInput = {
    os_id: number
    url: string
    active?: boolean | null
  }

  export type OsEntrySecurityNoteUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntrySecurityNoteNestedInput
  }

  export type OsEntrySecurityNoteUncheckedUpdateInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySecurityNoteCreateManyInput = {
    os_id: number
    url: string
    active?: boolean | null
  }

  export type OsEntrySecurityNoteUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySecurityNoteUncheckedUpdateManyInput = {
    os_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsLookupNameCreateInput = {
    name: string
    priority?: number | null
    OsEntry?: OsEntryCreateNestedManyWithoutOsLookupNameInput
  }

  export type OsLookupNameUncheckedCreateInput = {
    id?: number
    name: string
    priority?: number | null
    OsEntry?: OsEntryUncheckedCreateNestedManyWithoutOsLookupNameInput
  }

  export type OsLookupNameUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    OsEntry?: OsEntryUpdateManyWithoutOsLookupNameNestedInput
  }

  export type OsLookupNameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    OsEntry?: OsEntryUncheckedUpdateManyWithoutOsLookupNameNestedInput
  }

  export type OsLookupNameCreateManyInput = {
    id?: number
    name: string
    priority?: number | null
  }

  export type OsLookupNameUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OsLookupNameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SourceEntryCreateInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    OsEntry?: OsEntryCreateNestedOneWithoutSourceEntryInput
    SourceHash?: SourceHashCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUpdateInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntry?: OsEntryUpdateOneWithoutSourceEntryNestedInput
    SourceHash?: SourceHashUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryCreateManyInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
  }

  export type SourceEntryUpdateManyMutationInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashCreateInput = {
    hash_type: string
    hash_value?: string | null
    SourceEntry: SourceEntryCreateNestedOneWithoutSourceHashInput
  }

  export type SourceHashUncheckedCreateInput = {
    source_id: number
    hash_type: string
    hash_value?: string | null
  }

  export type SourceHashUpdateInput = {
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
    SourceEntry?: SourceEntryUpdateOneRequiredWithoutSourceHashNestedInput
  }

  export type SourceHashUncheckedUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashCreateManyInput = {
    source_id: number
    hash_type: string
    hash_value?: string | null
  }

  export type SourceHashUpdateManyMutationInput = {
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashUncheckedUpdateManyInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceLinkCreateInput = {
    url: string
    active?: boolean | null
    SourceEntry: SourceEntryCreateNestedOneWithoutSourceLinkInput
  }

  export type SourceLinkUncheckedCreateInput = {
    source_id: number
    url: string
    active?: boolean | null
  }

  export type SourceLinkUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    SourceEntry?: SourceEntryUpdateOneRequiredWithoutSourceLinkNestedInput
  }

  export type SourceLinkUncheckedUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceLinkCreateManyInput = {
    source_id: number
    url: string
    active?: boolean | null
  }

  export type SourceLinkUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceLinkUncheckedUpdateManyInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceMapDeviceCreateInput = {
    SourceEntry: SourceEntryCreateNestedOneWithoutSourceMapDeviceInput
    DeviceEntry: DeviceEntryCreateNestedOneWithoutSourceMapDeviceInput
  }

  export type SourceMapDeviceUncheckedCreateInput = {
    source_id: number
    device_id: number
  }

  export type SourceMapDeviceUpdateInput = {
    SourceEntry?: SourceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput
  }

  export type SourceMapDeviceUncheckedUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourceMapDeviceCreateManyInput = {
    source_id: number
    device_id: number
  }

  export type SourceMapDeviceUpdateManyMutationInput = {

  }

  export type SourceMapDeviceUncheckedUpdateManyInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourceMapOsStringCreateInput = {
    source_id: number
    os_string: string
  }

  export type SourceMapOsStringUncheckedCreateInput = {
    source_id: number
    os_string: string
  }

  export type SourceMapOsStringUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type SourceMapOsStringUncheckedUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type SourceMapOsStringCreateManyInput = {
    source_id: number
    os_string: string
  }

  export type SourceMapOsStringUpdateManyMutationInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type SourceMapOsStringUncheckedUpdateManyInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type SourcePrequisiteBuildCreateInput = {
    build: string
    SourceEntry: SourceEntryCreateNestedOneWithoutSourcePrequisiteBuildInput
  }

  export type SourcePrequisiteBuildUncheckedCreateInput = {
    source_id: number
    build: string
  }

  export type SourcePrequisiteBuildUpdateInput = {
    build?: StringFieldUpdateOperationsInput | string
    SourceEntry?: SourceEntryUpdateOneRequiredWithoutSourcePrequisiteBuildNestedInput
  }

  export type SourcePrequisiteBuildUncheckedUpdateInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    build?: StringFieldUpdateOperationsInput | string
  }

  export type SourcePrequisiteBuildCreateManyInput = {
    source_id: number
    build: string
  }

  export type SourcePrequisiteBuildUpdateManyMutationInput = {
    build?: StringFieldUpdateOperationsInput | string
  }

  export type SourcePrequisiteBuildUncheckedUpdateManyInput = {
    source_id?: IntFieldUpdateOperationsInput | number
    build?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DeviceImageColorsListRelationFilter = {
    every?: DeviceImageColorsWhereInput
    some?: DeviceImageColorsWhereInput
    none?: DeviceImageColorsWhereInput
  }

  export type DeviceImageColorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColorLookupOrderByRelevanceInput = {
    fields: ColorLookupOrderByRelevanceFieldEnum | ColorLookupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ColorLookupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorLookupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ColorLookupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorLookupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ColorLookupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DeviceLookupCategoryScalarRelationFilter = {
    is?: DeviceLookupCategoryWhereInput
    isNot?: DeviceLookupCategoryWhereInput
  }

  export type DeviceLookupImageNullableScalarRelationFilter = {
    is?: DeviceLookupImageWhereInput | null
    isNot?: DeviceLookupImageWhereInput | null
  }

  export type DeviceGroupMapDeviceListRelationFilter = {
    every?: DeviceGroupMapDeviceWhereInput
    some?: DeviceGroupMapDeviceWhereInput
    none?: DeviceGroupMapDeviceWhereInput
  }

  export type DeviceMapArchitectureListRelationFilter = {
    every?: DeviceMapArchitectureWhereInput
    some?: DeviceMapArchitectureWhereInput
    none?: DeviceMapArchitectureWhereInput
  }

  export type DeviceMapIdentifierListRelationFilter = {
    every?: DeviceMapIdentifierWhereInput
    some?: DeviceMapIdentifierWhereInput
    none?: DeviceMapIdentifierWhereInput
  }

  export type DeviceMapModelListRelationFilter = {
    every?: DeviceMapModelWhereInput
    some?: DeviceMapModelWhereInput
    none?: DeviceMapModelWhereInput
  }

  export type DeviceMapReleaseListRelationFilter = {
    every?: DeviceMapReleaseWhereInput
    some?: DeviceMapReleaseWhereInput
    none?: DeviceMapReleaseWhereInput
  }

  export type DeviceMapSocListRelationFilter = {
    every?: DeviceMapSocWhereInput
    some?: DeviceMapSocWhereInput
    none?: DeviceMapSocWhereInput
  }

  export type MapDeviceOsListRelationFilter = {
    every?: MapDeviceOsWhereInput
    some?: MapDeviceOsWhereInput
    none?: MapDeviceOsWhereInput
  }

  export type OsEntryPreinstalledListRelationFilter = {
    every?: OsEntryPreinstalledWhereInput
    some?: OsEntryPreinstalledWhereInput
    none?: OsEntryPreinstalledWhereInput
  }

  export type SourceMapDeviceListRelationFilter = {
    every?: SourceMapDeviceWhereInput
    some?: SourceMapDeviceWhereInput
    none?: SourceMapDeviceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DeviceGroupMapDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceMapArchitectureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceMapIdentifierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceMapModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceMapReleaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceMapSocOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapDeviceOsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntryPreinstalledOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceMapDeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceEntryOrderByRelevanceInput = {
    fields: DeviceEntryOrderByRelevanceFieldEnum | DeviceEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceEntryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
  }

  export type DeviceEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceEntryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceEntrySumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DeviceGroupMapDeviceGroupListRelationFilter = {
    every?: DeviceGroupMapDeviceGroupWhereInput
    some?: DeviceGroupMapDeviceGroupWhereInput
    none?: DeviceGroupMapDeviceGroupWhereInput
  }

  export type DeviceGroupMapDeviceGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceGroupEntryOrderByRelevanceInput = {
    fields: DeviceGroupEntryOrderByRelevanceFieldEnum | DeviceGroupEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceGroupEntryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceGroupEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
  }

  export type DeviceGroupEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceGroupEntryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
    is_internal?: SortOrder
    legacy_unique_key?: SortOrder
  }

  export type DeviceGroupEntrySumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    image_id?: SortOrder
  }

  export type DeviceGroupEntryScalarRelationFilter = {
    is?: DeviceGroupEntryWhereInput
    isNot?: DeviceGroupEntryWhereInput
  }

  export type DeviceEntryScalarRelationFilter = {
    is?: DeviceEntryWhereInput
    isNot?: DeviceEntryWhereInput
  }

  export type DeviceGroupMapDeviceGroup_idDevice_idCompoundUniqueInput = {
    group_id: number
    device_id: number
  }

  export type DeviceGroupMapDeviceCountOrderByAggregateInput = {
    group_id?: SortOrder
    device_id?: SortOrder
  }

  export type DeviceGroupMapDeviceAvgOrderByAggregateInput = {
    group_id?: SortOrder
    device_id?: SortOrder
  }

  export type DeviceGroupMapDeviceMaxOrderByAggregateInput = {
    group_id?: SortOrder
    device_id?: SortOrder
  }

  export type DeviceGroupMapDeviceMinOrderByAggregateInput = {
    group_id?: SortOrder
    device_id?: SortOrder
  }

  export type DeviceGroupMapDeviceSumOrderByAggregateInput = {
    group_id?: SortOrder
    device_id?: SortOrder
  }

  export type DeviceGroupMapDeviceGroupParent_group_idChild_group_idCompoundUniqueInput = {
    parent_group_id: number
    child_group_id: number
  }

  export type DeviceGroupMapDeviceGroupCountOrderByAggregateInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
  }

  export type DeviceGroupMapDeviceGroupAvgOrderByAggregateInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
  }

  export type DeviceGroupMapDeviceGroupMaxOrderByAggregateInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
  }

  export type DeviceGroupMapDeviceGroupMinOrderByAggregateInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
  }

  export type DeviceGroupMapDeviceGroupSumOrderByAggregateInput = {
    parent_group_id?: SortOrder
    child_group_id?: SortOrder
  }

  export type DeviceLookupImageScalarRelationFilter = {
    is?: DeviceLookupImageWhereInput
    isNot?: DeviceLookupImageWhereInput
  }

  export type ColorLookupScalarRelationFilter = {
    is?: ColorLookupWhereInput
    isNot?: ColorLookupWhereInput
  }

  export type DeviceImageColorsDevice_image_idColor_idCompoundUniqueInput = {
    device_image_id: number
    color_id: number
  }

  export type DeviceImageColorsCountOrderByAggregateInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
    dark_mode?: SortOrder
  }

  export type DeviceImageColorsAvgOrderByAggregateInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
  }

  export type DeviceImageColorsMaxOrderByAggregateInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
    dark_mode?: SortOrder
  }

  export type DeviceImageColorsMinOrderByAggregateInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
    dark_mode?: SortOrder
  }

  export type DeviceImageColorsSumOrderByAggregateInput = {
    device_image_id?: SortOrder
    color_id?: SortOrder
  }

  export type DeviceLookupArchitectureOrderByRelevanceInput = {
    fields: DeviceLookupArchitectureOrderByRelevanceFieldEnum | DeviceLookupArchitectureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceLookupArchitectureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupArchitectureAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupArchitectureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupArchitectureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupArchitectureSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceEntryListRelationFilter = {
    every?: DeviceEntryWhereInput
    some?: DeviceEntryWhereInput
    none?: DeviceEntryWhereInput
  }

  export type DeviceEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceLookupCategoryOrderByRelevanceInput = {
    fields: DeviceLookupCategoryOrderByRelevanceFieldEnum | DeviceLookupCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceLookupCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupImageOrderByRelevanceInput = {
    fields: DeviceLookupImageOrderByRelevanceFieldEnum | DeviceLookupImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceLookupImageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupImageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupImageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupImageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupImageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupSocOrderByRelevanceInput = {
    fields: DeviceLookupSocOrderByRelevanceFieldEnum | DeviceLookupSocOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceLookupSocCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupSocAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupSocMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupSocMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DeviceLookupSocSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceLookupArchitectureScalarRelationFilter = {
    is?: DeviceLookupArchitectureWhereInput
    isNot?: DeviceLookupArchitectureWhereInput
  }

  export type DeviceMapArchitectureDevice_idArchitecture_idCompoundUniqueInput = {
    device_id: number
    architecture_id: number
  }

  export type DeviceMapArchitectureCountOrderByAggregateInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
  }

  export type DeviceMapArchitectureAvgOrderByAggregateInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
  }

  export type DeviceMapArchitectureMaxOrderByAggregateInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
  }

  export type DeviceMapArchitectureMinOrderByAggregateInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
  }

  export type DeviceMapArchitectureSumOrderByAggregateInput = {
    device_id?: SortOrder
    architecture_id?: SortOrder
  }

  export type DeviceMapIdentifierOrderByRelevanceInput = {
    fields: DeviceMapIdentifierOrderByRelevanceFieldEnum | DeviceMapIdentifierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceMapIdentifierDevice_idIdentifierCompoundUniqueInput = {
    device_id: number
    identifier: string
  }

  export type DeviceMapIdentifierCountOrderByAggregateInput = {
    device_id?: SortOrder
    identifier?: SortOrder
  }

  export type DeviceMapIdentifierAvgOrderByAggregateInput = {
    device_id?: SortOrder
  }

  export type DeviceMapIdentifierMaxOrderByAggregateInput = {
    device_id?: SortOrder
    identifier?: SortOrder
  }

  export type DeviceMapIdentifierMinOrderByAggregateInput = {
    device_id?: SortOrder
    identifier?: SortOrder
  }

  export type DeviceMapIdentifierSumOrderByAggregateInput = {
    device_id?: SortOrder
  }

  export type DeviceMapModelOrderByRelevanceInput = {
    fields: DeviceMapModelOrderByRelevanceFieldEnum | DeviceMapModelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceMapModelDevice_idModelCompoundUniqueInput = {
    device_id: number
    model: string
  }

  export type DeviceMapModelCountOrderByAggregateInput = {
    device_id?: SortOrder
    model?: SortOrder
  }

  export type DeviceMapModelAvgOrderByAggregateInput = {
    device_id?: SortOrder
  }

  export type DeviceMapModelMaxOrderByAggregateInput = {
    device_id?: SortOrder
    model?: SortOrder
  }

  export type DeviceMapModelMinOrderByAggregateInput = {
    device_id?: SortOrder
    model?: SortOrder
  }

  export type DeviceMapModelSumOrderByAggregateInput = {
    device_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DeviceEntryNullableScalarRelationFilter = {
    is?: DeviceEntryWhereInput | null
    isNot?: DeviceEntryWhereInput | null
  }

  export type DeviceMapReleaseCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    datetime?: SortOrder
    depth?: SortOrder
  }

  export type DeviceMapReleaseAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    depth?: SortOrder
  }

  export type DeviceMapReleaseMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    datetime?: SortOrder
    depth?: SortOrder
  }

  export type DeviceMapReleaseMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    datetime?: SortOrder
    depth?: SortOrder
  }

  export type DeviceMapReleaseSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    depth?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DeviceLookupSocScalarRelationFilter = {
    is?: DeviceLookupSocWhereInput
    isNot?: DeviceLookupSocWhereInput
  }

  export type DeviceMapSocDevice_idSoc_idCompoundUniqueInput = {
    device_id: number
    soc_id: number
  }

  export type DeviceMapSocCountOrderByAggregateInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
  }

  export type DeviceMapSocAvgOrderByAggregateInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
  }

  export type DeviceMapSocMaxOrderByAggregateInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
  }

  export type DeviceMapSocMinOrderByAggregateInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
  }

  export type DeviceMapSocSumOrderByAggregateInput = {
    device_id?: SortOrder
    soc_id?: SortOrder
  }

  export type OsEntryScalarRelationFilter = {
    is?: OsEntryWhereInput
    isNot?: OsEntryWhereInput
  }

  export type MapDeviceOsDevice_idOs_idCompoundUniqueInput = {
    device_id: number
    os_id: number
  }

  export type MapDeviceOsCountOrderByAggregateInput = {
    device_id?: SortOrder
    os_id?: SortOrder
  }

  export type MapDeviceOsAvgOrderByAggregateInput = {
    device_id?: SortOrder
    os_id?: SortOrder
  }

  export type MapDeviceOsMaxOrderByAggregateInput = {
    device_id?: SortOrder
    os_id?: SortOrder
  }

  export type MapDeviceOsMinOrderByAggregateInput = {
    device_id?: SortOrder
    os_id?: SortOrder
  }

  export type MapDeviceOsSumOrderByAggregateInput = {
    device_id?: SortOrder
    os_id?: SortOrder
  }

  export type OsLookupNameScalarRelationFilter = {
    is?: OsLookupNameWhereInput
    isNot?: OsLookupNameWhereInput
  }

  export type OsEntryBuildTrainListRelationFilter = {
    every?: OsEntryBuildTrainWhereInput
    some?: OsEntryBuildTrainWhereInput
    none?: OsEntryBuildTrainWhereInput
  }

  export type OsEntryIpdListRelationFilter = {
    every?: OsEntryIpdWhereInput
    some?: OsEntryIpdWhereInput
    none?: OsEntryIpdWhereInput
  }

  export type OsEntryOsStringMapListRelationFilter = {
    every?: OsEntryOsStringMapWhereInput
    some?: OsEntryOsStringMapWhereInput
    none?: OsEntryOsStringMapWhereInput
  }

  export type OsEntryReleaseNoteListRelationFilter = {
    every?: OsEntryReleaseNoteWhereInput
    some?: OsEntryReleaseNoteWhereInput
    none?: OsEntryReleaseNoteWhereInput
  }

  export type OsEntrySafariVersionListRelationFilter = {
    every?: OsEntrySafariVersionWhereInput
    some?: OsEntrySafariVersionWhereInput
    none?: OsEntrySafariVersionWhereInput
  }

  export type OsEntrySecurityNoteListRelationFilter = {
    every?: OsEntrySecurityNoteWhereInput
    some?: OsEntrySecurityNoteWhereInput
    none?: OsEntrySecurityNoteWhereInput
  }

  export type SourceEntryListRelationFilter = {
    every?: SourceEntryWhereInput
    some?: SourceEntryWhereInput
    none?: SourceEntryWhereInput
  }

  export type OsEntryBuildTrainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntryIpdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntryOsStringMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntryReleaseNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntrySafariVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntrySecurityNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsEntryOrderByRelevanceInput = {
    fields: OsEntryOrderByRelevanceFieldEnum | OsEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntryCountOrderByAggregateInput = {
    id?: SortOrder
    name_id?: SortOrder
    version?: SortOrder
    build?: SortOrder
    release_datetime?: SortOrder
    release_datetime_depth?: SortOrder
    is_release?: SortOrder
    is_beta?: SortOrder
    is_rc?: SortOrder
    is_internal?: SortOrder
    is_rsr?: SortOrder
    is_sdk?: SortOrder
    is_simulator?: SortOrder
    image_id?: SortOrder
    embedded_os_build?: SortOrder
    bridge_os_build?: SortOrder
    notes?: SortOrder
    legacy_unique_key?: SortOrder
    search?: SortOrder
  }

  export type OsEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    name_id?: SortOrder
    release_datetime_depth?: SortOrder
  }

  export type OsEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    name_id?: SortOrder
    version?: SortOrder
    build?: SortOrder
    release_datetime?: SortOrder
    release_datetime_depth?: SortOrder
    is_release?: SortOrder
    is_beta?: SortOrder
    is_rc?: SortOrder
    is_internal?: SortOrder
    is_rsr?: SortOrder
    is_sdk?: SortOrder
    is_simulator?: SortOrder
    image_id?: SortOrder
    embedded_os_build?: SortOrder
    bridge_os_build?: SortOrder
    notes?: SortOrder
    legacy_unique_key?: SortOrder
    search?: SortOrder
  }

  export type OsEntryMinOrderByAggregateInput = {
    id?: SortOrder
    name_id?: SortOrder
    version?: SortOrder
    build?: SortOrder
    release_datetime?: SortOrder
    release_datetime_depth?: SortOrder
    is_release?: SortOrder
    is_beta?: SortOrder
    is_rc?: SortOrder
    is_internal?: SortOrder
    is_rsr?: SortOrder
    is_sdk?: SortOrder
    is_simulator?: SortOrder
    image_id?: SortOrder
    embedded_os_build?: SortOrder
    bridge_os_build?: SortOrder
    notes?: SortOrder
    legacy_unique_key?: SortOrder
    search?: SortOrder
  }

  export type OsEntrySumOrderByAggregateInput = {
    id?: SortOrder
    name_id?: SortOrder
    release_datetime_depth?: SortOrder
  }

  export type OsEntryBuildTrainOrderByRelevanceInput = {
    fields: OsEntryBuildTrainOrderByRelevanceFieldEnum | OsEntryBuildTrainOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntryBuildTrainOs_idBuild_trainCompoundUniqueInput = {
    os_id: number
    build_train: string
  }

  export type OsEntryBuildTrainCountOrderByAggregateInput = {
    os_id?: SortOrder
    build_train?: SortOrder
  }

  export type OsEntryBuildTrainAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryBuildTrainMaxOrderByAggregateInput = {
    os_id?: SortOrder
    build_train?: SortOrder
  }

  export type OsEntryBuildTrainMinOrderByAggregateInput = {
    os_id?: SortOrder
    build_train?: SortOrder
  }

  export type OsEntryBuildTrainSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryIpdOrderByRelevanceInput = {
    fields: OsEntryIpdOrderByRelevanceFieldEnum | OsEntryIpdOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntryIpdOs_idIpd_typeCompoundUniqueInput = {
    os_id: number
    ipd_type: string
  }

  export type OsEntryIpdCountOrderByAggregateInput = {
    os_id?: SortOrder
    ipd_type?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryIpdAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryIpdMaxOrderByAggregateInput = {
    os_id?: SortOrder
    ipd_type?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryIpdMinOrderByAggregateInput = {
    os_id?: SortOrder
    ipd_type?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryIpdSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryOsStringMapOrderByRelevanceInput = {
    fields: OsEntryOsStringMapOrderByRelevanceFieldEnum | OsEntryOsStringMapOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntryOsStringMapOs_idOs_stringCompoundUniqueInput = {
    os_id: number
    os_string: string
  }

  export type OsEntryOsStringMapCountOrderByAggregateInput = {
    os_id?: SortOrder
    os_string?: SortOrder
  }

  export type OsEntryOsStringMapAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryOsStringMapMaxOrderByAggregateInput = {
    os_id?: SortOrder
    os_string?: SortOrder
  }

  export type OsEntryOsStringMapMinOrderByAggregateInput = {
    os_id?: SortOrder
    os_string?: SortOrder
  }

  export type OsEntryOsStringMapSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryPreinstalledOs_idDevice_idCompoundUniqueInput = {
    os_id: number
    device_id: number
  }

  export type OsEntryPreinstalledCountOrderByAggregateInput = {
    os_id?: SortOrder
    device_id?: SortOrder
  }

  export type OsEntryPreinstalledAvgOrderByAggregateInput = {
    os_id?: SortOrder
    device_id?: SortOrder
  }

  export type OsEntryPreinstalledMaxOrderByAggregateInput = {
    os_id?: SortOrder
    device_id?: SortOrder
  }

  export type OsEntryPreinstalledMinOrderByAggregateInput = {
    os_id?: SortOrder
    device_id?: SortOrder
  }

  export type OsEntryPreinstalledSumOrderByAggregateInput = {
    os_id?: SortOrder
    device_id?: SortOrder
  }

  export type OsEntryReleaseNoteOrderByRelevanceInput = {
    fields: OsEntryReleaseNoteOrderByRelevanceFieldEnum | OsEntryReleaseNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntryReleaseNoteOs_idUrlCompoundUniqueInput = {
    os_id: number
    url: string
  }

  export type OsEntryReleaseNoteCountOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryReleaseNoteAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryReleaseNoteMaxOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryReleaseNoteMinOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntryReleaseNoteSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntrySafariVersionOrderByRelevanceInput = {
    fields: OsEntrySafariVersionOrderByRelevanceFieldEnum | OsEntrySafariVersionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntrySafariVersionOs_idVersionCompoundUniqueInput = {
    os_id: number
    version: string
  }

  export type OsEntrySafariVersionCountOrderByAggregateInput = {
    os_id?: SortOrder
    version?: SortOrder
  }

  export type OsEntrySafariVersionAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntrySafariVersionMaxOrderByAggregateInput = {
    os_id?: SortOrder
    version?: SortOrder
  }

  export type OsEntrySafariVersionMinOrderByAggregateInput = {
    os_id?: SortOrder
    version?: SortOrder
  }

  export type OsEntrySafariVersionSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntrySecurityNoteOrderByRelevanceInput = {
    fields: OsEntrySecurityNoteOrderByRelevanceFieldEnum | OsEntrySecurityNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsEntrySecurityNoteOs_idUrlCompoundUniqueInput = {
    os_id: number
    url: string
  }

  export type OsEntrySecurityNoteCountOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntrySecurityNoteAvgOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntrySecurityNoteMaxOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntrySecurityNoteMinOrderByAggregateInput = {
    os_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type OsEntrySecurityNoteSumOrderByAggregateInput = {
    os_id?: SortOrder
  }

  export type OsEntryListRelationFilter = {
    every?: OsEntryWhereInput
    some?: OsEntryWhereInput
    none?: OsEntryWhereInput
  }

  export type OsEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OsLookupNameOrderByRelevanceInput = {
    fields: OsLookupNameOrderByRelevanceFieldEnum | OsLookupNameOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OsLookupNameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    priority?: SortOrder
  }

  export type OsLookupNameAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type OsLookupNameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    priority?: SortOrder
  }

  export type OsLookupNameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    priority?: SortOrder
  }

  export type OsLookupNameSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type OsEntryNullableScalarRelationFilter = {
    is?: OsEntryWhereInput | null
    isNot?: OsEntryWhereInput | null
  }

  export type SourceHashListRelationFilter = {
    every?: SourceHashWhereInput
    some?: SourceHashWhereInput
    none?: SourceHashWhereInput
  }

  export type SourceLinkListRelationFilter = {
    every?: SourceLinkWhereInput
    some?: SourceLinkWhereInput
    none?: SourceLinkWhereInput
  }

  export type SourcePrequisiteBuildListRelationFilter = {
    every?: SourcePrequisiteBuildWhereInput
    some?: SourcePrequisiteBuildWhereInput
    none?: SourcePrequisiteBuildWhereInput
  }

  export type SourceHashOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourcePrequisiteBuildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceEntryOrderByRelevanceInput = {
    fields: SourceEntryOrderByRelevanceFieldEnum | SourceEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourceEntryCountOrderByAggregateInput = {
    id?: SortOrder
    os_id?: SortOrder
    source_type?: SortOrder
    skip_update_links?: SortOrder
    size?: SortOrder
    windows_update_id?: SortOrder
    windows_revision_id?: SortOrder
  }

  export type SourceEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    os_id?: SortOrder
    size?: SortOrder
  }

  export type SourceEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    os_id?: SortOrder
    source_type?: SortOrder
    skip_update_links?: SortOrder
    size?: SortOrder
    windows_update_id?: SortOrder
    windows_revision_id?: SortOrder
  }

  export type SourceEntryMinOrderByAggregateInput = {
    id?: SortOrder
    os_id?: SortOrder
    source_type?: SortOrder
    skip_update_links?: SortOrder
    size?: SortOrder
    windows_update_id?: SortOrder
    windows_revision_id?: SortOrder
  }

  export type SourceEntrySumOrderByAggregateInput = {
    id?: SortOrder
    os_id?: SortOrder
    size?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type SourceEntryScalarRelationFilter = {
    is?: SourceEntryWhereInput
    isNot?: SourceEntryWhereInput
  }

  export type SourceHashOrderByRelevanceInput = {
    fields: SourceHashOrderByRelevanceFieldEnum | SourceHashOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourceHashSource_idHash_typeCompoundUniqueInput = {
    source_id: number
    hash_type: string
  }

  export type SourceHashCountOrderByAggregateInput = {
    source_id?: SortOrder
    hash_type?: SortOrder
    hash_value?: SortOrder
  }

  export type SourceHashAvgOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourceHashMaxOrderByAggregateInput = {
    source_id?: SortOrder
    hash_type?: SortOrder
    hash_value?: SortOrder
  }

  export type SourceHashMinOrderByAggregateInput = {
    source_id?: SortOrder
    hash_type?: SortOrder
    hash_value?: SortOrder
  }

  export type SourceHashSumOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourceLinkOrderByRelevanceInput = {
    fields: SourceLinkOrderByRelevanceFieldEnum | SourceLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourceLinkSource_idUrlCompoundUniqueInput = {
    source_id: number
    url: string
  }

  export type SourceLinkCountOrderByAggregateInput = {
    source_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type SourceLinkAvgOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourceLinkMaxOrderByAggregateInput = {
    source_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type SourceLinkMinOrderByAggregateInput = {
    source_id?: SortOrder
    url?: SortOrder
    active?: SortOrder
  }

  export type SourceLinkSumOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourceMapDeviceSource_idDevice_idCompoundUniqueInput = {
    source_id: number
    device_id: number
  }

  export type SourceMapDeviceCountOrderByAggregateInput = {
    source_id?: SortOrder
    device_id?: SortOrder
  }

  export type SourceMapDeviceAvgOrderByAggregateInput = {
    source_id?: SortOrder
    device_id?: SortOrder
  }

  export type SourceMapDeviceMaxOrderByAggregateInput = {
    source_id?: SortOrder
    device_id?: SortOrder
  }

  export type SourceMapDeviceMinOrderByAggregateInput = {
    source_id?: SortOrder
    device_id?: SortOrder
  }

  export type SourceMapDeviceSumOrderByAggregateInput = {
    source_id?: SortOrder
    device_id?: SortOrder
  }

  export type SourceMapOsStringOrderByRelevanceInput = {
    fields: SourceMapOsStringOrderByRelevanceFieldEnum | SourceMapOsStringOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourceMapOsStringSource_idOs_stringCompoundUniqueInput = {
    source_id: number
    os_string: string
  }

  export type SourceMapOsStringCountOrderByAggregateInput = {
    source_id?: SortOrder
    os_string?: SortOrder
  }

  export type SourceMapOsStringAvgOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourceMapOsStringMaxOrderByAggregateInput = {
    source_id?: SortOrder
    os_string?: SortOrder
  }

  export type SourceMapOsStringMinOrderByAggregateInput = {
    source_id?: SortOrder
    os_string?: SortOrder
  }

  export type SourceMapOsStringSumOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourcePrequisiteBuildOrderByRelevanceInput = {
    fields: SourcePrequisiteBuildOrderByRelevanceFieldEnum | SourcePrequisiteBuildOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SourcePrequisiteBuildSource_idBuildCompoundUniqueInput = {
    source_id: number
    build: string
  }

  export type SourcePrequisiteBuildCountOrderByAggregateInput = {
    source_id?: SortOrder
    build?: SortOrder
  }

  export type SourcePrequisiteBuildAvgOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type SourcePrequisiteBuildMaxOrderByAggregateInput = {
    source_id?: SortOrder
    build?: SortOrder
  }

  export type SourcePrequisiteBuildMinOrderByAggregateInput = {
    source_id?: SortOrder
    build?: SortOrder
  }

  export type SourcePrequisiteBuildSumOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type DeviceImageColorsCreateNestedManyWithoutColorLookupInput = {
    create?: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput> | DeviceImageColorsCreateWithoutColorLookupInput[] | DeviceImageColorsUncheckedCreateWithoutColorLookupInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutColorLookupInput | DeviceImageColorsCreateOrConnectWithoutColorLookupInput[]
    createMany?: DeviceImageColorsCreateManyColorLookupInputEnvelope
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
  }

  export type DeviceImageColorsUncheckedCreateNestedManyWithoutColorLookupInput = {
    create?: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput> | DeviceImageColorsCreateWithoutColorLookupInput[] | DeviceImageColorsUncheckedCreateWithoutColorLookupInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutColorLookupInput | DeviceImageColorsCreateOrConnectWithoutColorLookupInput[]
    createMany?: DeviceImageColorsCreateManyColorLookupInputEnvelope
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DeviceImageColorsUpdateManyWithoutColorLookupNestedInput = {
    create?: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput> | DeviceImageColorsCreateWithoutColorLookupInput[] | DeviceImageColorsUncheckedCreateWithoutColorLookupInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutColorLookupInput | DeviceImageColorsCreateOrConnectWithoutColorLookupInput[]
    upsert?: DeviceImageColorsUpsertWithWhereUniqueWithoutColorLookupInput | DeviceImageColorsUpsertWithWhereUniqueWithoutColorLookupInput[]
    createMany?: DeviceImageColorsCreateManyColorLookupInputEnvelope
    set?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    disconnect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    delete?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    update?: DeviceImageColorsUpdateWithWhereUniqueWithoutColorLookupInput | DeviceImageColorsUpdateWithWhereUniqueWithoutColorLookupInput[]
    updateMany?: DeviceImageColorsUpdateManyWithWhereWithoutColorLookupInput | DeviceImageColorsUpdateManyWithWhereWithoutColorLookupInput[]
    deleteMany?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceImageColorsUncheckedUpdateManyWithoutColorLookupNestedInput = {
    create?: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput> | DeviceImageColorsCreateWithoutColorLookupInput[] | DeviceImageColorsUncheckedCreateWithoutColorLookupInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutColorLookupInput | DeviceImageColorsCreateOrConnectWithoutColorLookupInput[]
    upsert?: DeviceImageColorsUpsertWithWhereUniqueWithoutColorLookupInput | DeviceImageColorsUpsertWithWhereUniqueWithoutColorLookupInput[]
    createMany?: DeviceImageColorsCreateManyColorLookupInputEnvelope
    set?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    disconnect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    delete?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    update?: DeviceImageColorsUpdateWithWhereUniqueWithoutColorLookupInput | DeviceImageColorsUpdateWithWhereUniqueWithoutColorLookupInput[]
    updateMany?: DeviceImageColorsUpdateManyWithWhereWithoutColorLookupInput | DeviceImageColorsUpdateManyWithWhereWithoutColorLookupInput[]
    deleteMany?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
  }

  export type DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput = {
    create?: XOR<DeviceLookupCategoryCreateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedCreateWithoutDeviceEntryInput>
    connectOrCreate?: DeviceLookupCategoryCreateOrConnectWithoutDeviceEntryInput
    connect?: DeviceLookupCategoryWhereUniqueInput
  }

  export type DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput = {
    create?: XOR<DeviceLookupImageCreateWithoutDeviceEntryInput, DeviceLookupImageUncheckedCreateWithoutDeviceEntryInput>
    connectOrCreate?: DeviceLookupImageCreateOrConnectWithoutDeviceEntryInput
    connect?: DeviceLookupImageWhereUniqueInput
  }

  export type DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceEntryInputEnvelope
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
  }

  export type DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput> | DeviceMapArchitectureCreateWithoutDeviceEntryInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
  }

  export type DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput> | DeviceMapIdentifierCreateWithoutDeviceEntryInput[] | DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput | DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapIdentifierCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
  }

  export type DeviceMapModelCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput> | DeviceMapModelCreateWithoutDeviceEntryInput[] | DeviceMapModelUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapModelCreateOrConnectWithoutDeviceEntryInput | DeviceMapModelCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapModelCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
  }

  export type DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput> | DeviceMapReleaseCreateWithoutDeviceEntryInput[] | DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput | DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapReleaseCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
  }

  export type DeviceMapSocCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput> | DeviceMapSocCreateWithoutDeviceEntryInput[] | DeviceMapSocUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceEntryInput | DeviceMapSocCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapSocCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
  }

  export type MapDeviceOsCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput> | MapDeviceOsCreateWithoutDeviceEntryInput[] | MapDeviceOsUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutDeviceEntryInput | MapDeviceOsCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: MapDeviceOsCreateManyDeviceEntryInputEnvelope
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
  }

  export type OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput> | OsEntryPreinstalledCreateWithoutDeviceEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput | OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyDeviceEntryInputEnvelope
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
  }

  export type SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput> | SourceMapDeviceCreateWithoutDeviceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput | SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: SourceMapDeviceCreateManyDeviceEntryInputEnvelope
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceEntryInputEnvelope
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
  }

  export type DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput> | DeviceMapArchitectureCreateWithoutDeviceEntryInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
  }

  export type DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput> | DeviceMapIdentifierCreateWithoutDeviceEntryInput[] | DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput | DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapIdentifierCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
  }

  export type DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput> | DeviceMapModelCreateWithoutDeviceEntryInput[] | DeviceMapModelUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapModelCreateOrConnectWithoutDeviceEntryInput | DeviceMapModelCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapModelCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
  }

  export type DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput> | DeviceMapReleaseCreateWithoutDeviceEntryInput[] | DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput | DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapReleaseCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
  }

  export type DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput> | DeviceMapSocCreateWithoutDeviceEntryInput[] | DeviceMapSocUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceEntryInput | DeviceMapSocCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: DeviceMapSocCreateManyDeviceEntryInputEnvelope
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
  }

  export type MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput> | MapDeviceOsCreateWithoutDeviceEntryInput[] | MapDeviceOsUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutDeviceEntryInput | MapDeviceOsCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: MapDeviceOsCreateManyDeviceEntryInputEnvelope
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
  }

  export type OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput> | OsEntryPreinstalledCreateWithoutDeviceEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput | OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyDeviceEntryInputEnvelope
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
  }

  export type SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput = {
    create?: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput> | SourceMapDeviceCreateWithoutDeviceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput | SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    createMany?: SourceMapDeviceCreateManyDeviceEntryInputEnvelope
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceLookupCategoryCreateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedCreateWithoutDeviceEntryInput>
    connectOrCreate?: DeviceLookupCategoryCreateOrConnectWithoutDeviceEntryInput
    upsert?: DeviceLookupCategoryUpsertWithoutDeviceEntryInput
    connect?: DeviceLookupCategoryWhereUniqueInput
    update?: XOR<XOR<DeviceLookupCategoryUpdateToOneWithWhereWithoutDeviceEntryInput, DeviceLookupCategoryUpdateWithoutDeviceEntryInput>, DeviceLookupCategoryUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceLookupImageCreateWithoutDeviceEntryInput, DeviceLookupImageUncheckedCreateWithoutDeviceEntryInput>
    connectOrCreate?: DeviceLookupImageCreateOrConnectWithoutDeviceEntryInput
    upsert?: DeviceLookupImageUpsertWithoutDeviceEntryInput
    disconnect?: DeviceLookupImageWhereInput | boolean
    delete?: DeviceLookupImageWhereInput | boolean
    connect?: DeviceLookupImageWhereUniqueInput
    update?: XOR<XOR<DeviceLookupImageUpdateToOneWithWhereWithoutDeviceEntryInput, DeviceLookupImageUpdateWithoutDeviceEntryInput>, DeviceLookupImageUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceEntryInputEnvelope
    set?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    update?: DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput | DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
  }

  export type DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput> | DeviceMapArchitectureCreateWithoutDeviceEntryInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    disconnect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    delete?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    update?: DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
  }

  export type DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput> | DeviceMapIdentifierCreateWithoutDeviceEntryInput[] | DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput | DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapIdentifierUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapIdentifierUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapIdentifierCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    disconnect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    delete?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    connect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    update?: DeviceMapIdentifierUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapIdentifierUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapIdentifierUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapIdentifierUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapIdentifierScalarWhereInput | DeviceMapIdentifierScalarWhereInput[]
  }

  export type DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput> | DeviceMapModelCreateWithoutDeviceEntryInput[] | DeviceMapModelUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapModelCreateOrConnectWithoutDeviceEntryInput | DeviceMapModelCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapModelUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapModelUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapModelCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    disconnect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    delete?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    connect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    update?: DeviceMapModelUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapModelUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapModelUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapModelUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapModelScalarWhereInput | DeviceMapModelScalarWhereInput[]
  }

  export type DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput> | DeviceMapReleaseCreateWithoutDeviceEntryInput[] | DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput | DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapReleaseUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapReleaseUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapReleaseCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    disconnect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    delete?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    connect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    update?: DeviceMapReleaseUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapReleaseUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapReleaseUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapReleaseUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapReleaseScalarWhereInput | DeviceMapReleaseScalarWhereInput[]
  }

  export type DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput> | DeviceMapSocCreateWithoutDeviceEntryInput[] | DeviceMapSocUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceEntryInput | DeviceMapSocCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapSocUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapSocUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapSocCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    disconnect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    delete?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    update?: DeviceMapSocUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapSocUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapSocUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapSocUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
  }

  export type MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput> | MapDeviceOsCreateWithoutDeviceEntryInput[] | MapDeviceOsUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutDeviceEntryInput | MapDeviceOsCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: MapDeviceOsUpsertWithWhereUniqueWithoutDeviceEntryInput | MapDeviceOsUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: MapDeviceOsCreateManyDeviceEntryInputEnvelope
    set?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    disconnect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    delete?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    update?: MapDeviceOsUpdateWithWhereUniqueWithoutDeviceEntryInput | MapDeviceOsUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: MapDeviceOsUpdateManyWithWhereWithoutDeviceEntryInput | MapDeviceOsUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
  }

  export type OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput> | OsEntryPreinstalledCreateWithoutDeviceEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput | OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: OsEntryPreinstalledUpsertWithWhereUniqueWithoutDeviceEntryInput | OsEntryPreinstalledUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyDeviceEntryInputEnvelope
    set?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    disconnect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    delete?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    update?: OsEntryPreinstalledUpdateWithWhereUniqueWithoutDeviceEntryInput | OsEntryPreinstalledUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: OsEntryPreinstalledUpdateManyWithWhereWithoutDeviceEntryInput | OsEntryPreinstalledUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
  }

  export type SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput> | SourceMapDeviceCreateWithoutDeviceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput | SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: SourceMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput | SourceMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: SourceMapDeviceCreateManyDeviceEntryInputEnvelope
    set?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    disconnect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    delete?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    update?: SourceMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput | SourceMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: SourceMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput | SourceMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceEntryInputEnvelope
    set?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    update?: DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput | DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
  }

  export type DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput> | DeviceMapArchitectureCreateWithoutDeviceEntryInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    disconnect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    delete?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    update?: DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
  }

  export type DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput> | DeviceMapIdentifierCreateWithoutDeviceEntryInput[] | DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput | DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapIdentifierUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapIdentifierUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapIdentifierCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    disconnect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    delete?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    connect?: DeviceMapIdentifierWhereUniqueInput | DeviceMapIdentifierWhereUniqueInput[]
    update?: DeviceMapIdentifierUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapIdentifierUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapIdentifierUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapIdentifierUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapIdentifierScalarWhereInput | DeviceMapIdentifierScalarWhereInput[]
  }

  export type DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput> | DeviceMapModelCreateWithoutDeviceEntryInput[] | DeviceMapModelUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapModelCreateOrConnectWithoutDeviceEntryInput | DeviceMapModelCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapModelUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapModelUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapModelCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    disconnect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    delete?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    connect?: DeviceMapModelWhereUniqueInput | DeviceMapModelWhereUniqueInput[]
    update?: DeviceMapModelUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapModelUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapModelUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapModelUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapModelScalarWhereInput | DeviceMapModelScalarWhereInput[]
  }

  export type DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput> | DeviceMapReleaseCreateWithoutDeviceEntryInput[] | DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput | DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapReleaseUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapReleaseUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapReleaseCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    disconnect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    delete?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    connect?: DeviceMapReleaseWhereUniqueInput | DeviceMapReleaseWhereUniqueInput[]
    update?: DeviceMapReleaseUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapReleaseUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapReleaseUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapReleaseUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapReleaseScalarWhereInput | DeviceMapReleaseScalarWhereInput[]
  }

  export type DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput> | DeviceMapSocCreateWithoutDeviceEntryInput[] | DeviceMapSocUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceEntryInput | DeviceMapSocCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: DeviceMapSocUpsertWithWhereUniqueWithoutDeviceEntryInput | DeviceMapSocUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: DeviceMapSocCreateManyDeviceEntryInputEnvelope
    set?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    disconnect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    delete?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    update?: DeviceMapSocUpdateWithWhereUniqueWithoutDeviceEntryInput | DeviceMapSocUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: DeviceMapSocUpdateManyWithWhereWithoutDeviceEntryInput | DeviceMapSocUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
  }

  export type MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput> | MapDeviceOsCreateWithoutDeviceEntryInput[] | MapDeviceOsUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutDeviceEntryInput | MapDeviceOsCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: MapDeviceOsUpsertWithWhereUniqueWithoutDeviceEntryInput | MapDeviceOsUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: MapDeviceOsCreateManyDeviceEntryInputEnvelope
    set?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    disconnect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    delete?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    update?: MapDeviceOsUpdateWithWhereUniqueWithoutDeviceEntryInput | MapDeviceOsUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: MapDeviceOsUpdateManyWithWhereWithoutDeviceEntryInput | MapDeviceOsUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
  }

  export type OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput> | OsEntryPreinstalledCreateWithoutDeviceEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput | OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: OsEntryPreinstalledUpsertWithWhereUniqueWithoutDeviceEntryInput | OsEntryPreinstalledUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyDeviceEntryInputEnvelope
    set?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    disconnect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    delete?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    update?: OsEntryPreinstalledUpdateWithWhereUniqueWithoutDeviceEntryInput | OsEntryPreinstalledUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: OsEntryPreinstalledUpdateManyWithWhereWithoutDeviceEntryInput | OsEntryPreinstalledUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
  }

  export type SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput = {
    create?: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput> | SourceMapDeviceCreateWithoutDeviceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput | SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput[]
    upsert?: SourceMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput | SourceMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput[]
    createMany?: SourceMapDeviceCreateManyDeviceEntryInputEnvelope
    set?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    disconnect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    delete?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    update?: SourceMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput | SourceMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput[]
    updateMany?: SourceMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput | SourceMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput[]
    deleteMany?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceCreateNestedManyWithoutDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInputEnvelope
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
  }

  export type DeviceGroupMapDeviceUpdateManyWithoutDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    update?: DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    update?: DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    update?: DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput> | DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput[] | DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceCreateManyDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceWhereUniqueInput | DeviceGroupMapDeviceWhereUniqueInput[]
    update?: DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceGroupEntryInput | DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    update?: DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput> | DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[] | DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    connectOrCreate?: DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    upsert?: DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    createMany?: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInputEnvelope
    set?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    disconnect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    delete?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    connect?: DeviceGroupMapDeviceGroupWhereUniqueInput | DeviceGroupMapDeviceGroupWhereUniqueInput[]
    update?: DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    updateMany?: DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    deleteMany?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
  }

  export type DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput
    connect?: DeviceGroupEntryWhereUniqueInput
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput
    upsert?: DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceInput
    connect?: DeviceGroupEntryWhereUniqueInput
    update?: XOR<XOR<DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceInput>, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput
    upsert?: DeviceEntryUpsertWithoutDeviceGroupMapDeviceInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceInput, DeviceEntryUpdateWithoutDeviceGroupMapDeviceInput>, DeviceEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    connect?: DeviceGroupEntryWhereUniqueInput
  }

  export type DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
    connect?: DeviceGroupEntryWhereUniqueInput
  }

  export type DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    upsert?: DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    connect?: DeviceGroupEntryWhereUniqueInput
    update?: XOR<XOR<DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput = {
    create?: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
    connectOrCreate?: DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
    upsert?: DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
    connect?: DeviceGroupEntryWhereUniqueInput
    update?: XOR<XOR<DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceLookupImageCreateNestedOneWithoutDeviceImageColorsInput = {
    create?: XOR<DeviceLookupImageCreateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedCreateWithoutDeviceImageColorsInput>
    connectOrCreate?: DeviceLookupImageCreateOrConnectWithoutDeviceImageColorsInput
    connect?: DeviceLookupImageWhereUniqueInput
  }

  export type ColorLookupCreateNestedOneWithoutDeviceImageColorsInput = {
    create?: XOR<ColorLookupCreateWithoutDeviceImageColorsInput, ColorLookupUncheckedCreateWithoutDeviceImageColorsInput>
    connectOrCreate?: ColorLookupCreateOrConnectWithoutDeviceImageColorsInput
    connect?: ColorLookupWhereUniqueInput
  }

  export type DeviceLookupImageUpdateOneRequiredWithoutDeviceImageColorsNestedInput = {
    create?: XOR<DeviceLookupImageCreateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedCreateWithoutDeviceImageColorsInput>
    connectOrCreate?: DeviceLookupImageCreateOrConnectWithoutDeviceImageColorsInput
    upsert?: DeviceLookupImageUpsertWithoutDeviceImageColorsInput
    connect?: DeviceLookupImageWhereUniqueInput
    update?: XOR<XOR<DeviceLookupImageUpdateToOneWithWhereWithoutDeviceImageColorsInput, DeviceLookupImageUpdateWithoutDeviceImageColorsInput>, DeviceLookupImageUncheckedUpdateWithoutDeviceImageColorsInput>
  }

  export type ColorLookupUpdateOneRequiredWithoutDeviceImageColorsNestedInput = {
    create?: XOR<ColorLookupCreateWithoutDeviceImageColorsInput, ColorLookupUncheckedCreateWithoutDeviceImageColorsInput>
    connectOrCreate?: ColorLookupCreateOrConnectWithoutDeviceImageColorsInput
    upsert?: ColorLookupUpsertWithoutDeviceImageColorsInput
    connect?: ColorLookupWhereUniqueInput
    update?: XOR<XOR<ColorLookupUpdateToOneWithWhereWithoutDeviceImageColorsInput, ColorLookupUpdateWithoutDeviceImageColorsInput>, ColorLookupUncheckedUpdateWithoutDeviceImageColorsInput>
  }

  export type DeviceMapArchitectureCreateNestedManyWithoutDeviceLookupArchitectureInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput> | DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceLookupArchitectureInputEnvelope
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
  }

  export type DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceLookupArchitectureInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput> | DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceLookupArchitectureInputEnvelope
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
  }

  export type DeviceMapArchitectureUpdateManyWithoutDeviceLookupArchitectureNestedInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput> | DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput[]
    upsert?: DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceLookupArchitectureInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceLookupArchitectureInputEnvelope
    set?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    disconnect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    delete?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    update?: DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceLookupArchitectureInput[]
    updateMany?: DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceLookupArchitectureInput[]
    deleteMany?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
  }

  export type DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceLookupArchitectureNestedInput = {
    create?: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput> | DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput[] | DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput[]
    connectOrCreate?: DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput[]
    upsert?: DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceLookupArchitectureInput[]
    createMany?: DeviceMapArchitectureCreateManyDeviceLookupArchitectureInputEnvelope
    set?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    disconnect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    delete?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    connect?: DeviceMapArchitectureWhereUniqueInput | DeviceMapArchitectureWhereUniqueInput[]
    update?: DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceLookupArchitectureInput[]
    updateMany?: DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceLookupArchitectureInput | DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceLookupArchitectureInput[]
    deleteMany?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
  }

  export type DeviceEntryCreateNestedManyWithoutDeviceLookupCategoryInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput> | DeviceEntryCreateWithoutDeviceLookupCategoryInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput | DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupCategoryInputEnvelope
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
  }

  export type DeviceEntryUncheckedCreateNestedManyWithoutDeviceLookupCategoryInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput> | DeviceEntryCreateWithoutDeviceLookupCategoryInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput | DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupCategoryInputEnvelope
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
  }

  export type DeviceEntryUpdateManyWithoutDeviceLookupCategoryNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput> | DeviceEntryCreateWithoutDeviceLookupCategoryInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput | DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput[]
    upsert?: DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupCategoryInput | DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupCategoryInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupCategoryInputEnvelope
    set?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    disconnect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    delete?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    update?: DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupCategoryInput | DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupCategoryInput[]
    updateMany?: DeviceEntryUpdateManyWithWhereWithoutDeviceLookupCategoryInput | DeviceEntryUpdateManyWithWhereWithoutDeviceLookupCategoryInput[]
    deleteMany?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
  }

  export type DeviceEntryUncheckedUpdateManyWithoutDeviceLookupCategoryNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput> | DeviceEntryCreateWithoutDeviceLookupCategoryInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput | DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput[]
    upsert?: DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupCategoryInput | DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupCategoryInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupCategoryInputEnvelope
    set?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    disconnect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    delete?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    update?: DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupCategoryInput | DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupCategoryInput[]
    updateMany?: DeviceEntryUpdateManyWithWhereWithoutDeviceLookupCategoryInput | DeviceEntryUpdateManyWithWhereWithoutDeviceLookupCategoryInput[]
    deleteMany?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
  }

  export type DeviceEntryCreateNestedManyWithoutDeviceLookupImageInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput> | DeviceEntryCreateWithoutDeviceLookupImageInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput | DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupImageInputEnvelope
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
  }

  export type DeviceImageColorsCreateNestedManyWithoutDeviceLookupImageInput = {
    create?: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput> | DeviceImageColorsCreateWithoutDeviceLookupImageInput[] | DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput | DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput[]
    createMany?: DeviceImageColorsCreateManyDeviceLookupImageInputEnvelope
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
  }

  export type DeviceEntryUncheckedCreateNestedManyWithoutDeviceLookupImageInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput> | DeviceEntryCreateWithoutDeviceLookupImageInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput | DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupImageInputEnvelope
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
  }

  export type DeviceImageColorsUncheckedCreateNestedManyWithoutDeviceLookupImageInput = {
    create?: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput> | DeviceImageColorsCreateWithoutDeviceLookupImageInput[] | DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput | DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput[]
    createMany?: DeviceImageColorsCreateManyDeviceLookupImageInputEnvelope
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
  }

  export type DeviceEntryUpdateManyWithoutDeviceLookupImageNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput> | DeviceEntryCreateWithoutDeviceLookupImageInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput | DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput[]
    upsert?: DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupImageInput | DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupImageInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupImageInputEnvelope
    set?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    disconnect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    delete?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    update?: DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupImageInput | DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupImageInput[]
    updateMany?: DeviceEntryUpdateManyWithWhereWithoutDeviceLookupImageInput | DeviceEntryUpdateManyWithWhereWithoutDeviceLookupImageInput[]
    deleteMany?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
  }

  export type DeviceImageColorsUpdateManyWithoutDeviceLookupImageNestedInput = {
    create?: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput> | DeviceImageColorsCreateWithoutDeviceLookupImageInput[] | DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput | DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput[]
    upsert?: DeviceImageColorsUpsertWithWhereUniqueWithoutDeviceLookupImageInput | DeviceImageColorsUpsertWithWhereUniqueWithoutDeviceLookupImageInput[]
    createMany?: DeviceImageColorsCreateManyDeviceLookupImageInputEnvelope
    set?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    disconnect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    delete?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    update?: DeviceImageColorsUpdateWithWhereUniqueWithoutDeviceLookupImageInput | DeviceImageColorsUpdateWithWhereUniqueWithoutDeviceLookupImageInput[]
    updateMany?: DeviceImageColorsUpdateManyWithWhereWithoutDeviceLookupImageInput | DeviceImageColorsUpdateManyWithWhereWithoutDeviceLookupImageInput[]
    deleteMany?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
  }

  export type DeviceEntryUncheckedUpdateManyWithoutDeviceLookupImageNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput> | DeviceEntryCreateWithoutDeviceLookupImageInput[] | DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput | DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput[]
    upsert?: DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupImageInput | DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupImageInput[]
    createMany?: DeviceEntryCreateManyDeviceLookupImageInputEnvelope
    set?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    disconnect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    delete?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    connect?: DeviceEntryWhereUniqueInput | DeviceEntryWhereUniqueInput[]
    update?: DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupImageInput | DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupImageInput[]
    updateMany?: DeviceEntryUpdateManyWithWhereWithoutDeviceLookupImageInput | DeviceEntryUpdateManyWithWhereWithoutDeviceLookupImageInput[]
    deleteMany?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
  }

  export type DeviceImageColorsUncheckedUpdateManyWithoutDeviceLookupImageNestedInput = {
    create?: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput> | DeviceImageColorsCreateWithoutDeviceLookupImageInput[] | DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput[]
    connectOrCreate?: DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput | DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput[]
    upsert?: DeviceImageColorsUpsertWithWhereUniqueWithoutDeviceLookupImageInput | DeviceImageColorsUpsertWithWhereUniqueWithoutDeviceLookupImageInput[]
    createMany?: DeviceImageColorsCreateManyDeviceLookupImageInputEnvelope
    set?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    disconnect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    delete?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    connect?: DeviceImageColorsWhereUniqueInput | DeviceImageColorsWhereUniqueInput[]
    update?: DeviceImageColorsUpdateWithWhereUniqueWithoutDeviceLookupImageInput | DeviceImageColorsUpdateWithWhereUniqueWithoutDeviceLookupImageInput[]
    updateMany?: DeviceImageColorsUpdateManyWithWhereWithoutDeviceLookupImageInput | DeviceImageColorsUpdateManyWithWhereWithoutDeviceLookupImageInput[]
    deleteMany?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
  }

  export type DeviceMapSocCreateNestedManyWithoutDeviceLookupSocInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput> | DeviceMapSocCreateWithoutDeviceLookupSocInput[] | DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput | DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput[]
    createMany?: DeviceMapSocCreateManyDeviceLookupSocInputEnvelope
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
  }

  export type DeviceMapSocUncheckedCreateNestedManyWithoutDeviceLookupSocInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput> | DeviceMapSocCreateWithoutDeviceLookupSocInput[] | DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput | DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput[]
    createMany?: DeviceMapSocCreateManyDeviceLookupSocInputEnvelope
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
  }

  export type DeviceMapSocUpdateManyWithoutDeviceLookupSocNestedInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput> | DeviceMapSocCreateWithoutDeviceLookupSocInput[] | DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput | DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput[]
    upsert?: DeviceMapSocUpsertWithWhereUniqueWithoutDeviceLookupSocInput | DeviceMapSocUpsertWithWhereUniqueWithoutDeviceLookupSocInput[]
    createMany?: DeviceMapSocCreateManyDeviceLookupSocInputEnvelope
    set?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    disconnect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    delete?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    update?: DeviceMapSocUpdateWithWhereUniqueWithoutDeviceLookupSocInput | DeviceMapSocUpdateWithWhereUniqueWithoutDeviceLookupSocInput[]
    updateMany?: DeviceMapSocUpdateManyWithWhereWithoutDeviceLookupSocInput | DeviceMapSocUpdateManyWithWhereWithoutDeviceLookupSocInput[]
    deleteMany?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
  }

  export type DeviceMapSocUncheckedUpdateManyWithoutDeviceLookupSocNestedInput = {
    create?: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput> | DeviceMapSocCreateWithoutDeviceLookupSocInput[] | DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput[]
    connectOrCreate?: DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput | DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput[]
    upsert?: DeviceMapSocUpsertWithWhereUniqueWithoutDeviceLookupSocInput | DeviceMapSocUpsertWithWhereUniqueWithoutDeviceLookupSocInput[]
    createMany?: DeviceMapSocCreateManyDeviceLookupSocInputEnvelope
    set?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    disconnect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    delete?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    connect?: DeviceMapSocWhereUniqueInput | DeviceMapSocWhereUniqueInput[]
    update?: DeviceMapSocUpdateWithWhereUniqueWithoutDeviceLookupSocInput | DeviceMapSocUpdateWithWhereUniqueWithoutDeviceLookupSocInput[]
    updateMany?: DeviceMapSocUpdateManyWithWhereWithoutDeviceLookupSocInput | DeviceMapSocUpdateManyWithWhereWithoutDeviceLookupSocInput[]
    deleteMany?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceMapArchitectureInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedCreateWithoutDeviceMapArchitectureInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapArchitectureInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type DeviceLookupArchitectureCreateNestedOneWithoutDeviceMapArchitectureInput = {
    create?: XOR<DeviceLookupArchitectureCreateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedCreateWithoutDeviceMapArchitectureInput>
    connectOrCreate?: DeviceLookupArchitectureCreateOrConnectWithoutDeviceMapArchitectureInput
    connect?: DeviceLookupArchitectureWhereUniqueInput
  }

  export type DeviceEntryUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedCreateWithoutDeviceMapArchitectureInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapArchitectureInput
    upsert?: DeviceEntryUpsertWithoutDeviceMapArchitectureInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceMapArchitectureInput, DeviceEntryUpdateWithoutDeviceMapArchitectureInput>, DeviceEntryUncheckedUpdateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceLookupArchitectureUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput = {
    create?: XOR<DeviceLookupArchitectureCreateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedCreateWithoutDeviceMapArchitectureInput>
    connectOrCreate?: DeviceLookupArchitectureCreateOrConnectWithoutDeviceMapArchitectureInput
    upsert?: DeviceLookupArchitectureUpsertWithoutDeviceMapArchitectureInput
    connect?: DeviceLookupArchitectureWhereUniqueInput
    update?: XOR<XOR<DeviceLookupArchitectureUpdateToOneWithWhereWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUpdateWithoutDeviceMapArchitectureInput>, DeviceLookupArchitectureUncheckedUpdateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceMapIdentifierInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedCreateWithoutDeviceMapIdentifierInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapIdentifierInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type DeviceEntryUpdateOneRequiredWithoutDeviceMapIdentifierNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedCreateWithoutDeviceMapIdentifierInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapIdentifierInput
    upsert?: DeviceEntryUpsertWithoutDeviceMapIdentifierInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceMapIdentifierInput, DeviceEntryUpdateWithoutDeviceMapIdentifierInput>, DeviceEntryUncheckedUpdateWithoutDeviceMapIdentifierInput>
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceMapModelInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapModelInput, DeviceEntryUncheckedCreateWithoutDeviceMapModelInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapModelInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type DeviceEntryUpdateOneRequiredWithoutDeviceMapModelNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapModelInput, DeviceEntryUncheckedCreateWithoutDeviceMapModelInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapModelInput
    upsert?: DeviceEntryUpsertWithoutDeviceMapModelInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceMapModelInput, DeviceEntryUpdateWithoutDeviceMapModelInput>, DeviceEntryUncheckedUpdateWithoutDeviceMapModelInput>
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceMapReleaseInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedCreateWithoutDeviceMapReleaseInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapReleaseInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DeviceEntryUpdateOneWithoutDeviceMapReleaseNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedCreateWithoutDeviceMapReleaseInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapReleaseInput
    upsert?: DeviceEntryUpsertWithoutDeviceMapReleaseInput
    disconnect?: DeviceEntryWhereInput | boolean
    delete?: DeviceEntryWhereInput | boolean
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceMapReleaseInput, DeviceEntryUpdateWithoutDeviceMapReleaseInput>, DeviceEntryUncheckedUpdateWithoutDeviceMapReleaseInput>
  }

  export type DeviceEntryCreateNestedOneWithoutDeviceMapSocInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapSocInput, DeviceEntryUncheckedCreateWithoutDeviceMapSocInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapSocInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type DeviceLookupSocCreateNestedOneWithoutDeviceMapSocInput = {
    create?: XOR<DeviceLookupSocCreateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedCreateWithoutDeviceMapSocInput>
    connectOrCreate?: DeviceLookupSocCreateOrConnectWithoutDeviceMapSocInput
    connect?: DeviceLookupSocWhereUniqueInput
  }

  export type DeviceEntryUpdateOneRequiredWithoutDeviceMapSocNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutDeviceMapSocInput, DeviceEntryUncheckedCreateWithoutDeviceMapSocInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutDeviceMapSocInput
    upsert?: DeviceEntryUpsertWithoutDeviceMapSocInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutDeviceMapSocInput, DeviceEntryUpdateWithoutDeviceMapSocInput>, DeviceEntryUncheckedUpdateWithoutDeviceMapSocInput>
  }

  export type DeviceLookupSocUpdateOneRequiredWithoutDeviceMapSocNestedInput = {
    create?: XOR<DeviceLookupSocCreateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedCreateWithoutDeviceMapSocInput>
    connectOrCreate?: DeviceLookupSocCreateOrConnectWithoutDeviceMapSocInput
    upsert?: DeviceLookupSocUpsertWithoutDeviceMapSocInput
    connect?: DeviceLookupSocWhereUniqueInput
    update?: XOR<XOR<DeviceLookupSocUpdateToOneWithWhereWithoutDeviceMapSocInput, DeviceLookupSocUpdateWithoutDeviceMapSocInput>, DeviceLookupSocUncheckedUpdateWithoutDeviceMapSocInput>
  }

  export type DeviceEntryCreateNestedOneWithoutMapDeviceOsInput = {
    create?: XOR<DeviceEntryCreateWithoutMapDeviceOsInput, DeviceEntryUncheckedCreateWithoutMapDeviceOsInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutMapDeviceOsInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type OsEntryCreateNestedOneWithoutMapDeviceOsInput = {
    create?: XOR<OsEntryCreateWithoutMapDeviceOsInput, OsEntryUncheckedCreateWithoutMapDeviceOsInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutMapDeviceOsInput
    connect?: OsEntryWhereUniqueInput
  }

  export type DeviceEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutMapDeviceOsInput, DeviceEntryUncheckedCreateWithoutMapDeviceOsInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutMapDeviceOsInput
    upsert?: DeviceEntryUpsertWithoutMapDeviceOsInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutMapDeviceOsInput, DeviceEntryUpdateWithoutMapDeviceOsInput>, DeviceEntryUncheckedUpdateWithoutMapDeviceOsInput>
  }

  export type OsEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput = {
    create?: XOR<OsEntryCreateWithoutMapDeviceOsInput, OsEntryUncheckedCreateWithoutMapDeviceOsInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutMapDeviceOsInput
    upsert?: OsEntryUpsertWithoutMapDeviceOsInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutMapDeviceOsInput, OsEntryUpdateWithoutMapDeviceOsInput>, OsEntryUncheckedUpdateWithoutMapDeviceOsInput>
  }

  export type MapDeviceOsCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput> | MapDeviceOsCreateWithoutOsEntryInput[] | MapDeviceOsUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutOsEntryInput | MapDeviceOsCreateOrConnectWithoutOsEntryInput[]
    createMany?: MapDeviceOsCreateManyOsEntryInputEnvelope
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
  }

  export type OsLookupNameCreateNestedOneWithoutOsEntryInput = {
    create?: XOR<OsLookupNameCreateWithoutOsEntryInput, OsLookupNameUncheckedCreateWithoutOsEntryInput>
    connectOrCreate?: OsLookupNameCreateOrConnectWithoutOsEntryInput
    connect?: OsLookupNameWhereUniqueInput
  }

  export type OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput> | OsEntryBuildTrainCreateWithoutOsEntryInput[] | OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput | OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryBuildTrainCreateManyOsEntryInputEnvelope
    connect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
  }

  export type OsEntryIpdCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput> | OsEntryIpdCreateWithoutOsEntryInput[] | OsEntryIpdUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryIpdCreateOrConnectWithoutOsEntryInput | OsEntryIpdCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryIpdCreateManyOsEntryInputEnvelope
    connect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
  }

  export type OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput> | OsEntryOsStringMapCreateWithoutOsEntryInput[] | OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput | OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryOsStringMapCreateManyOsEntryInputEnvelope
    connect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
  }

  export type OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput> | OsEntryPreinstalledCreateWithoutOsEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput | OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyOsEntryInputEnvelope
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
  }

  export type OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput> | OsEntryReleaseNoteCreateWithoutOsEntryInput[] | OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput | OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryReleaseNoteCreateManyOsEntryInputEnvelope
    connect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
  }

  export type OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput> | OsEntrySafariVersionCreateWithoutOsEntryInput[] | OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput | OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntrySafariVersionCreateManyOsEntryInputEnvelope
    connect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
  }

  export type OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput> | OsEntrySecurityNoteCreateWithoutOsEntryInput[] | OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput | OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntrySecurityNoteCreateManyOsEntryInputEnvelope
    connect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
  }

  export type SourceEntryCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput> | SourceEntryCreateWithoutOsEntryInput[] | SourceEntryUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: SourceEntryCreateOrConnectWithoutOsEntryInput | SourceEntryCreateOrConnectWithoutOsEntryInput[]
    createMany?: SourceEntryCreateManyOsEntryInputEnvelope
    connect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
  }

  export type MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput> | MapDeviceOsCreateWithoutOsEntryInput[] | MapDeviceOsUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutOsEntryInput | MapDeviceOsCreateOrConnectWithoutOsEntryInput[]
    createMany?: MapDeviceOsCreateManyOsEntryInputEnvelope
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
  }

  export type OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput> | OsEntryBuildTrainCreateWithoutOsEntryInput[] | OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput | OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryBuildTrainCreateManyOsEntryInputEnvelope
    connect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
  }

  export type OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput> | OsEntryIpdCreateWithoutOsEntryInput[] | OsEntryIpdUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryIpdCreateOrConnectWithoutOsEntryInput | OsEntryIpdCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryIpdCreateManyOsEntryInputEnvelope
    connect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
  }

  export type OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput> | OsEntryOsStringMapCreateWithoutOsEntryInput[] | OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput | OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryOsStringMapCreateManyOsEntryInputEnvelope
    connect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
  }

  export type OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput> | OsEntryPreinstalledCreateWithoutOsEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput | OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyOsEntryInputEnvelope
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
  }

  export type OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput> | OsEntryReleaseNoteCreateWithoutOsEntryInput[] | OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput | OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntryReleaseNoteCreateManyOsEntryInputEnvelope
    connect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
  }

  export type OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput> | OsEntrySafariVersionCreateWithoutOsEntryInput[] | OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput | OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntrySafariVersionCreateManyOsEntryInputEnvelope
    connect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
  }

  export type OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput> | OsEntrySecurityNoteCreateWithoutOsEntryInput[] | OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput | OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput[]
    createMany?: OsEntrySecurityNoteCreateManyOsEntryInputEnvelope
    connect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
  }

  export type SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput = {
    create?: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput> | SourceEntryCreateWithoutOsEntryInput[] | SourceEntryUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: SourceEntryCreateOrConnectWithoutOsEntryInput | SourceEntryCreateOrConnectWithoutOsEntryInput[]
    createMany?: SourceEntryCreateManyOsEntryInputEnvelope
    connect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
  }

  export type MapDeviceOsUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput> | MapDeviceOsCreateWithoutOsEntryInput[] | MapDeviceOsUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutOsEntryInput | MapDeviceOsCreateOrConnectWithoutOsEntryInput[]
    upsert?: MapDeviceOsUpsertWithWhereUniqueWithoutOsEntryInput | MapDeviceOsUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: MapDeviceOsCreateManyOsEntryInputEnvelope
    set?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    disconnect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    delete?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    update?: MapDeviceOsUpdateWithWhereUniqueWithoutOsEntryInput | MapDeviceOsUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: MapDeviceOsUpdateManyWithWhereWithoutOsEntryInput | MapDeviceOsUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
  }

  export type OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput = {
    create?: XOR<OsLookupNameCreateWithoutOsEntryInput, OsLookupNameUncheckedCreateWithoutOsEntryInput>
    connectOrCreate?: OsLookupNameCreateOrConnectWithoutOsEntryInput
    upsert?: OsLookupNameUpsertWithoutOsEntryInput
    connect?: OsLookupNameWhereUniqueInput
    update?: XOR<XOR<OsLookupNameUpdateToOneWithWhereWithoutOsEntryInput, OsLookupNameUpdateWithoutOsEntryInput>, OsLookupNameUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput> | OsEntryBuildTrainCreateWithoutOsEntryInput[] | OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput | OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryBuildTrainUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryBuildTrainUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryBuildTrainCreateManyOsEntryInputEnvelope
    set?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    disconnect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    delete?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    connect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    update?: OsEntryBuildTrainUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryBuildTrainUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryBuildTrainUpdateManyWithWhereWithoutOsEntryInput | OsEntryBuildTrainUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryBuildTrainScalarWhereInput | OsEntryBuildTrainScalarWhereInput[]
  }

  export type OsEntryIpdUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput> | OsEntryIpdCreateWithoutOsEntryInput[] | OsEntryIpdUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryIpdCreateOrConnectWithoutOsEntryInput | OsEntryIpdCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryIpdUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryIpdUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryIpdCreateManyOsEntryInputEnvelope
    set?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    disconnect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    delete?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    connect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    update?: OsEntryIpdUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryIpdUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryIpdUpdateManyWithWhereWithoutOsEntryInput | OsEntryIpdUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryIpdScalarWhereInput | OsEntryIpdScalarWhereInput[]
  }

  export type OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput> | OsEntryOsStringMapCreateWithoutOsEntryInput[] | OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput | OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryOsStringMapUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryOsStringMapUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryOsStringMapCreateManyOsEntryInputEnvelope
    set?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    disconnect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    delete?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    connect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    update?: OsEntryOsStringMapUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryOsStringMapUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryOsStringMapUpdateManyWithWhereWithoutOsEntryInput | OsEntryOsStringMapUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryOsStringMapScalarWhereInput | OsEntryOsStringMapScalarWhereInput[]
  }

  export type OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput> | OsEntryPreinstalledCreateWithoutOsEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput | OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryPreinstalledUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryPreinstalledUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyOsEntryInputEnvelope
    set?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    disconnect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    delete?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    update?: OsEntryPreinstalledUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryPreinstalledUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryPreinstalledUpdateManyWithWhereWithoutOsEntryInput | OsEntryPreinstalledUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
  }

  export type OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput> | OsEntryReleaseNoteCreateWithoutOsEntryInput[] | OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput | OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryReleaseNoteUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryReleaseNoteUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryReleaseNoteCreateManyOsEntryInputEnvelope
    set?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    disconnect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    delete?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    connect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    update?: OsEntryReleaseNoteUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryReleaseNoteUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryReleaseNoteUpdateManyWithWhereWithoutOsEntryInput | OsEntryReleaseNoteUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryReleaseNoteScalarWhereInput | OsEntryReleaseNoteScalarWhereInput[]
  }

  export type OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput> | OsEntrySafariVersionCreateWithoutOsEntryInput[] | OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput | OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntrySafariVersionUpsertWithWhereUniqueWithoutOsEntryInput | OsEntrySafariVersionUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntrySafariVersionCreateManyOsEntryInputEnvelope
    set?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    disconnect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    delete?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    connect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    update?: OsEntrySafariVersionUpdateWithWhereUniqueWithoutOsEntryInput | OsEntrySafariVersionUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntrySafariVersionUpdateManyWithWhereWithoutOsEntryInput | OsEntrySafariVersionUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntrySafariVersionScalarWhereInput | OsEntrySafariVersionScalarWhereInput[]
  }

  export type OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput> | OsEntrySecurityNoteCreateWithoutOsEntryInput[] | OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput | OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntrySecurityNoteUpsertWithWhereUniqueWithoutOsEntryInput | OsEntrySecurityNoteUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntrySecurityNoteCreateManyOsEntryInputEnvelope
    set?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    disconnect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    delete?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    connect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    update?: OsEntrySecurityNoteUpdateWithWhereUniqueWithoutOsEntryInput | OsEntrySecurityNoteUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntrySecurityNoteUpdateManyWithWhereWithoutOsEntryInput | OsEntrySecurityNoteUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntrySecurityNoteScalarWhereInput | OsEntrySecurityNoteScalarWhereInput[]
  }

  export type SourceEntryUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput> | SourceEntryCreateWithoutOsEntryInput[] | SourceEntryUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: SourceEntryCreateOrConnectWithoutOsEntryInput | SourceEntryCreateOrConnectWithoutOsEntryInput[]
    upsert?: SourceEntryUpsertWithWhereUniqueWithoutOsEntryInput | SourceEntryUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: SourceEntryCreateManyOsEntryInputEnvelope
    set?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    disconnect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    delete?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    connect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    update?: SourceEntryUpdateWithWhereUniqueWithoutOsEntryInput | SourceEntryUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: SourceEntryUpdateManyWithWhereWithoutOsEntryInput | SourceEntryUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: SourceEntryScalarWhereInput | SourceEntryScalarWhereInput[]
  }

  export type MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput> | MapDeviceOsCreateWithoutOsEntryInput[] | MapDeviceOsUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: MapDeviceOsCreateOrConnectWithoutOsEntryInput | MapDeviceOsCreateOrConnectWithoutOsEntryInput[]
    upsert?: MapDeviceOsUpsertWithWhereUniqueWithoutOsEntryInput | MapDeviceOsUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: MapDeviceOsCreateManyOsEntryInputEnvelope
    set?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    disconnect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    delete?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    connect?: MapDeviceOsWhereUniqueInput | MapDeviceOsWhereUniqueInput[]
    update?: MapDeviceOsUpdateWithWhereUniqueWithoutOsEntryInput | MapDeviceOsUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: MapDeviceOsUpdateManyWithWhereWithoutOsEntryInput | MapDeviceOsUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
  }

  export type OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput> | OsEntryBuildTrainCreateWithoutOsEntryInput[] | OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput | OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryBuildTrainUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryBuildTrainUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryBuildTrainCreateManyOsEntryInputEnvelope
    set?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    disconnect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    delete?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    connect?: OsEntryBuildTrainWhereUniqueInput | OsEntryBuildTrainWhereUniqueInput[]
    update?: OsEntryBuildTrainUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryBuildTrainUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryBuildTrainUpdateManyWithWhereWithoutOsEntryInput | OsEntryBuildTrainUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryBuildTrainScalarWhereInput | OsEntryBuildTrainScalarWhereInput[]
  }

  export type OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput> | OsEntryIpdCreateWithoutOsEntryInput[] | OsEntryIpdUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryIpdCreateOrConnectWithoutOsEntryInput | OsEntryIpdCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryIpdUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryIpdUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryIpdCreateManyOsEntryInputEnvelope
    set?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    disconnect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    delete?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    connect?: OsEntryIpdWhereUniqueInput | OsEntryIpdWhereUniqueInput[]
    update?: OsEntryIpdUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryIpdUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryIpdUpdateManyWithWhereWithoutOsEntryInput | OsEntryIpdUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryIpdScalarWhereInput | OsEntryIpdScalarWhereInput[]
  }

  export type OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput> | OsEntryOsStringMapCreateWithoutOsEntryInput[] | OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput | OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryOsStringMapUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryOsStringMapUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryOsStringMapCreateManyOsEntryInputEnvelope
    set?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    disconnect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    delete?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    connect?: OsEntryOsStringMapWhereUniqueInput | OsEntryOsStringMapWhereUniqueInput[]
    update?: OsEntryOsStringMapUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryOsStringMapUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryOsStringMapUpdateManyWithWhereWithoutOsEntryInput | OsEntryOsStringMapUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryOsStringMapScalarWhereInput | OsEntryOsStringMapScalarWhereInput[]
  }

  export type OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput> | OsEntryPreinstalledCreateWithoutOsEntryInput[] | OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput | OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryPreinstalledUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryPreinstalledUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryPreinstalledCreateManyOsEntryInputEnvelope
    set?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    disconnect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    delete?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    connect?: OsEntryPreinstalledWhereUniqueInput | OsEntryPreinstalledWhereUniqueInput[]
    update?: OsEntryPreinstalledUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryPreinstalledUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryPreinstalledUpdateManyWithWhereWithoutOsEntryInput | OsEntryPreinstalledUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
  }

  export type OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput> | OsEntryReleaseNoteCreateWithoutOsEntryInput[] | OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput | OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntryReleaseNoteUpsertWithWhereUniqueWithoutOsEntryInput | OsEntryReleaseNoteUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntryReleaseNoteCreateManyOsEntryInputEnvelope
    set?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    disconnect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    delete?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    connect?: OsEntryReleaseNoteWhereUniqueInput | OsEntryReleaseNoteWhereUniqueInput[]
    update?: OsEntryReleaseNoteUpdateWithWhereUniqueWithoutOsEntryInput | OsEntryReleaseNoteUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntryReleaseNoteUpdateManyWithWhereWithoutOsEntryInput | OsEntryReleaseNoteUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntryReleaseNoteScalarWhereInput | OsEntryReleaseNoteScalarWhereInput[]
  }

  export type OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput> | OsEntrySafariVersionCreateWithoutOsEntryInput[] | OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput | OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntrySafariVersionUpsertWithWhereUniqueWithoutOsEntryInput | OsEntrySafariVersionUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntrySafariVersionCreateManyOsEntryInputEnvelope
    set?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    disconnect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    delete?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    connect?: OsEntrySafariVersionWhereUniqueInput | OsEntrySafariVersionWhereUniqueInput[]
    update?: OsEntrySafariVersionUpdateWithWhereUniqueWithoutOsEntryInput | OsEntrySafariVersionUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntrySafariVersionUpdateManyWithWhereWithoutOsEntryInput | OsEntrySafariVersionUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntrySafariVersionScalarWhereInput | OsEntrySafariVersionScalarWhereInput[]
  }

  export type OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput> | OsEntrySecurityNoteCreateWithoutOsEntryInput[] | OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput | OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput[]
    upsert?: OsEntrySecurityNoteUpsertWithWhereUniqueWithoutOsEntryInput | OsEntrySecurityNoteUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: OsEntrySecurityNoteCreateManyOsEntryInputEnvelope
    set?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    disconnect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    delete?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    connect?: OsEntrySecurityNoteWhereUniqueInput | OsEntrySecurityNoteWhereUniqueInput[]
    update?: OsEntrySecurityNoteUpdateWithWhereUniqueWithoutOsEntryInput | OsEntrySecurityNoteUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: OsEntrySecurityNoteUpdateManyWithWhereWithoutOsEntryInput | OsEntrySecurityNoteUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: OsEntrySecurityNoteScalarWhereInput | OsEntrySecurityNoteScalarWhereInput[]
  }

  export type SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput = {
    create?: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput> | SourceEntryCreateWithoutOsEntryInput[] | SourceEntryUncheckedCreateWithoutOsEntryInput[]
    connectOrCreate?: SourceEntryCreateOrConnectWithoutOsEntryInput | SourceEntryCreateOrConnectWithoutOsEntryInput[]
    upsert?: SourceEntryUpsertWithWhereUniqueWithoutOsEntryInput | SourceEntryUpsertWithWhereUniqueWithoutOsEntryInput[]
    createMany?: SourceEntryCreateManyOsEntryInputEnvelope
    set?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    disconnect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    delete?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    connect?: SourceEntryWhereUniqueInput | SourceEntryWhereUniqueInput[]
    update?: SourceEntryUpdateWithWhereUniqueWithoutOsEntryInput | SourceEntryUpdateWithWhereUniqueWithoutOsEntryInput[]
    updateMany?: SourceEntryUpdateManyWithWhereWithoutOsEntryInput | SourceEntryUpdateManyWithWhereWithoutOsEntryInput[]
    deleteMany?: SourceEntryScalarWhereInput | SourceEntryScalarWhereInput[]
  }

  export type OsEntryCreateNestedOneWithoutOsEntryBuildTrainInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryBuildTrainInput, OsEntryUncheckedCreateWithoutOsEntryBuildTrainInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryBuildTrainInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntryBuildTrainNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryBuildTrainInput, OsEntryUncheckedCreateWithoutOsEntryBuildTrainInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryBuildTrainInput
    upsert?: OsEntryUpsertWithoutOsEntryBuildTrainInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntryBuildTrainInput, OsEntryUpdateWithoutOsEntryBuildTrainInput>, OsEntryUncheckedUpdateWithoutOsEntryBuildTrainInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntryIpdInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryIpdInput, OsEntryUncheckedCreateWithoutOsEntryIpdInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryIpdInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntryIpdNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryIpdInput, OsEntryUncheckedCreateWithoutOsEntryIpdInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryIpdInput
    upsert?: OsEntryUpsertWithoutOsEntryIpdInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntryIpdInput, OsEntryUpdateWithoutOsEntryIpdInput>, OsEntryUncheckedUpdateWithoutOsEntryIpdInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntryOsStringMapInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryOsStringMapInput, OsEntryUncheckedCreateWithoutOsEntryOsStringMapInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryOsStringMapInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntryOsStringMapNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryOsStringMapInput, OsEntryUncheckedCreateWithoutOsEntryOsStringMapInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryOsStringMapInput
    upsert?: OsEntryUpsertWithoutOsEntryOsStringMapInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntryOsStringMapInput, OsEntryUpdateWithoutOsEntryOsStringMapInput>, OsEntryUncheckedUpdateWithoutOsEntryOsStringMapInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntryPreinstalledInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryPreinstalledInput, OsEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryPreinstalledInput
    connect?: OsEntryWhereUniqueInput
  }

  export type DeviceEntryCreateNestedOneWithoutOsEntryPreinstalledInput = {
    create?: XOR<DeviceEntryCreateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutOsEntryPreinstalledInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryPreinstalledInput, OsEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryPreinstalledInput
    upsert?: OsEntryUpsertWithoutOsEntryPreinstalledInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntryPreinstalledInput, OsEntryUpdateWithoutOsEntryPreinstalledInput>, OsEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
  }

  export type DeviceEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutOsEntryPreinstalledInput
    upsert?: DeviceEntryUpsertWithoutOsEntryPreinstalledInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutOsEntryPreinstalledInput, DeviceEntryUpdateWithoutOsEntryPreinstalledInput>, DeviceEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntryReleaseNoteInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedCreateWithoutOsEntryReleaseNoteInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryReleaseNoteInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntryReleaseNoteNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedCreateWithoutOsEntryReleaseNoteInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntryReleaseNoteInput
    upsert?: OsEntryUpsertWithoutOsEntryReleaseNoteInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntryReleaseNoteInput, OsEntryUpdateWithoutOsEntryReleaseNoteInput>, OsEntryUncheckedUpdateWithoutOsEntryReleaseNoteInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntrySafariVersionInput = {
    create?: XOR<OsEntryCreateWithoutOsEntrySafariVersionInput, OsEntryUncheckedCreateWithoutOsEntrySafariVersionInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntrySafariVersionInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntrySafariVersionNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntrySafariVersionInput, OsEntryUncheckedCreateWithoutOsEntrySafariVersionInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntrySafariVersionInput
    upsert?: OsEntryUpsertWithoutOsEntrySafariVersionInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntrySafariVersionInput, OsEntryUpdateWithoutOsEntrySafariVersionInput>, OsEntryUncheckedUpdateWithoutOsEntrySafariVersionInput>
  }

  export type OsEntryCreateNestedOneWithoutOsEntrySecurityNoteInput = {
    create?: XOR<OsEntryCreateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedCreateWithoutOsEntrySecurityNoteInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntrySecurityNoteInput
    connect?: OsEntryWhereUniqueInput
  }

  export type OsEntryUpdateOneRequiredWithoutOsEntrySecurityNoteNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedCreateWithoutOsEntrySecurityNoteInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsEntrySecurityNoteInput
    upsert?: OsEntryUpsertWithoutOsEntrySecurityNoteInput
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutOsEntrySecurityNoteInput, OsEntryUpdateWithoutOsEntrySecurityNoteInput>, OsEntryUncheckedUpdateWithoutOsEntrySecurityNoteInput>
  }

  export type OsEntryCreateNestedManyWithoutOsLookupNameInput = {
    create?: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput> | OsEntryCreateWithoutOsLookupNameInput[] | OsEntryUncheckedCreateWithoutOsLookupNameInput[]
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsLookupNameInput | OsEntryCreateOrConnectWithoutOsLookupNameInput[]
    createMany?: OsEntryCreateManyOsLookupNameInputEnvelope
    connect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
  }

  export type OsEntryUncheckedCreateNestedManyWithoutOsLookupNameInput = {
    create?: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput> | OsEntryCreateWithoutOsLookupNameInput[] | OsEntryUncheckedCreateWithoutOsLookupNameInput[]
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsLookupNameInput | OsEntryCreateOrConnectWithoutOsLookupNameInput[]
    createMany?: OsEntryCreateManyOsLookupNameInputEnvelope
    connect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
  }

  export type OsEntryUpdateManyWithoutOsLookupNameNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput> | OsEntryCreateWithoutOsLookupNameInput[] | OsEntryUncheckedCreateWithoutOsLookupNameInput[]
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsLookupNameInput | OsEntryCreateOrConnectWithoutOsLookupNameInput[]
    upsert?: OsEntryUpsertWithWhereUniqueWithoutOsLookupNameInput | OsEntryUpsertWithWhereUniqueWithoutOsLookupNameInput[]
    createMany?: OsEntryCreateManyOsLookupNameInputEnvelope
    set?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    disconnect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    delete?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    connect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    update?: OsEntryUpdateWithWhereUniqueWithoutOsLookupNameInput | OsEntryUpdateWithWhereUniqueWithoutOsLookupNameInput[]
    updateMany?: OsEntryUpdateManyWithWhereWithoutOsLookupNameInput | OsEntryUpdateManyWithWhereWithoutOsLookupNameInput[]
    deleteMany?: OsEntryScalarWhereInput | OsEntryScalarWhereInput[]
  }

  export type OsEntryUncheckedUpdateManyWithoutOsLookupNameNestedInput = {
    create?: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput> | OsEntryCreateWithoutOsLookupNameInput[] | OsEntryUncheckedCreateWithoutOsLookupNameInput[]
    connectOrCreate?: OsEntryCreateOrConnectWithoutOsLookupNameInput | OsEntryCreateOrConnectWithoutOsLookupNameInput[]
    upsert?: OsEntryUpsertWithWhereUniqueWithoutOsLookupNameInput | OsEntryUpsertWithWhereUniqueWithoutOsLookupNameInput[]
    createMany?: OsEntryCreateManyOsLookupNameInputEnvelope
    set?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    disconnect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    delete?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    connect?: OsEntryWhereUniqueInput | OsEntryWhereUniqueInput[]
    update?: OsEntryUpdateWithWhereUniqueWithoutOsLookupNameInput | OsEntryUpdateWithWhereUniqueWithoutOsLookupNameInput[]
    updateMany?: OsEntryUpdateManyWithWhereWithoutOsLookupNameInput | OsEntryUpdateManyWithWhereWithoutOsLookupNameInput[]
    deleteMany?: OsEntryScalarWhereInput | OsEntryScalarWhereInput[]
  }

  export type OsEntryCreateNestedOneWithoutSourceEntryInput = {
    create?: XOR<OsEntryCreateWithoutSourceEntryInput, OsEntryUncheckedCreateWithoutSourceEntryInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutSourceEntryInput
    connect?: OsEntryWhereUniqueInput
  }

  export type SourceHashCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput> | SourceHashCreateWithoutSourceEntryInput[] | SourceHashUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceHashCreateOrConnectWithoutSourceEntryInput | SourceHashCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceHashCreateManySourceEntryInputEnvelope
    connect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
  }

  export type SourceLinkCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput> | SourceLinkCreateWithoutSourceEntryInput[] | SourceLinkUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceLinkCreateOrConnectWithoutSourceEntryInput | SourceLinkCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceLinkCreateManySourceEntryInputEnvelope
    connect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
  }

  export type SourceMapDeviceCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput> | SourceMapDeviceCreateWithoutSourceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutSourceEntryInput | SourceMapDeviceCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceMapDeviceCreateManySourceEntryInputEnvelope
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
  }

  export type SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput> | SourcePrequisiteBuildCreateWithoutSourceEntryInput[] | SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput | SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourcePrequisiteBuildCreateManySourceEntryInputEnvelope
    connect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
  }

  export type SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput> | SourceHashCreateWithoutSourceEntryInput[] | SourceHashUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceHashCreateOrConnectWithoutSourceEntryInput | SourceHashCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceHashCreateManySourceEntryInputEnvelope
    connect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
  }

  export type SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput> | SourceLinkCreateWithoutSourceEntryInput[] | SourceLinkUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceLinkCreateOrConnectWithoutSourceEntryInput | SourceLinkCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceLinkCreateManySourceEntryInputEnvelope
    connect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
  }

  export type SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput> | SourceMapDeviceCreateWithoutSourceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutSourceEntryInput | SourceMapDeviceCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourceMapDeviceCreateManySourceEntryInputEnvelope
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
  }

  export type SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput = {
    create?: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput> | SourcePrequisiteBuildCreateWithoutSourceEntryInput[] | SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput | SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput[]
    createMany?: SourcePrequisiteBuildCreateManySourceEntryInputEnvelope
    connect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type OsEntryUpdateOneWithoutSourceEntryNestedInput = {
    create?: XOR<OsEntryCreateWithoutSourceEntryInput, OsEntryUncheckedCreateWithoutSourceEntryInput>
    connectOrCreate?: OsEntryCreateOrConnectWithoutSourceEntryInput
    upsert?: OsEntryUpsertWithoutSourceEntryInput
    disconnect?: OsEntryWhereInput | boolean
    delete?: OsEntryWhereInput | boolean
    connect?: OsEntryWhereUniqueInput
    update?: XOR<XOR<OsEntryUpdateToOneWithWhereWithoutSourceEntryInput, OsEntryUpdateWithoutSourceEntryInput>, OsEntryUncheckedUpdateWithoutSourceEntryInput>
  }

  export type SourceHashUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput> | SourceHashCreateWithoutSourceEntryInput[] | SourceHashUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceHashCreateOrConnectWithoutSourceEntryInput | SourceHashCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceHashUpsertWithWhereUniqueWithoutSourceEntryInput | SourceHashUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceHashCreateManySourceEntryInputEnvelope
    set?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    disconnect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    delete?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    connect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    update?: SourceHashUpdateWithWhereUniqueWithoutSourceEntryInput | SourceHashUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceHashUpdateManyWithWhereWithoutSourceEntryInput | SourceHashUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceHashScalarWhereInput | SourceHashScalarWhereInput[]
  }

  export type SourceLinkUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput> | SourceLinkCreateWithoutSourceEntryInput[] | SourceLinkUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceLinkCreateOrConnectWithoutSourceEntryInput | SourceLinkCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceLinkUpsertWithWhereUniqueWithoutSourceEntryInput | SourceLinkUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceLinkCreateManySourceEntryInputEnvelope
    set?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    disconnect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    delete?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    connect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    update?: SourceLinkUpdateWithWhereUniqueWithoutSourceEntryInput | SourceLinkUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceLinkUpdateManyWithWhereWithoutSourceEntryInput | SourceLinkUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceLinkScalarWhereInput | SourceLinkScalarWhereInput[]
  }

  export type SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput> | SourceMapDeviceCreateWithoutSourceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutSourceEntryInput | SourceMapDeviceCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceMapDeviceUpsertWithWhereUniqueWithoutSourceEntryInput | SourceMapDeviceUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceMapDeviceCreateManySourceEntryInputEnvelope
    set?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    disconnect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    delete?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    update?: SourceMapDeviceUpdateWithWhereUniqueWithoutSourceEntryInput | SourceMapDeviceUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceMapDeviceUpdateManyWithWhereWithoutSourceEntryInput | SourceMapDeviceUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
  }

  export type SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput> | SourcePrequisiteBuildCreateWithoutSourceEntryInput[] | SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput | SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourcePrequisiteBuildUpsertWithWhereUniqueWithoutSourceEntryInput | SourcePrequisiteBuildUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourcePrequisiteBuildCreateManySourceEntryInputEnvelope
    set?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    disconnect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    delete?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    connect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    update?: SourcePrequisiteBuildUpdateWithWhereUniqueWithoutSourceEntryInput | SourcePrequisiteBuildUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourcePrequisiteBuildUpdateManyWithWhereWithoutSourceEntryInput | SourcePrequisiteBuildUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourcePrequisiteBuildScalarWhereInput | SourcePrequisiteBuildScalarWhereInput[]
  }

  export type SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput> | SourceHashCreateWithoutSourceEntryInput[] | SourceHashUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceHashCreateOrConnectWithoutSourceEntryInput | SourceHashCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceHashUpsertWithWhereUniqueWithoutSourceEntryInput | SourceHashUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceHashCreateManySourceEntryInputEnvelope
    set?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    disconnect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    delete?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    connect?: SourceHashWhereUniqueInput | SourceHashWhereUniqueInput[]
    update?: SourceHashUpdateWithWhereUniqueWithoutSourceEntryInput | SourceHashUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceHashUpdateManyWithWhereWithoutSourceEntryInput | SourceHashUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceHashScalarWhereInput | SourceHashScalarWhereInput[]
  }

  export type SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput> | SourceLinkCreateWithoutSourceEntryInput[] | SourceLinkUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceLinkCreateOrConnectWithoutSourceEntryInput | SourceLinkCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceLinkUpsertWithWhereUniqueWithoutSourceEntryInput | SourceLinkUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceLinkCreateManySourceEntryInputEnvelope
    set?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    disconnect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    delete?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    connect?: SourceLinkWhereUniqueInput | SourceLinkWhereUniqueInput[]
    update?: SourceLinkUpdateWithWhereUniqueWithoutSourceEntryInput | SourceLinkUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceLinkUpdateManyWithWhereWithoutSourceEntryInput | SourceLinkUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceLinkScalarWhereInput | SourceLinkScalarWhereInput[]
  }

  export type SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput> | SourceMapDeviceCreateWithoutSourceEntryInput[] | SourceMapDeviceUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourceMapDeviceCreateOrConnectWithoutSourceEntryInput | SourceMapDeviceCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourceMapDeviceUpsertWithWhereUniqueWithoutSourceEntryInput | SourceMapDeviceUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourceMapDeviceCreateManySourceEntryInputEnvelope
    set?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    disconnect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    delete?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    connect?: SourceMapDeviceWhereUniqueInput | SourceMapDeviceWhereUniqueInput[]
    update?: SourceMapDeviceUpdateWithWhereUniqueWithoutSourceEntryInput | SourceMapDeviceUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourceMapDeviceUpdateManyWithWhereWithoutSourceEntryInput | SourceMapDeviceUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
  }

  export type SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput = {
    create?: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput> | SourcePrequisiteBuildCreateWithoutSourceEntryInput[] | SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput[]
    connectOrCreate?: SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput | SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput[]
    upsert?: SourcePrequisiteBuildUpsertWithWhereUniqueWithoutSourceEntryInput | SourcePrequisiteBuildUpsertWithWhereUniqueWithoutSourceEntryInput[]
    createMany?: SourcePrequisiteBuildCreateManySourceEntryInputEnvelope
    set?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    disconnect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    delete?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    connect?: SourcePrequisiteBuildWhereUniqueInput | SourcePrequisiteBuildWhereUniqueInput[]
    update?: SourcePrequisiteBuildUpdateWithWhereUniqueWithoutSourceEntryInput | SourcePrequisiteBuildUpdateWithWhereUniqueWithoutSourceEntryInput[]
    updateMany?: SourcePrequisiteBuildUpdateManyWithWhereWithoutSourceEntryInput | SourcePrequisiteBuildUpdateManyWithWhereWithoutSourceEntryInput[]
    deleteMany?: SourcePrequisiteBuildScalarWhereInput | SourcePrequisiteBuildScalarWhereInput[]
  }

  export type SourceEntryCreateNestedOneWithoutSourceHashInput = {
    create?: XOR<SourceEntryCreateWithoutSourceHashInput, SourceEntryUncheckedCreateWithoutSourceHashInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceHashInput
    connect?: SourceEntryWhereUniqueInput
  }

  export type SourceEntryUpdateOneRequiredWithoutSourceHashNestedInput = {
    create?: XOR<SourceEntryCreateWithoutSourceHashInput, SourceEntryUncheckedCreateWithoutSourceHashInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceHashInput
    upsert?: SourceEntryUpsertWithoutSourceHashInput
    connect?: SourceEntryWhereUniqueInput
    update?: XOR<XOR<SourceEntryUpdateToOneWithWhereWithoutSourceHashInput, SourceEntryUpdateWithoutSourceHashInput>, SourceEntryUncheckedUpdateWithoutSourceHashInput>
  }

  export type SourceEntryCreateNestedOneWithoutSourceLinkInput = {
    create?: XOR<SourceEntryCreateWithoutSourceLinkInput, SourceEntryUncheckedCreateWithoutSourceLinkInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceLinkInput
    connect?: SourceEntryWhereUniqueInput
  }

  export type SourceEntryUpdateOneRequiredWithoutSourceLinkNestedInput = {
    create?: XOR<SourceEntryCreateWithoutSourceLinkInput, SourceEntryUncheckedCreateWithoutSourceLinkInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceLinkInput
    upsert?: SourceEntryUpsertWithoutSourceLinkInput
    connect?: SourceEntryWhereUniqueInput
    update?: XOR<XOR<SourceEntryUpdateToOneWithWhereWithoutSourceLinkInput, SourceEntryUpdateWithoutSourceLinkInput>, SourceEntryUncheckedUpdateWithoutSourceLinkInput>
  }

  export type SourceEntryCreateNestedOneWithoutSourceMapDeviceInput = {
    create?: XOR<SourceEntryCreateWithoutSourceMapDeviceInput, SourceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceMapDeviceInput
    connect?: SourceEntryWhereUniqueInput
  }

  export type DeviceEntryCreateNestedOneWithoutSourceMapDeviceInput = {
    create?: XOR<DeviceEntryCreateWithoutSourceMapDeviceInput, DeviceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutSourceMapDeviceInput
    connect?: DeviceEntryWhereUniqueInput
  }

  export type SourceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput = {
    create?: XOR<SourceEntryCreateWithoutSourceMapDeviceInput, SourceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourceMapDeviceInput
    upsert?: SourceEntryUpsertWithoutSourceMapDeviceInput
    connect?: SourceEntryWhereUniqueInput
    update?: XOR<XOR<SourceEntryUpdateToOneWithWhereWithoutSourceMapDeviceInput, SourceEntryUpdateWithoutSourceMapDeviceInput>, SourceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
  }

  export type DeviceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput = {
    create?: XOR<DeviceEntryCreateWithoutSourceMapDeviceInput, DeviceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    connectOrCreate?: DeviceEntryCreateOrConnectWithoutSourceMapDeviceInput
    upsert?: DeviceEntryUpsertWithoutSourceMapDeviceInput
    connect?: DeviceEntryWhereUniqueInput
    update?: XOR<XOR<DeviceEntryUpdateToOneWithWhereWithoutSourceMapDeviceInput, DeviceEntryUpdateWithoutSourceMapDeviceInput>, DeviceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
  }

  export type SourceEntryCreateNestedOneWithoutSourcePrequisiteBuildInput = {
    create?: XOR<SourceEntryCreateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedCreateWithoutSourcePrequisiteBuildInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourcePrequisiteBuildInput
    connect?: SourceEntryWhereUniqueInput
  }

  export type SourceEntryUpdateOneRequiredWithoutSourcePrequisiteBuildNestedInput = {
    create?: XOR<SourceEntryCreateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedCreateWithoutSourcePrequisiteBuildInput>
    connectOrCreate?: SourceEntryCreateOrConnectWithoutSourcePrequisiteBuildInput
    upsert?: SourceEntryUpsertWithoutSourcePrequisiteBuildInput
    connect?: SourceEntryWhereUniqueInput
    update?: XOR<XOR<SourceEntryUpdateToOneWithWhereWithoutSourcePrequisiteBuildInput, SourceEntryUpdateWithoutSourcePrequisiteBuildInput>, SourceEntryUncheckedUpdateWithoutSourcePrequisiteBuildInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DeviceImageColorsCreateWithoutColorLookupInput = {
    dark_mode?: boolean | null
    DeviceLookupImage: DeviceLookupImageCreateNestedOneWithoutDeviceImageColorsInput
  }

  export type DeviceImageColorsUncheckedCreateWithoutColorLookupInput = {
    device_image_id: number
    dark_mode?: boolean | null
  }

  export type DeviceImageColorsCreateOrConnectWithoutColorLookupInput = {
    where: DeviceImageColorsWhereUniqueInput
    create: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput>
  }

  export type DeviceImageColorsCreateManyColorLookupInputEnvelope = {
    data: DeviceImageColorsCreateManyColorLookupInput | DeviceImageColorsCreateManyColorLookupInput[]
    skipDuplicates?: boolean
  }

  export type DeviceImageColorsUpsertWithWhereUniqueWithoutColorLookupInput = {
    where: DeviceImageColorsWhereUniqueInput
    update: XOR<DeviceImageColorsUpdateWithoutColorLookupInput, DeviceImageColorsUncheckedUpdateWithoutColorLookupInput>
    create: XOR<DeviceImageColorsCreateWithoutColorLookupInput, DeviceImageColorsUncheckedCreateWithoutColorLookupInput>
  }

  export type DeviceImageColorsUpdateWithWhereUniqueWithoutColorLookupInput = {
    where: DeviceImageColorsWhereUniqueInput
    data: XOR<DeviceImageColorsUpdateWithoutColorLookupInput, DeviceImageColorsUncheckedUpdateWithoutColorLookupInput>
  }

  export type DeviceImageColorsUpdateManyWithWhereWithoutColorLookupInput = {
    where: DeviceImageColorsScalarWhereInput
    data: XOR<DeviceImageColorsUpdateManyMutationInput, DeviceImageColorsUncheckedUpdateManyWithoutColorLookupInput>
  }

  export type DeviceImageColorsScalarWhereInput = {
    AND?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
    OR?: DeviceImageColorsScalarWhereInput[]
    NOT?: DeviceImageColorsScalarWhereInput | DeviceImageColorsScalarWhereInput[]
    device_image_id?: IntFilter<"DeviceImageColors"> | number
    color_id?: IntFilter<"DeviceImageColors"> | number
    dark_mode?: BoolNullableFilter<"DeviceImageColors"> | boolean | null
  }

  export type DeviceLookupCategoryCreateWithoutDeviceEntryInput = {
    name: string
  }

  export type DeviceLookupCategoryUncheckedCreateWithoutDeviceEntryInput = {
    id?: number
    name: string
  }

  export type DeviceLookupCategoryCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceLookupCategoryWhereUniqueInput
    create: XOR<DeviceLookupCategoryCreateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceLookupImageCreateWithoutDeviceEntryInput = {
    name: string
    DeviceImageColors?: DeviceImageColorsCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageUncheckedCreateWithoutDeviceEntryInput = {
    id?: number
    name: string
    DeviceImageColors?: DeviceImageColorsUncheckedCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceLookupImageWhereUniqueInput
    create: XOR<DeviceLookupImageCreateWithoutDeviceEntryInput, DeviceLookupImageUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceCreateWithoutDeviceEntryInput = {
    DeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput
  }

  export type DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput = {
    group_id: number
  }

  export type DeviceGroupMapDeviceCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    create: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceCreateManyDeviceEntryInputEnvelope = {
    data: DeviceGroupMapDeviceCreateManyDeviceEntryInput | DeviceGroupMapDeviceCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapArchitectureCreateWithoutDeviceEntryInput = {
    DeviceLookupArchitecture: DeviceLookupArchitectureCreateNestedOneWithoutDeviceMapArchitectureInput
  }

  export type DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput = {
    architecture_id: number
  }

  export type DeviceMapArchitectureCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    create: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapArchitectureCreateManyDeviceEntryInputEnvelope = {
    data: DeviceMapArchitectureCreateManyDeviceEntryInput | DeviceMapArchitectureCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapIdentifierCreateWithoutDeviceEntryInput = {
    identifier: string
  }

  export type DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput = {
    identifier: string
  }

  export type DeviceMapIdentifierCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceMapIdentifierWhereUniqueInput
    create: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapIdentifierCreateManyDeviceEntryInputEnvelope = {
    data: DeviceMapIdentifierCreateManyDeviceEntryInput | DeviceMapIdentifierCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapModelCreateWithoutDeviceEntryInput = {
    model: string
  }

  export type DeviceMapModelUncheckedCreateWithoutDeviceEntryInput = {
    model: string
  }

  export type DeviceMapModelCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceMapModelWhereUniqueInput
    create: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapModelCreateManyDeviceEntryInputEnvelope = {
    data: DeviceMapModelCreateManyDeviceEntryInput | DeviceMapModelCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapReleaseCreateWithoutDeviceEntryInput = {
    datetime?: Date | string | null
    depth?: number | null
  }

  export type DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput = {
    id?: number
    datetime?: Date | string | null
    depth?: number | null
  }

  export type DeviceMapReleaseCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceMapReleaseWhereUniqueInput
    create: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapReleaseCreateManyDeviceEntryInputEnvelope = {
    data: DeviceMapReleaseCreateManyDeviceEntryInput | DeviceMapReleaseCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapSocCreateWithoutDeviceEntryInput = {
    DeviceLookupSoc: DeviceLookupSocCreateNestedOneWithoutDeviceMapSocInput
  }

  export type DeviceMapSocUncheckedCreateWithoutDeviceEntryInput = {
    soc_id: number
  }

  export type DeviceMapSocCreateOrConnectWithoutDeviceEntryInput = {
    where: DeviceMapSocWhereUniqueInput
    create: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapSocCreateManyDeviceEntryInputEnvelope = {
    data: DeviceMapSocCreateManyDeviceEntryInput | DeviceMapSocCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type MapDeviceOsCreateWithoutDeviceEntryInput = {
    OsEntry: OsEntryCreateNestedOneWithoutMapDeviceOsInput
  }

  export type MapDeviceOsUncheckedCreateWithoutDeviceEntryInput = {
    os_id: number
  }

  export type MapDeviceOsCreateOrConnectWithoutDeviceEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    create: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput>
  }

  export type MapDeviceOsCreateManyDeviceEntryInputEnvelope = {
    data: MapDeviceOsCreateManyDeviceEntryInput | MapDeviceOsCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryPreinstalledCreateWithoutDeviceEntryInput = {
    OsEntry: OsEntryCreateNestedOneWithoutOsEntryPreinstalledInput
  }

  export type OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput = {
    os_id: number
  }

  export type OsEntryPreinstalledCreateOrConnectWithoutDeviceEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    create: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput>
  }

  export type OsEntryPreinstalledCreateManyDeviceEntryInputEnvelope = {
    data: OsEntryPreinstalledCreateManyDeviceEntryInput | OsEntryPreinstalledCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type SourceMapDeviceCreateWithoutDeviceEntryInput = {
    SourceEntry: SourceEntryCreateNestedOneWithoutSourceMapDeviceInput
  }

  export type SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput = {
    source_id: number
  }

  export type SourceMapDeviceCreateOrConnectWithoutDeviceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    create: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput>
  }

  export type SourceMapDeviceCreateManyDeviceEntryInputEnvelope = {
    data: SourceMapDeviceCreateManyDeviceEntryInput | SourceMapDeviceCreateManyDeviceEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceLookupCategoryUpsertWithoutDeviceEntryInput = {
    update: XOR<DeviceLookupCategoryUpdateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceLookupCategoryCreateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedCreateWithoutDeviceEntryInput>
    where?: DeviceLookupCategoryWhereInput
  }

  export type DeviceLookupCategoryUpdateToOneWithWhereWithoutDeviceEntryInput = {
    where?: DeviceLookupCategoryWhereInput
    data: XOR<DeviceLookupCategoryUpdateWithoutDeviceEntryInput, DeviceLookupCategoryUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceLookupCategoryUpdateWithoutDeviceEntryInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupCategoryUncheckedUpdateWithoutDeviceEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupImageUpsertWithoutDeviceEntryInput = {
    update: XOR<DeviceLookupImageUpdateWithoutDeviceEntryInput, DeviceLookupImageUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceLookupImageCreateWithoutDeviceEntryInput, DeviceLookupImageUncheckedCreateWithoutDeviceEntryInput>
    where?: DeviceLookupImageWhereInput
  }

  export type DeviceLookupImageUpdateToOneWithWhereWithoutDeviceEntryInput = {
    where?: DeviceLookupImageWhereInput
    data: XOR<DeviceLookupImageUpdateWithoutDeviceEntryInput, DeviceLookupImageUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceLookupImageUpdateWithoutDeviceEntryInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceImageColors?: DeviceImageColorsUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type DeviceLookupImageUncheckedUpdateWithoutDeviceEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceImageColors?: DeviceImageColorsUncheckedUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    update: XOR<DeviceGroupMapDeviceUpdateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceGroupMapDeviceCreateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    data: XOR<DeviceGroupMapDeviceUpdateWithoutDeviceEntryInput, DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceGroupMapDeviceScalarWhereInput
    data: XOR<DeviceGroupMapDeviceUpdateManyMutationInput, DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceGroupMapDeviceScalarWhereInput = {
    AND?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
    OR?: DeviceGroupMapDeviceScalarWhereInput[]
    NOT?: DeviceGroupMapDeviceScalarWhereInput | DeviceGroupMapDeviceScalarWhereInput[]
    group_id?: IntFilter<"DeviceGroupMapDevice"> | number
    device_id?: IntFilter<"DeviceGroupMapDevice"> | number
  }

  export type DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    update: XOR<DeviceMapArchitectureUpdateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceMapArchitectureCreateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    data: XOR<DeviceMapArchitectureUpdateWithoutDeviceEntryInput, DeviceMapArchitectureUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceMapArchitectureScalarWhereInput
    data: XOR<DeviceMapArchitectureUpdateManyMutationInput, DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceMapArchitectureScalarWhereInput = {
    AND?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
    OR?: DeviceMapArchitectureScalarWhereInput[]
    NOT?: DeviceMapArchitectureScalarWhereInput | DeviceMapArchitectureScalarWhereInput[]
    device_id?: IntFilter<"DeviceMapArchitecture"> | number
    architecture_id?: IntFilter<"DeviceMapArchitecture"> | number
  }

  export type DeviceMapIdentifierUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapIdentifierWhereUniqueInput
    update: XOR<DeviceMapIdentifierUpdateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceMapIdentifierCreateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapIdentifierUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapIdentifierWhereUniqueInput
    data: XOR<DeviceMapIdentifierUpdateWithoutDeviceEntryInput, DeviceMapIdentifierUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceMapIdentifierUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceMapIdentifierScalarWhereInput
    data: XOR<DeviceMapIdentifierUpdateManyMutationInput, DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceMapIdentifierScalarWhereInput = {
    AND?: DeviceMapIdentifierScalarWhereInput | DeviceMapIdentifierScalarWhereInput[]
    OR?: DeviceMapIdentifierScalarWhereInput[]
    NOT?: DeviceMapIdentifierScalarWhereInput | DeviceMapIdentifierScalarWhereInput[]
    device_id?: IntFilter<"DeviceMapIdentifier"> | number
    identifier?: StringFilter<"DeviceMapIdentifier"> | string
  }

  export type DeviceMapModelUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapModelWhereUniqueInput
    update: XOR<DeviceMapModelUpdateWithoutDeviceEntryInput, DeviceMapModelUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceMapModelCreateWithoutDeviceEntryInput, DeviceMapModelUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapModelUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapModelWhereUniqueInput
    data: XOR<DeviceMapModelUpdateWithoutDeviceEntryInput, DeviceMapModelUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceMapModelUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceMapModelScalarWhereInput
    data: XOR<DeviceMapModelUpdateManyMutationInput, DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceMapModelScalarWhereInput = {
    AND?: DeviceMapModelScalarWhereInput | DeviceMapModelScalarWhereInput[]
    OR?: DeviceMapModelScalarWhereInput[]
    NOT?: DeviceMapModelScalarWhereInput | DeviceMapModelScalarWhereInput[]
    device_id?: IntFilter<"DeviceMapModel"> | number
    model?: StringFilter<"DeviceMapModel"> | string
  }

  export type DeviceMapReleaseUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapReleaseWhereUniqueInput
    update: XOR<DeviceMapReleaseUpdateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceMapReleaseCreateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapReleaseUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapReleaseWhereUniqueInput
    data: XOR<DeviceMapReleaseUpdateWithoutDeviceEntryInput, DeviceMapReleaseUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceMapReleaseUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceMapReleaseScalarWhereInput
    data: XOR<DeviceMapReleaseUpdateManyMutationInput, DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceMapReleaseScalarWhereInput = {
    AND?: DeviceMapReleaseScalarWhereInput | DeviceMapReleaseScalarWhereInput[]
    OR?: DeviceMapReleaseScalarWhereInput[]
    NOT?: DeviceMapReleaseScalarWhereInput | DeviceMapReleaseScalarWhereInput[]
    id?: IntFilter<"DeviceMapRelease"> | number
    device_id?: IntNullableFilter<"DeviceMapRelease"> | number | null
    datetime?: DateTimeNullableFilter<"DeviceMapRelease"> | Date | string | null
    depth?: IntNullableFilter<"DeviceMapRelease"> | number | null
  }

  export type DeviceMapSocUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapSocWhereUniqueInput
    update: XOR<DeviceMapSocUpdateWithoutDeviceEntryInput, DeviceMapSocUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<DeviceMapSocCreateWithoutDeviceEntryInput, DeviceMapSocUncheckedCreateWithoutDeviceEntryInput>
  }

  export type DeviceMapSocUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: DeviceMapSocWhereUniqueInput
    data: XOR<DeviceMapSocUpdateWithoutDeviceEntryInput, DeviceMapSocUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type DeviceMapSocUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: DeviceMapSocScalarWhereInput
    data: XOR<DeviceMapSocUpdateManyMutationInput, DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type DeviceMapSocScalarWhereInput = {
    AND?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
    OR?: DeviceMapSocScalarWhereInput[]
    NOT?: DeviceMapSocScalarWhereInput | DeviceMapSocScalarWhereInput[]
    device_id?: IntFilter<"DeviceMapSoc"> | number
    soc_id?: IntFilter<"DeviceMapSoc"> | number
  }

  export type MapDeviceOsUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    update: XOR<MapDeviceOsUpdateWithoutDeviceEntryInput, MapDeviceOsUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<MapDeviceOsCreateWithoutDeviceEntryInput, MapDeviceOsUncheckedCreateWithoutDeviceEntryInput>
  }

  export type MapDeviceOsUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    data: XOR<MapDeviceOsUpdateWithoutDeviceEntryInput, MapDeviceOsUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type MapDeviceOsUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: MapDeviceOsScalarWhereInput
    data: XOR<MapDeviceOsUpdateManyMutationInput, MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type MapDeviceOsScalarWhereInput = {
    AND?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
    OR?: MapDeviceOsScalarWhereInput[]
    NOT?: MapDeviceOsScalarWhereInput | MapDeviceOsScalarWhereInput[]
    device_id?: IntFilter<"MapDeviceOs"> | number
    os_id?: IntFilter<"MapDeviceOs"> | number
  }

  export type OsEntryPreinstalledUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    update: XOR<OsEntryPreinstalledUpdateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<OsEntryPreinstalledCreateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedCreateWithoutDeviceEntryInput>
  }

  export type OsEntryPreinstalledUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    data: XOR<OsEntryPreinstalledUpdateWithoutDeviceEntryInput, OsEntryPreinstalledUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type OsEntryPreinstalledUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: OsEntryPreinstalledScalarWhereInput
    data: XOR<OsEntryPreinstalledUpdateManyMutationInput, OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type OsEntryPreinstalledScalarWhereInput = {
    AND?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
    OR?: OsEntryPreinstalledScalarWhereInput[]
    NOT?: OsEntryPreinstalledScalarWhereInput | OsEntryPreinstalledScalarWhereInput[]
    os_id?: IntFilter<"OsEntryPreinstalled"> | number
    device_id?: IntFilter<"OsEntryPreinstalled"> | number
  }

  export type SourceMapDeviceUpsertWithWhereUniqueWithoutDeviceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    update: XOR<SourceMapDeviceUpdateWithoutDeviceEntryInput, SourceMapDeviceUncheckedUpdateWithoutDeviceEntryInput>
    create: XOR<SourceMapDeviceCreateWithoutDeviceEntryInput, SourceMapDeviceUncheckedCreateWithoutDeviceEntryInput>
  }

  export type SourceMapDeviceUpdateWithWhereUniqueWithoutDeviceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    data: XOR<SourceMapDeviceUpdateWithoutDeviceEntryInput, SourceMapDeviceUncheckedUpdateWithoutDeviceEntryInput>
  }

  export type SourceMapDeviceUpdateManyWithWhereWithoutDeviceEntryInput = {
    where: SourceMapDeviceScalarWhereInput
    data: XOR<SourceMapDeviceUpdateManyMutationInput, SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryInput>
  }

  export type SourceMapDeviceScalarWhereInput = {
    AND?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
    OR?: SourceMapDeviceScalarWhereInput[]
    NOT?: SourceMapDeviceScalarWhereInput | SourceMapDeviceScalarWhereInput[]
    source_id?: IntFilter<"SourceMapDevice"> | number
    device_id?: IntFilter<"SourceMapDevice"> | number
  }

  export type DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceGroupMapDeviceInput
  }

  export type DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput = {
    device_id: number
  }

  export type DeviceGroupMapDeviceCreateOrConnectWithoutDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    create: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceCreateManyDeviceGroupEntryInputEnvelope = {
    data: DeviceGroupMapDeviceCreateManyDeviceGroupEntryInput | DeviceGroupMapDeviceCreateManyDeviceGroupEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    child_group_id: number
  }

  export type DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    create: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInputEnvelope = {
    data: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry: DeviceGroupEntryCreateNestedOneWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    parent_group_id: number
  }

  export type DeviceGroupMapDeviceGroupCreateOrConnectWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    create: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInputEnvelope = {
    data: DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput | DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceGroupMapDeviceUpsertWithWhereUniqueWithoutDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    update: XOR<DeviceGroupMapDeviceUpdateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceGroupEntryInput>
    create: XOR<DeviceGroupMapDeviceCreateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedCreateWithoutDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceUpdateWithWhereUniqueWithoutDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceWhereUniqueInput
    data: XOR<DeviceGroupMapDeviceUpdateWithoutDeviceGroupEntryInput, DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceUpdateManyWithWhereWithoutDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceScalarWhereInput
    data: XOR<DeviceGroupMapDeviceUpdateManyMutationInput, DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    update: XOR<DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
    create: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    data: XOR<DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupScalarWhereInput
    data: XOR<DeviceGroupMapDeviceGroupUpdateManyMutationInput, DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupScalarWhereInput = {
    AND?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
    OR?: DeviceGroupMapDeviceGroupScalarWhereInput[]
    NOT?: DeviceGroupMapDeviceGroupScalarWhereInput | DeviceGroupMapDeviceGroupScalarWhereInput[]
    parent_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
    child_group_id?: IntFilter<"DeviceGroupMapDeviceGroup"> | number
  }

  export type DeviceGroupMapDeviceGroupUpsertWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    update: XOR<DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
    create: XOR<DeviceGroupMapDeviceGroupCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedCreateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupUpdateWithWhereUniqueWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupWhereUniqueInput
    data: XOR<DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupMapDeviceGroupUpdateManyWithWhereWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupMapDeviceGroupScalarWhereInput
    data: XOR<DeviceGroupMapDeviceGroupUpdateManyMutationInput, DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceInput = {
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput = {
    id?: number
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput = {
    where: DeviceGroupEntryWhereUniqueInput
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceEntryCreateWithoutDeviceGroupMapDeviceInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceGroupMapDeviceInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceInput = {
    update: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    where?: DeviceGroupEntryWhereInput
  }

  export type DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceInput = {
    where?: DeviceGroupEntryWhereInput
    data: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceEntryUpsertWithoutDeviceGroupMapDeviceInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
    create: XOR<DeviceEntryCreateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedCreateWithoutDeviceGroupMapDeviceInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceGroupMapDeviceInput, DeviceEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput>
  }

  export type DeviceEntryUpdateWithoutDeviceGroupMapDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceGroupMapDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    id?: number
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupEntryWhereUniqueInput
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    id?: number
    name: string
    category_id?: number | null
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceGroupEntryInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedCreateNestedManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput
  }

  export type DeviceGroupEntryCreateOrConnectWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where: DeviceGroupEntryWhereUniqueInput
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    update: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
    where?: DeviceGroupEntryWhereInput
  }

  export type DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    where?: DeviceGroupEntryWhereInput
    data: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryUpsertWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    update: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
    create: XOR<DeviceGroupEntryCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedCreateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
    where?: DeviceGroupEntryWhereInput
  }

  export type DeviceGroupEntryUpdateToOneWithWhereWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    where?: DeviceGroupEntryWhereInput
    data: XOR<DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput, DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput>
  }

  export type DeviceGroupEntryUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupEntryUncheckedUpdateWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryNestedInput
    DeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceLookupImageCreateWithoutDeviceImageColorsInput = {
    name: string
    DeviceEntry?: DeviceEntryCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageUncheckedCreateWithoutDeviceImageColorsInput = {
    id?: number
    name: string
    DeviceEntry?: DeviceEntryUncheckedCreateNestedManyWithoutDeviceLookupImageInput
  }

  export type DeviceLookupImageCreateOrConnectWithoutDeviceImageColorsInput = {
    where: DeviceLookupImageWhereUniqueInput
    create: XOR<DeviceLookupImageCreateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedCreateWithoutDeviceImageColorsInput>
  }

  export type ColorLookupCreateWithoutDeviceImageColorsInput = {
    name: string
  }

  export type ColorLookupUncheckedCreateWithoutDeviceImageColorsInput = {
    id?: number
    name: string
  }

  export type ColorLookupCreateOrConnectWithoutDeviceImageColorsInput = {
    where: ColorLookupWhereUniqueInput
    create: XOR<ColorLookupCreateWithoutDeviceImageColorsInput, ColorLookupUncheckedCreateWithoutDeviceImageColorsInput>
  }

  export type DeviceLookupImageUpsertWithoutDeviceImageColorsInput = {
    update: XOR<DeviceLookupImageUpdateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedUpdateWithoutDeviceImageColorsInput>
    create: XOR<DeviceLookupImageCreateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedCreateWithoutDeviceImageColorsInput>
    where?: DeviceLookupImageWhereInput
  }

  export type DeviceLookupImageUpdateToOneWithWhereWithoutDeviceImageColorsInput = {
    where?: DeviceLookupImageWhereInput
    data: XOR<DeviceLookupImageUpdateWithoutDeviceImageColorsInput, DeviceLookupImageUncheckedUpdateWithoutDeviceImageColorsInput>
  }

  export type DeviceLookupImageUpdateWithoutDeviceImageColorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type DeviceLookupImageUncheckedUpdateWithoutDeviceImageColorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DeviceEntry?: DeviceEntryUncheckedUpdateManyWithoutDeviceLookupImageNestedInput
  }

  export type ColorLookupUpsertWithoutDeviceImageColorsInput = {
    update: XOR<ColorLookupUpdateWithoutDeviceImageColorsInput, ColorLookupUncheckedUpdateWithoutDeviceImageColorsInput>
    create: XOR<ColorLookupCreateWithoutDeviceImageColorsInput, ColorLookupUncheckedCreateWithoutDeviceImageColorsInput>
    where?: ColorLookupWhereInput
  }

  export type ColorLookupUpdateToOneWithWhereWithoutDeviceImageColorsInput = {
    where?: ColorLookupWhereInput
    data: XOR<ColorLookupUpdateWithoutDeviceImageColorsInput, ColorLookupUncheckedUpdateWithoutDeviceImageColorsInput>
  }

  export type ColorLookupUpdateWithoutDeviceImageColorsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ColorLookupUncheckedUpdateWithoutDeviceImageColorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapArchitectureInput
  }

  export type DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput = {
    device_id: number
  }

  export type DeviceMapArchitectureCreateOrConnectWithoutDeviceLookupArchitectureInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    create: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput>
  }

  export type DeviceMapArchitectureCreateManyDeviceLookupArchitectureInputEnvelope = {
    data: DeviceMapArchitectureCreateManyDeviceLookupArchitectureInput | DeviceMapArchitectureCreateManyDeviceLookupArchitectureInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapArchitectureUpsertWithWhereUniqueWithoutDeviceLookupArchitectureInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    update: XOR<DeviceMapArchitectureUpdateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedUpdateWithoutDeviceLookupArchitectureInput>
    create: XOR<DeviceMapArchitectureCreateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedCreateWithoutDeviceLookupArchitectureInput>
  }

  export type DeviceMapArchitectureUpdateWithWhereUniqueWithoutDeviceLookupArchitectureInput = {
    where: DeviceMapArchitectureWhereUniqueInput
    data: XOR<DeviceMapArchitectureUpdateWithoutDeviceLookupArchitectureInput, DeviceMapArchitectureUncheckedUpdateWithoutDeviceLookupArchitectureInput>
  }

  export type DeviceMapArchitectureUpdateManyWithWhereWithoutDeviceLookupArchitectureInput = {
    where: DeviceMapArchitectureScalarWhereInput
    data: XOR<DeviceMapArchitectureUpdateManyMutationInput, DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceLookupArchitectureInput>
  }

  export type DeviceEntryCreateWithoutDeviceLookupCategoryInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput = {
    id?: number
    name: string
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceLookupCategoryInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput>
  }

  export type DeviceEntryCreateManyDeviceLookupCategoryInputEnvelope = {
    data: DeviceEntryCreateManyDeviceLookupCategoryInput | DeviceEntryCreateManyDeviceLookupCategoryInput[]
    skipDuplicates?: boolean
  }

  export type DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupCategoryInput = {
    where: DeviceEntryWhereUniqueInput
    update: XOR<DeviceEntryUpdateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedUpdateWithoutDeviceLookupCategoryInput>
    create: XOR<DeviceEntryCreateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedCreateWithoutDeviceLookupCategoryInput>
  }

  export type DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupCategoryInput = {
    where: DeviceEntryWhereUniqueInput
    data: XOR<DeviceEntryUpdateWithoutDeviceLookupCategoryInput, DeviceEntryUncheckedUpdateWithoutDeviceLookupCategoryInput>
  }

  export type DeviceEntryUpdateManyWithWhereWithoutDeviceLookupCategoryInput = {
    where: DeviceEntryScalarWhereInput
    data: XOR<DeviceEntryUpdateManyMutationInput, DeviceEntryUncheckedUpdateManyWithoutDeviceLookupCategoryInput>
  }

  export type DeviceEntryScalarWhereInput = {
    AND?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
    OR?: DeviceEntryScalarWhereInput[]
    NOT?: DeviceEntryScalarWhereInput | DeviceEntryScalarWhereInput[]
    id?: IntFilter<"DeviceEntry"> | number
    name?: StringFilter<"DeviceEntry"> | string
    category_id?: IntFilter<"DeviceEntry"> | number
    image_id?: IntNullableFilter<"DeviceEntry"> | number | null
    is_internal?: BoolNullableFilter<"DeviceEntry"> | boolean | null
    legacy_unique_key?: StringNullableFilter<"DeviceEntry"> | string | null
  }

  export type DeviceEntryCreateWithoutDeviceLookupImageInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput = {
    id?: number
    name: string
    category_id: number
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceLookupImageInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput>
  }

  export type DeviceEntryCreateManyDeviceLookupImageInputEnvelope = {
    data: DeviceEntryCreateManyDeviceLookupImageInput | DeviceEntryCreateManyDeviceLookupImageInput[]
    skipDuplicates?: boolean
  }

  export type DeviceImageColorsCreateWithoutDeviceLookupImageInput = {
    dark_mode?: boolean | null
    ColorLookup: ColorLookupCreateNestedOneWithoutDeviceImageColorsInput
  }

  export type DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput = {
    color_id: number
    dark_mode?: boolean | null
  }

  export type DeviceImageColorsCreateOrConnectWithoutDeviceLookupImageInput = {
    where: DeviceImageColorsWhereUniqueInput
    create: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput>
  }

  export type DeviceImageColorsCreateManyDeviceLookupImageInputEnvelope = {
    data: DeviceImageColorsCreateManyDeviceLookupImageInput | DeviceImageColorsCreateManyDeviceLookupImageInput[]
    skipDuplicates?: boolean
  }

  export type DeviceEntryUpsertWithWhereUniqueWithoutDeviceLookupImageInput = {
    where: DeviceEntryWhereUniqueInput
    update: XOR<DeviceEntryUpdateWithoutDeviceLookupImageInput, DeviceEntryUncheckedUpdateWithoutDeviceLookupImageInput>
    create: XOR<DeviceEntryCreateWithoutDeviceLookupImageInput, DeviceEntryUncheckedCreateWithoutDeviceLookupImageInput>
  }

  export type DeviceEntryUpdateWithWhereUniqueWithoutDeviceLookupImageInput = {
    where: DeviceEntryWhereUniqueInput
    data: XOR<DeviceEntryUpdateWithoutDeviceLookupImageInput, DeviceEntryUncheckedUpdateWithoutDeviceLookupImageInput>
  }

  export type DeviceEntryUpdateManyWithWhereWithoutDeviceLookupImageInput = {
    where: DeviceEntryScalarWhereInput
    data: XOR<DeviceEntryUpdateManyMutationInput, DeviceEntryUncheckedUpdateManyWithoutDeviceLookupImageInput>
  }

  export type DeviceImageColorsUpsertWithWhereUniqueWithoutDeviceLookupImageInput = {
    where: DeviceImageColorsWhereUniqueInput
    update: XOR<DeviceImageColorsUpdateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedUpdateWithoutDeviceLookupImageInput>
    create: XOR<DeviceImageColorsCreateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedCreateWithoutDeviceLookupImageInput>
  }

  export type DeviceImageColorsUpdateWithWhereUniqueWithoutDeviceLookupImageInput = {
    where: DeviceImageColorsWhereUniqueInput
    data: XOR<DeviceImageColorsUpdateWithoutDeviceLookupImageInput, DeviceImageColorsUncheckedUpdateWithoutDeviceLookupImageInput>
  }

  export type DeviceImageColorsUpdateManyWithWhereWithoutDeviceLookupImageInput = {
    where: DeviceImageColorsScalarWhereInput
    data: XOR<DeviceImageColorsUpdateManyMutationInput, DeviceImageColorsUncheckedUpdateManyWithoutDeviceLookupImageInput>
  }

  export type DeviceMapSocCreateWithoutDeviceLookupSocInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutDeviceMapSocInput
  }

  export type DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput = {
    device_id: number
  }

  export type DeviceMapSocCreateOrConnectWithoutDeviceLookupSocInput = {
    where: DeviceMapSocWhereUniqueInput
    create: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput>
  }

  export type DeviceMapSocCreateManyDeviceLookupSocInputEnvelope = {
    data: DeviceMapSocCreateManyDeviceLookupSocInput | DeviceMapSocCreateManyDeviceLookupSocInput[]
    skipDuplicates?: boolean
  }

  export type DeviceMapSocUpsertWithWhereUniqueWithoutDeviceLookupSocInput = {
    where: DeviceMapSocWhereUniqueInput
    update: XOR<DeviceMapSocUpdateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedUpdateWithoutDeviceLookupSocInput>
    create: XOR<DeviceMapSocCreateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedCreateWithoutDeviceLookupSocInput>
  }

  export type DeviceMapSocUpdateWithWhereUniqueWithoutDeviceLookupSocInput = {
    where: DeviceMapSocWhereUniqueInput
    data: XOR<DeviceMapSocUpdateWithoutDeviceLookupSocInput, DeviceMapSocUncheckedUpdateWithoutDeviceLookupSocInput>
  }

  export type DeviceMapSocUpdateManyWithWhereWithoutDeviceLookupSocInput = {
    where: DeviceMapSocScalarWhereInput
    data: XOR<DeviceMapSocUpdateManyMutationInput, DeviceMapSocUncheckedUpdateManyWithoutDeviceLookupSocInput>
  }

  export type DeviceEntryCreateWithoutDeviceMapArchitectureInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceMapArchitectureInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceMapArchitectureInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedCreateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceLookupArchitectureCreateWithoutDeviceMapArchitectureInput = {
    name: string
  }

  export type DeviceLookupArchitectureUncheckedCreateWithoutDeviceMapArchitectureInput = {
    id?: number
    name: string
  }

  export type DeviceLookupArchitectureCreateOrConnectWithoutDeviceMapArchitectureInput = {
    where: DeviceLookupArchitectureWhereUniqueInput
    create: XOR<DeviceLookupArchitectureCreateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedCreateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceEntryUpsertWithoutDeviceMapArchitectureInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedUpdateWithoutDeviceMapArchitectureInput>
    create: XOR<DeviceEntryCreateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedCreateWithoutDeviceMapArchitectureInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceMapArchitectureInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceMapArchitectureInput, DeviceEntryUncheckedUpdateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceEntryUpdateWithoutDeviceMapArchitectureInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceMapArchitectureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceLookupArchitectureUpsertWithoutDeviceMapArchitectureInput = {
    update: XOR<DeviceLookupArchitectureUpdateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedUpdateWithoutDeviceMapArchitectureInput>
    create: XOR<DeviceLookupArchitectureCreateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedCreateWithoutDeviceMapArchitectureInput>
    where?: DeviceLookupArchitectureWhereInput
  }

  export type DeviceLookupArchitectureUpdateToOneWithWhereWithoutDeviceMapArchitectureInput = {
    where?: DeviceLookupArchitectureWhereInput
    data: XOR<DeviceLookupArchitectureUpdateWithoutDeviceMapArchitectureInput, DeviceLookupArchitectureUncheckedUpdateWithoutDeviceMapArchitectureInput>
  }

  export type DeviceLookupArchitectureUpdateWithoutDeviceMapArchitectureInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupArchitectureUncheckedUpdateWithoutDeviceMapArchitectureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceEntryCreateWithoutDeviceMapIdentifierInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceMapIdentifierInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceMapIdentifierInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedCreateWithoutDeviceMapIdentifierInput>
  }

  export type DeviceEntryUpsertWithoutDeviceMapIdentifierInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedUpdateWithoutDeviceMapIdentifierInput>
    create: XOR<DeviceEntryCreateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedCreateWithoutDeviceMapIdentifierInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceMapIdentifierInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceMapIdentifierInput, DeviceEntryUncheckedUpdateWithoutDeviceMapIdentifierInput>
  }

  export type DeviceEntryUpdateWithoutDeviceMapIdentifierInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceMapIdentifierInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryCreateWithoutDeviceMapModelInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceMapModelInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceMapModelInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceMapModelInput, DeviceEntryUncheckedCreateWithoutDeviceMapModelInput>
  }

  export type DeviceEntryUpsertWithoutDeviceMapModelInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceMapModelInput, DeviceEntryUncheckedUpdateWithoutDeviceMapModelInput>
    create: XOR<DeviceEntryCreateWithoutDeviceMapModelInput, DeviceEntryUncheckedCreateWithoutDeviceMapModelInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceMapModelInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceMapModelInput, DeviceEntryUncheckedUpdateWithoutDeviceMapModelInput>
  }

  export type DeviceEntryUpdateWithoutDeviceMapModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceMapModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryCreateWithoutDeviceMapReleaseInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceMapReleaseInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceMapReleaseInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedCreateWithoutDeviceMapReleaseInput>
  }

  export type DeviceEntryUpsertWithoutDeviceMapReleaseInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedUpdateWithoutDeviceMapReleaseInput>
    create: XOR<DeviceEntryCreateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedCreateWithoutDeviceMapReleaseInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceMapReleaseInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceMapReleaseInput, DeviceEntryUncheckedUpdateWithoutDeviceMapReleaseInput>
  }

  export type DeviceEntryUpdateWithoutDeviceMapReleaseInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceMapReleaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryCreateWithoutDeviceMapSocInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutDeviceMapSocInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutDeviceMapSocInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutDeviceMapSocInput, DeviceEntryUncheckedCreateWithoutDeviceMapSocInput>
  }

  export type DeviceLookupSocCreateWithoutDeviceMapSocInput = {
    name: string
  }

  export type DeviceLookupSocUncheckedCreateWithoutDeviceMapSocInput = {
    id?: number
    name: string
  }

  export type DeviceLookupSocCreateOrConnectWithoutDeviceMapSocInput = {
    where: DeviceLookupSocWhereUniqueInput
    create: XOR<DeviceLookupSocCreateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedCreateWithoutDeviceMapSocInput>
  }

  export type DeviceEntryUpsertWithoutDeviceMapSocInput = {
    update: XOR<DeviceEntryUpdateWithoutDeviceMapSocInput, DeviceEntryUncheckedUpdateWithoutDeviceMapSocInput>
    create: XOR<DeviceEntryCreateWithoutDeviceMapSocInput, DeviceEntryUncheckedCreateWithoutDeviceMapSocInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutDeviceMapSocInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutDeviceMapSocInput, DeviceEntryUncheckedUpdateWithoutDeviceMapSocInput>
  }

  export type DeviceEntryUpdateWithoutDeviceMapSocInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceMapSocInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceLookupSocUpsertWithoutDeviceMapSocInput = {
    update: XOR<DeviceLookupSocUpdateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedUpdateWithoutDeviceMapSocInput>
    create: XOR<DeviceLookupSocCreateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedCreateWithoutDeviceMapSocInput>
    where?: DeviceLookupSocWhereInput
  }

  export type DeviceLookupSocUpdateToOneWithWhereWithoutDeviceMapSocInput = {
    where?: DeviceLookupSocWhereInput
    data: XOR<DeviceLookupSocUpdateWithoutDeviceMapSocInput, DeviceLookupSocUncheckedUpdateWithoutDeviceMapSocInput>
  }

  export type DeviceLookupSocUpdateWithoutDeviceMapSocInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceLookupSocUncheckedUpdateWithoutDeviceMapSocInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceEntryCreateWithoutMapDeviceOsInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutMapDeviceOsInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutMapDeviceOsInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutMapDeviceOsInput, DeviceEntryUncheckedCreateWithoutMapDeviceOsInput>
  }

  export type OsEntryCreateWithoutMapDeviceOsInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutMapDeviceOsInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutMapDeviceOsInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutMapDeviceOsInput, OsEntryUncheckedCreateWithoutMapDeviceOsInput>
  }

  export type DeviceEntryUpsertWithoutMapDeviceOsInput = {
    update: XOR<DeviceEntryUpdateWithoutMapDeviceOsInput, DeviceEntryUncheckedUpdateWithoutMapDeviceOsInput>
    create: XOR<DeviceEntryCreateWithoutMapDeviceOsInput, DeviceEntryUncheckedCreateWithoutMapDeviceOsInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutMapDeviceOsInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutMapDeviceOsInput, DeviceEntryUncheckedUpdateWithoutMapDeviceOsInput>
  }

  export type DeviceEntryUpdateWithoutMapDeviceOsInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutMapDeviceOsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type OsEntryUpsertWithoutMapDeviceOsInput = {
    update: XOR<OsEntryUpdateWithoutMapDeviceOsInput, OsEntryUncheckedUpdateWithoutMapDeviceOsInput>
    create: XOR<OsEntryCreateWithoutMapDeviceOsInput, OsEntryUncheckedCreateWithoutMapDeviceOsInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutMapDeviceOsInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutMapDeviceOsInput, OsEntryUncheckedUpdateWithoutMapDeviceOsInput>
  }

  export type OsEntryUpdateWithoutMapDeviceOsInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutMapDeviceOsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type MapDeviceOsCreateWithoutOsEntryInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutMapDeviceOsInput
  }

  export type MapDeviceOsUncheckedCreateWithoutOsEntryInput = {
    device_id: number
  }

  export type MapDeviceOsCreateOrConnectWithoutOsEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    create: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput>
  }

  export type MapDeviceOsCreateManyOsEntryInputEnvelope = {
    data: MapDeviceOsCreateManyOsEntryInput | MapDeviceOsCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsLookupNameCreateWithoutOsEntryInput = {
    name: string
    priority?: number | null
  }

  export type OsLookupNameUncheckedCreateWithoutOsEntryInput = {
    id?: number
    name: string
    priority?: number | null
  }

  export type OsLookupNameCreateOrConnectWithoutOsEntryInput = {
    where: OsLookupNameWhereUniqueInput
    create: XOR<OsLookupNameCreateWithoutOsEntryInput, OsLookupNameUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainCreateWithoutOsEntryInput = {
    build_train: string
  }

  export type OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput = {
    build_train: string
  }

  export type OsEntryBuildTrainCreateOrConnectWithoutOsEntryInput = {
    where: OsEntryBuildTrainWhereUniqueInput
    create: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainCreateManyOsEntryInputEnvelope = {
    data: OsEntryBuildTrainCreateManyOsEntryInput | OsEntryBuildTrainCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryIpdCreateWithoutOsEntryInput = {
    ipd_type: string
    url?: string | null
    active?: boolean | null
  }

  export type OsEntryIpdUncheckedCreateWithoutOsEntryInput = {
    ipd_type: string
    url?: string | null
    active?: boolean | null
  }

  export type OsEntryIpdCreateOrConnectWithoutOsEntryInput = {
    where: OsEntryIpdWhereUniqueInput
    create: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryIpdCreateManyOsEntryInputEnvelope = {
    data: OsEntryIpdCreateManyOsEntryInput | OsEntryIpdCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryOsStringMapCreateWithoutOsEntryInput = {
    os_string: string
  }

  export type OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput = {
    os_string: string
  }

  export type OsEntryOsStringMapCreateOrConnectWithoutOsEntryInput = {
    where: OsEntryOsStringMapWhereUniqueInput
    create: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryOsStringMapCreateManyOsEntryInputEnvelope = {
    data: OsEntryOsStringMapCreateManyOsEntryInput | OsEntryOsStringMapCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryPreinstalledCreateWithoutOsEntryInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutOsEntryPreinstalledInput
  }

  export type OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput = {
    device_id: number
  }

  export type OsEntryPreinstalledCreateOrConnectWithoutOsEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    create: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryPreinstalledCreateManyOsEntryInputEnvelope = {
    data: OsEntryPreinstalledCreateManyOsEntryInput | OsEntryPreinstalledCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryReleaseNoteCreateWithoutOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type OsEntryReleaseNoteCreateOrConnectWithoutOsEntryInput = {
    where: OsEntryReleaseNoteWhereUniqueInput
    create: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryReleaseNoteCreateManyOsEntryInputEnvelope = {
    data: OsEntryReleaseNoteCreateManyOsEntryInput | OsEntryReleaseNoteCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntrySafariVersionCreateWithoutOsEntryInput = {
    version: string
  }

  export type OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput = {
    version: string
  }

  export type OsEntrySafariVersionCreateOrConnectWithoutOsEntryInput = {
    where: OsEntrySafariVersionWhereUniqueInput
    create: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntrySafariVersionCreateManyOsEntryInputEnvelope = {
    data: OsEntrySafariVersionCreateManyOsEntryInput | OsEntrySafariVersionCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntrySecurityNoteCreateWithoutOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type OsEntrySecurityNoteCreateOrConnectWithoutOsEntryInput = {
    where: OsEntrySecurityNoteWhereUniqueInput
    create: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntrySecurityNoteCreateManyOsEntryInputEnvelope = {
    data: OsEntrySecurityNoteCreateManyOsEntryInput | OsEntrySecurityNoteCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type SourceEntryCreateWithoutOsEntryInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateWithoutOsEntryInput = {
    id?: number
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryCreateOrConnectWithoutOsEntryInput = {
    where: SourceEntryWhereUniqueInput
    create: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput>
  }

  export type SourceEntryCreateManyOsEntryInputEnvelope = {
    data: SourceEntryCreateManyOsEntryInput | SourceEntryCreateManyOsEntryInput[]
    skipDuplicates?: boolean
  }

  export type MapDeviceOsUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    update: XOR<MapDeviceOsUpdateWithoutOsEntryInput, MapDeviceOsUncheckedUpdateWithoutOsEntryInput>
    create: XOR<MapDeviceOsCreateWithoutOsEntryInput, MapDeviceOsUncheckedCreateWithoutOsEntryInput>
  }

  export type MapDeviceOsUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: MapDeviceOsWhereUniqueInput
    data: XOR<MapDeviceOsUpdateWithoutOsEntryInput, MapDeviceOsUncheckedUpdateWithoutOsEntryInput>
  }

  export type MapDeviceOsUpdateManyWithWhereWithoutOsEntryInput = {
    where: MapDeviceOsScalarWhereInput
    data: XOR<MapDeviceOsUpdateManyMutationInput, MapDeviceOsUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsLookupNameUpsertWithoutOsEntryInput = {
    update: XOR<OsLookupNameUpdateWithoutOsEntryInput, OsLookupNameUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsLookupNameCreateWithoutOsEntryInput, OsLookupNameUncheckedCreateWithoutOsEntryInput>
    where?: OsLookupNameWhereInput
  }

  export type OsLookupNameUpdateToOneWithWhereWithoutOsEntryInput = {
    where?: OsLookupNameWhereInput
    data: XOR<OsLookupNameUpdateWithoutOsEntryInput, OsLookupNameUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsLookupNameUpdateWithoutOsEntryInput = {
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OsLookupNameUncheckedUpdateWithoutOsEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OsEntryBuildTrainUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryBuildTrainWhereUniqueInput
    update: XOR<OsEntryBuildTrainUpdateWithoutOsEntryInput, OsEntryBuildTrainUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntryBuildTrainCreateWithoutOsEntryInput, OsEntryBuildTrainUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryBuildTrainWhereUniqueInput
    data: XOR<OsEntryBuildTrainUpdateWithoutOsEntryInput, OsEntryBuildTrainUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntryBuildTrainScalarWhereInput
    data: XOR<OsEntryBuildTrainUpdateManyMutationInput, OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntryBuildTrainScalarWhereInput = {
    AND?: OsEntryBuildTrainScalarWhereInput | OsEntryBuildTrainScalarWhereInput[]
    OR?: OsEntryBuildTrainScalarWhereInput[]
    NOT?: OsEntryBuildTrainScalarWhereInput | OsEntryBuildTrainScalarWhereInput[]
    os_id?: IntFilter<"OsEntryBuildTrain"> | number
    build_train?: StringFilter<"OsEntryBuildTrain"> | string
  }

  export type OsEntryIpdUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryIpdWhereUniqueInput
    update: XOR<OsEntryIpdUpdateWithoutOsEntryInput, OsEntryIpdUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntryIpdCreateWithoutOsEntryInput, OsEntryIpdUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryIpdUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryIpdWhereUniqueInput
    data: XOR<OsEntryIpdUpdateWithoutOsEntryInput, OsEntryIpdUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryIpdUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntryIpdScalarWhereInput
    data: XOR<OsEntryIpdUpdateManyMutationInput, OsEntryIpdUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntryIpdScalarWhereInput = {
    AND?: OsEntryIpdScalarWhereInput | OsEntryIpdScalarWhereInput[]
    OR?: OsEntryIpdScalarWhereInput[]
    NOT?: OsEntryIpdScalarWhereInput | OsEntryIpdScalarWhereInput[]
    os_id?: IntFilter<"OsEntryIpd"> | number
    ipd_type?: StringFilter<"OsEntryIpd"> | string
    url?: StringNullableFilter<"OsEntryIpd"> | string | null
    active?: BoolNullableFilter<"OsEntryIpd"> | boolean | null
  }

  export type OsEntryOsStringMapUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryOsStringMapWhereUniqueInput
    update: XOR<OsEntryOsStringMapUpdateWithoutOsEntryInput, OsEntryOsStringMapUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntryOsStringMapCreateWithoutOsEntryInput, OsEntryOsStringMapUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryOsStringMapUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryOsStringMapWhereUniqueInput
    data: XOR<OsEntryOsStringMapUpdateWithoutOsEntryInput, OsEntryOsStringMapUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryOsStringMapUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntryOsStringMapScalarWhereInput
    data: XOR<OsEntryOsStringMapUpdateManyMutationInput, OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntryOsStringMapScalarWhereInput = {
    AND?: OsEntryOsStringMapScalarWhereInput | OsEntryOsStringMapScalarWhereInput[]
    OR?: OsEntryOsStringMapScalarWhereInput[]
    NOT?: OsEntryOsStringMapScalarWhereInput | OsEntryOsStringMapScalarWhereInput[]
    os_id?: IntFilter<"OsEntryOsStringMap"> | number
    os_string?: StringFilter<"OsEntryOsStringMap"> | string
  }

  export type OsEntryPreinstalledUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    update: XOR<OsEntryPreinstalledUpdateWithoutOsEntryInput, OsEntryPreinstalledUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntryPreinstalledCreateWithoutOsEntryInput, OsEntryPreinstalledUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryPreinstalledUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryPreinstalledWhereUniqueInput
    data: XOR<OsEntryPreinstalledUpdateWithoutOsEntryInput, OsEntryPreinstalledUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryPreinstalledUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntryPreinstalledScalarWhereInput
    data: XOR<OsEntryPreinstalledUpdateManyMutationInput, OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntryReleaseNoteUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryReleaseNoteWhereUniqueInput
    update: XOR<OsEntryReleaseNoteUpdateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntryReleaseNoteCreateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntryReleaseNoteUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntryReleaseNoteWhereUniqueInput
    data: XOR<OsEntryReleaseNoteUpdateWithoutOsEntryInput, OsEntryReleaseNoteUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntryReleaseNoteUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntryReleaseNoteScalarWhereInput
    data: XOR<OsEntryReleaseNoteUpdateManyMutationInput, OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntryReleaseNoteScalarWhereInput = {
    AND?: OsEntryReleaseNoteScalarWhereInput | OsEntryReleaseNoteScalarWhereInput[]
    OR?: OsEntryReleaseNoteScalarWhereInput[]
    NOT?: OsEntryReleaseNoteScalarWhereInput | OsEntryReleaseNoteScalarWhereInput[]
    os_id?: IntFilter<"OsEntryReleaseNote"> | number
    url?: StringFilter<"OsEntryReleaseNote"> | string
    active?: BoolNullableFilter<"OsEntryReleaseNote"> | boolean | null
  }

  export type OsEntrySafariVersionUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntrySafariVersionWhereUniqueInput
    update: XOR<OsEntrySafariVersionUpdateWithoutOsEntryInput, OsEntrySafariVersionUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntrySafariVersionCreateWithoutOsEntryInput, OsEntrySafariVersionUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntrySafariVersionUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntrySafariVersionWhereUniqueInput
    data: XOR<OsEntrySafariVersionUpdateWithoutOsEntryInput, OsEntrySafariVersionUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntrySafariVersionUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntrySafariVersionScalarWhereInput
    data: XOR<OsEntrySafariVersionUpdateManyMutationInput, OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntrySafariVersionScalarWhereInput = {
    AND?: OsEntrySafariVersionScalarWhereInput | OsEntrySafariVersionScalarWhereInput[]
    OR?: OsEntrySafariVersionScalarWhereInput[]
    NOT?: OsEntrySafariVersionScalarWhereInput | OsEntrySafariVersionScalarWhereInput[]
    os_id?: IntFilter<"OsEntrySafariVersion"> | number
    version?: StringFilter<"OsEntrySafariVersion"> | string
  }

  export type OsEntrySecurityNoteUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntrySecurityNoteWhereUniqueInput
    update: XOR<OsEntrySecurityNoteUpdateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedUpdateWithoutOsEntryInput>
    create: XOR<OsEntrySecurityNoteCreateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedCreateWithoutOsEntryInput>
  }

  export type OsEntrySecurityNoteUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: OsEntrySecurityNoteWhereUniqueInput
    data: XOR<OsEntrySecurityNoteUpdateWithoutOsEntryInput, OsEntrySecurityNoteUncheckedUpdateWithoutOsEntryInput>
  }

  export type OsEntrySecurityNoteUpdateManyWithWhereWithoutOsEntryInput = {
    where: OsEntrySecurityNoteScalarWhereInput
    data: XOR<OsEntrySecurityNoteUpdateManyMutationInput, OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type OsEntrySecurityNoteScalarWhereInput = {
    AND?: OsEntrySecurityNoteScalarWhereInput | OsEntrySecurityNoteScalarWhereInput[]
    OR?: OsEntrySecurityNoteScalarWhereInput[]
    NOT?: OsEntrySecurityNoteScalarWhereInput | OsEntrySecurityNoteScalarWhereInput[]
    os_id?: IntFilter<"OsEntrySecurityNote"> | number
    url?: StringFilter<"OsEntrySecurityNote"> | string
    active?: BoolNullableFilter<"OsEntrySecurityNote"> | boolean | null
  }

  export type SourceEntryUpsertWithWhereUniqueWithoutOsEntryInput = {
    where: SourceEntryWhereUniqueInput
    update: XOR<SourceEntryUpdateWithoutOsEntryInput, SourceEntryUncheckedUpdateWithoutOsEntryInput>
    create: XOR<SourceEntryCreateWithoutOsEntryInput, SourceEntryUncheckedCreateWithoutOsEntryInput>
  }

  export type SourceEntryUpdateWithWhereUniqueWithoutOsEntryInput = {
    where: SourceEntryWhereUniqueInput
    data: XOR<SourceEntryUpdateWithoutOsEntryInput, SourceEntryUncheckedUpdateWithoutOsEntryInput>
  }

  export type SourceEntryUpdateManyWithWhereWithoutOsEntryInput = {
    where: SourceEntryScalarWhereInput
    data: XOR<SourceEntryUpdateManyMutationInput, SourceEntryUncheckedUpdateManyWithoutOsEntryInput>
  }

  export type SourceEntryScalarWhereInput = {
    AND?: SourceEntryScalarWhereInput | SourceEntryScalarWhereInput[]
    OR?: SourceEntryScalarWhereInput[]
    NOT?: SourceEntryScalarWhereInput | SourceEntryScalarWhereInput[]
    id?: IntFilter<"SourceEntry"> | number
    os_id?: IntNullableFilter<"SourceEntry"> | number | null
    source_type?: StringNullableFilter<"SourceEntry"> | string | null
    skip_update_links?: BoolNullableFilter<"SourceEntry"> | boolean | null
    size?: BigIntNullableFilter<"SourceEntry"> | bigint | number | null
    windows_update_id?: StringNullableFilter<"SourceEntry"> | string | null
    windows_revision_id?: StringNullableFilter<"SourceEntry"> | string | null
  }

  export type OsEntryCreateWithoutOsEntryBuildTrainInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntryBuildTrainInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntryBuildTrainInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntryBuildTrainInput, OsEntryUncheckedCreateWithoutOsEntryBuildTrainInput>
  }

  export type OsEntryUpsertWithoutOsEntryBuildTrainInput = {
    update: XOR<OsEntryUpdateWithoutOsEntryBuildTrainInput, OsEntryUncheckedUpdateWithoutOsEntryBuildTrainInput>
    create: XOR<OsEntryCreateWithoutOsEntryBuildTrainInput, OsEntryUncheckedCreateWithoutOsEntryBuildTrainInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntryBuildTrainInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntryBuildTrainInput, OsEntryUncheckedUpdateWithoutOsEntryBuildTrainInput>
  }

  export type OsEntryUpdateWithoutOsEntryBuildTrainInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntryBuildTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntryIpdInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntryIpdInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntryIpdInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntryIpdInput, OsEntryUncheckedCreateWithoutOsEntryIpdInput>
  }

  export type OsEntryUpsertWithoutOsEntryIpdInput = {
    update: XOR<OsEntryUpdateWithoutOsEntryIpdInput, OsEntryUncheckedUpdateWithoutOsEntryIpdInput>
    create: XOR<OsEntryCreateWithoutOsEntryIpdInput, OsEntryUncheckedCreateWithoutOsEntryIpdInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntryIpdInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntryIpdInput, OsEntryUncheckedUpdateWithoutOsEntryIpdInput>
  }

  export type OsEntryUpdateWithoutOsEntryIpdInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntryIpdInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntryOsStringMapInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntryOsStringMapInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntryOsStringMapInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntryOsStringMapInput, OsEntryUncheckedCreateWithoutOsEntryOsStringMapInput>
  }

  export type OsEntryUpsertWithoutOsEntryOsStringMapInput = {
    update: XOR<OsEntryUpdateWithoutOsEntryOsStringMapInput, OsEntryUncheckedUpdateWithoutOsEntryOsStringMapInput>
    create: XOR<OsEntryCreateWithoutOsEntryOsStringMapInput, OsEntryUncheckedCreateWithoutOsEntryOsStringMapInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntryOsStringMapInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntryOsStringMapInput, OsEntryUncheckedUpdateWithoutOsEntryOsStringMapInput>
  }

  export type OsEntryUpdateWithoutOsEntryOsStringMapInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntryOsStringMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntryPreinstalledInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntryPreinstalledInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntryPreinstalledInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntryPreinstalledInput, OsEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
  }

  export type DeviceEntryCreateWithoutOsEntryPreinstalledInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutOsEntryPreinstalledInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutOsEntryPreinstalledInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
  }

  export type OsEntryUpsertWithoutOsEntryPreinstalledInput = {
    update: XOR<OsEntryUpdateWithoutOsEntryPreinstalledInput, OsEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
    create: XOR<OsEntryCreateWithoutOsEntryPreinstalledInput, OsEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntryPreinstalledInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntryPreinstalledInput, OsEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
  }

  export type OsEntryUpdateWithoutOsEntryPreinstalledInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntryPreinstalledInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type DeviceEntryUpsertWithoutOsEntryPreinstalledInput = {
    update: XOR<DeviceEntryUpdateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
    create: XOR<DeviceEntryCreateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedCreateWithoutOsEntryPreinstalledInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutOsEntryPreinstalledInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutOsEntryPreinstalledInput, DeviceEntryUncheckedUpdateWithoutOsEntryPreinstalledInput>
  }

  export type DeviceEntryUpdateWithoutOsEntryPreinstalledInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutOsEntryPreinstalledInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntryReleaseNoteInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntryReleaseNoteInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntryReleaseNoteInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedCreateWithoutOsEntryReleaseNoteInput>
  }

  export type OsEntryUpsertWithoutOsEntryReleaseNoteInput = {
    update: XOR<OsEntryUpdateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedUpdateWithoutOsEntryReleaseNoteInput>
    create: XOR<OsEntryCreateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedCreateWithoutOsEntryReleaseNoteInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntryReleaseNoteInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntryReleaseNoteInput, OsEntryUncheckedUpdateWithoutOsEntryReleaseNoteInput>
  }

  export type OsEntryUpdateWithoutOsEntryReleaseNoteInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntryReleaseNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntrySafariVersionInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntrySafariVersionInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntrySafariVersionInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntrySafariVersionInput, OsEntryUncheckedCreateWithoutOsEntrySafariVersionInput>
  }

  export type OsEntryUpsertWithoutOsEntrySafariVersionInput = {
    update: XOR<OsEntryUpdateWithoutOsEntrySafariVersionInput, OsEntryUncheckedUpdateWithoutOsEntrySafariVersionInput>
    create: XOR<OsEntryCreateWithoutOsEntrySafariVersionInput, OsEntryUncheckedCreateWithoutOsEntrySafariVersionInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntrySafariVersionInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntrySafariVersionInput, OsEntryUncheckedUpdateWithoutOsEntrySafariVersionInput>
  }

  export type OsEntryUpdateWithoutOsEntrySafariVersionInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntrySafariVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsEntrySecurityNoteInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsEntrySecurityNoteInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsEntrySecurityNoteInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedCreateWithoutOsEntrySecurityNoteInput>
  }

  export type OsEntryUpsertWithoutOsEntrySecurityNoteInput = {
    update: XOR<OsEntryUpdateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedUpdateWithoutOsEntrySecurityNoteInput>
    create: XOR<OsEntryCreateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedCreateWithoutOsEntrySecurityNoteInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutOsEntrySecurityNoteInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutOsEntrySecurityNoteInput, OsEntryUncheckedUpdateWithoutOsEntrySecurityNoteInput>
  }

  export type OsEntryUpdateWithoutOsEntrySecurityNoteInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsEntrySecurityNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryCreateWithoutOsLookupNameInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutOsLookupNameInput = {
    id?: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
    SourceEntry?: SourceEntryUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutOsLookupNameInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput>
  }

  export type OsEntryCreateManyOsLookupNameInputEnvelope = {
    data: OsEntryCreateManyOsLookupNameInput | OsEntryCreateManyOsLookupNameInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryUpsertWithWhereUniqueWithoutOsLookupNameInput = {
    where: OsEntryWhereUniqueInput
    update: XOR<OsEntryUpdateWithoutOsLookupNameInput, OsEntryUncheckedUpdateWithoutOsLookupNameInput>
    create: XOR<OsEntryCreateWithoutOsLookupNameInput, OsEntryUncheckedCreateWithoutOsLookupNameInput>
  }

  export type OsEntryUpdateWithWhereUniqueWithoutOsLookupNameInput = {
    where: OsEntryWhereUniqueInput
    data: XOR<OsEntryUpdateWithoutOsLookupNameInput, OsEntryUncheckedUpdateWithoutOsLookupNameInput>
  }

  export type OsEntryUpdateManyWithWhereWithoutOsLookupNameInput = {
    where: OsEntryScalarWhereInput
    data: XOR<OsEntryUpdateManyMutationInput, OsEntryUncheckedUpdateManyWithoutOsLookupNameInput>
  }

  export type OsEntryScalarWhereInput = {
    AND?: OsEntryScalarWhereInput | OsEntryScalarWhereInput[]
    OR?: OsEntryScalarWhereInput[]
    NOT?: OsEntryScalarWhereInput | OsEntryScalarWhereInput[]
    id?: IntFilter<"OsEntry"> | number
    name_id?: IntFilter<"OsEntry"> | number
    version?: StringFilter<"OsEntry"> | string
    build?: StringNullableFilter<"OsEntry"> | string | null
    release_datetime?: DateTimeNullableFilter<"OsEntry"> | Date | string | null
    release_datetime_depth?: IntNullableFilter<"OsEntry"> | number | null
    is_release?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_beta?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rc?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_internal?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_rsr?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_sdk?: BoolNullableFilter<"OsEntry"> | boolean | null
    is_simulator?: BoolNullableFilter<"OsEntry"> | boolean | null
    image_id?: StringNullableFilter<"OsEntry"> | string | null
    embedded_os_build?: StringNullableFilter<"OsEntry"> | string | null
    bridge_os_build?: StringNullableFilter<"OsEntry"> | string | null
    notes?: StringNullableFilter<"OsEntry"> | string | null
    legacy_unique_key?: StringNullableFilter<"OsEntry"> | string | null
    search?: StringNullableFilter<"OsEntry"> | string | null
  }

  export type OsEntryCreateWithoutSourceEntryInput = {
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutOsEntryInput
    OsLookupName: OsLookupNameCreateNestedOneWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryUncheckedCreateWithoutSourceEntryInput = {
    id?: number
    name_id: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryIpd?: OsEntryIpdUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedCreateNestedManyWithoutOsEntryInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedCreateNestedManyWithoutOsEntryInput
  }

  export type OsEntryCreateOrConnectWithoutSourceEntryInput = {
    where: OsEntryWhereUniqueInput
    create: XOR<OsEntryCreateWithoutSourceEntryInput, OsEntryUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceHashCreateWithoutSourceEntryInput = {
    hash_type: string
    hash_value?: string | null
  }

  export type SourceHashUncheckedCreateWithoutSourceEntryInput = {
    hash_type: string
    hash_value?: string | null
  }

  export type SourceHashCreateOrConnectWithoutSourceEntryInput = {
    where: SourceHashWhereUniqueInput
    create: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceHashCreateManySourceEntryInputEnvelope = {
    data: SourceHashCreateManySourceEntryInput | SourceHashCreateManySourceEntryInput[]
    skipDuplicates?: boolean
  }

  export type SourceLinkCreateWithoutSourceEntryInput = {
    url: string
    active?: boolean | null
  }

  export type SourceLinkUncheckedCreateWithoutSourceEntryInput = {
    url: string
    active?: boolean | null
  }

  export type SourceLinkCreateOrConnectWithoutSourceEntryInput = {
    where: SourceLinkWhereUniqueInput
    create: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceLinkCreateManySourceEntryInputEnvelope = {
    data: SourceLinkCreateManySourceEntryInput | SourceLinkCreateManySourceEntryInput[]
    skipDuplicates?: boolean
  }

  export type SourceMapDeviceCreateWithoutSourceEntryInput = {
    DeviceEntry: DeviceEntryCreateNestedOneWithoutSourceMapDeviceInput
  }

  export type SourceMapDeviceUncheckedCreateWithoutSourceEntryInput = {
    device_id: number
  }

  export type SourceMapDeviceCreateOrConnectWithoutSourceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    create: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceMapDeviceCreateManySourceEntryInputEnvelope = {
    data: SourceMapDeviceCreateManySourceEntryInput | SourceMapDeviceCreateManySourceEntryInput[]
    skipDuplicates?: boolean
  }

  export type SourcePrequisiteBuildCreateWithoutSourceEntryInput = {
    build: string
  }

  export type SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput = {
    build: string
  }

  export type SourcePrequisiteBuildCreateOrConnectWithoutSourceEntryInput = {
    where: SourcePrequisiteBuildWhereUniqueInput
    create: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourcePrequisiteBuildCreateManySourceEntryInputEnvelope = {
    data: SourcePrequisiteBuildCreateManySourceEntryInput | SourcePrequisiteBuildCreateManySourceEntryInput[]
    skipDuplicates?: boolean
  }

  export type OsEntryUpsertWithoutSourceEntryInput = {
    update: XOR<OsEntryUpdateWithoutSourceEntryInput, OsEntryUncheckedUpdateWithoutSourceEntryInput>
    create: XOR<OsEntryCreateWithoutSourceEntryInput, OsEntryUncheckedCreateWithoutSourceEntryInput>
    where?: OsEntryWhereInput
  }

  export type OsEntryUpdateToOneWithWhereWithoutSourceEntryInput = {
    where?: OsEntryWhereInput
    data: XOR<OsEntryUpdateWithoutSourceEntryInput, OsEntryUncheckedUpdateWithoutSourceEntryInput>
  }

  export type OsEntryUpdateWithoutSourceEntryInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsLookupName?: OsLookupNameUpdateOneRequiredWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutSourceEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type SourceHashUpsertWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceHashWhereUniqueInput
    update: XOR<SourceHashUpdateWithoutSourceEntryInput, SourceHashUncheckedUpdateWithoutSourceEntryInput>
    create: XOR<SourceHashCreateWithoutSourceEntryInput, SourceHashUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceHashUpdateWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceHashWhereUniqueInput
    data: XOR<SourceHashUpdateWithoutSourceEntryInput, SourceHashUncheckedUpdateWithoutSourceEntryInput>
  }

  export type SourceHashUpdateManyWithWhereWithoutSourceEntryInput = {
    where: SourceHashScalarWhereInput
    data: XOR<SourceHashUpdateManyMutationInput, SourceHashUncheckedUpdateManyWithoutSourceEntryInput>
  }

  export type SourceHashScalarWhereInput = {
    AND?: SourceHashScalarWhereInput | SourceHashScalarWhereInput[]
    OR?: SourceHashScalarWhereInput[]
    NOT?: SourceHashScalarWhereInput | SourceHashScalarWhereInput[]
    source_id?: IntFilter<"SourceHash"> | number
    hash_type?: StringFilter<"SourceHash"> | string
    hash_value?: StringNullableFilter<"SourceHash"> | string | null
  }

  export type SourceLinkUpsertWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceLinkWhereUniqueInput
    update: XOR<SourceLinkUpdateWithoutSourceEntryInput, SourceLinkUncheckedUpdateWithoutSourceEntryInput>
    create: XOR<SourceLinkCreateWithoutSourceEntryInput, SourceLinkUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceLinkUpdateWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceLinkWhereUniqueInput
    data: XOR<SourceLinkUpdateWithoutSourceEntryInput, SourceLinkUncheckedUpdateWithoutSourceEntryInput>
  }

  export type SourceLinkUpdateManyWithWhereWithoutSourceEntryInput = {
    where: SourceLinkScalarWhereInput
    data: XOR<SourceLinkUpdateManyMutationInput, SourceLinkUncheckedUpdateManyWithoutSourceEntryInput>
  }

  export type SourceLinkScalarWhereInput = {
    AND?: SourceLinkScalarWhereInput | SourceLinkScalarWhereInput[]
    OR?: SourceLinkScalarWhereInput[]
    NOT?: SourceLinkScalarWhereInput | SourceLinkScalarWhereInput[]
    source_id?: IntFilter<"SourceLink"> | number
    url?: StringFilter<"SourceLink"> | string
    active?: BoolNullableFilter<"SourceLink"> | boolean | null
  }

  export type SourceMapDeviceUpsertWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    update: XOR<SourceMapDeviceUpdateWithoutSourceEntryInput, SourceMapDeviceUncheckedUpdateWithoutSourceEntryInput>
    create: XOR<SourceMapDeviceCreateWithoutSourceEntryInput, SourceMapDeviceUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourceMapDeviceUpdateWithWhereUniqueWithoutSourceEntryInput = {
    where: SourceMapDeviceWhereUniqueInput
    data: XOR<SourceMapDeviceUpdateWithoutSourceEntryInput, SourceMapDeviceUncheckedUpdateWithoutSourceEntryInput>
  }

  export type SourceMapDeviceUpdateManyWithWhereWithoutSourceEntryInput = {
    where: SourceMapDeviceScalarWhereInput
    data: XOR<SourceMapDeviceUpdateManyMutationInput, SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryInput>
  }

  export type SourcePrequisiteBuildUpsertWithWhereUniqueWithoutSourceEntryInput = {
    where: SourcePrequisiteBuildWhereUniqueInput
    update: XOR<SourcePrequisiteBuildUpdateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedUpdateWithoutSourceEntryInput>
    create: XOR<SourcePrequisiteBuildCreateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedCreateWithoutSourceEntryInput>
  }

  export type SourcePrequisiteBuildUpdateWithWhereUniqueWithoutSourceEntryInput = {
    where: SourcePrequisiteBuildWhereUniqueInput
    data: XOR<SourcePrequisiteBuildUpdateWithoutSourceEntryInput, SourcePrequisiteBuildUncheckedUpdateWithoutSourceEntryInput>
  }

  export type SourcePrequisiteBuildUpdateManyWithWhereWithoutSourceEntryInput = {
    where: SourcePrequisiteBuildScalarWhereInput
    data: XOR<SourcePrequisiteBuildUpdateManyMutationInput, SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryInput>
  }

  export type SourcePrequisiteBuildScalarWhereInput = {
    AND?: SourcePrequisiteBuildScalarWhereInput | SourcePrequisiteBuildScalarWhereInput[]
    OR?: SourcePrequisiteBuildScalarWhereInput[]
    NOT?: SourcePrequisiteBuildScalarWhereInput | SourcePrequisiteBuildScalarWhereInput[]
    source_id?: IntFilter<"SourcePrequisiteBuild"> | number
    build?: StringFilter<"SourcePrequisiteBuild"> | string
  }

  export type SourceEntryCreateWithoutSourceHashInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    OsEntry?: OsEntryCreateNestedOneWithoutSourceEntryInput
    SourceLink?: SourceLinkCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateWithoutSourceHashInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceLink?: SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryCreateOrConnectWithoutSourceHashInput = {
    where: SourceEntryWhereUniqueInput
    create: XOR<SourceEntryCreateWithoutSourceHashInput, SourceEntryUncheckedCreateWithoutSourceHashInput>
  }

  export type SourceEntryUpsertWithoutSourceHashInput = {
    update: XOR<SourceEntryUpdateWithoutSourceHashInput, SourceEntryUncheckedUpdateWithoutSourceHashInput>
    create: XOR<SourceEntryCreateWithoutSourceHashInput, SourceEntryUncheckedCreateWithoutSourceHashInput>
    where?: SourceEntryWhereInput
  }

  export type SourceEntryUpdateToOneWithWhereWithoutSourceHashInput = {
    where?: SourceEntryWhereInput
    data: XOR<SourceEntryUpdateWithoutSourceHashInput, SourceEntryUncheckedUpdateWithoutSourceHashInput>
  }

  export type SourceEntryUpdateWithoutSourceHashInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntry?: OsEntryUpdateOneWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateWithoutSourceHashInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceLink?: SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryCreateWithoutSourceLinkInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    OsEntry?: OsEntryCreateNestedOneWithoutSourceEntryInput
    SourceHash?: SourceHashCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateWithoutSourceLinkInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryCreateOrConnectWithoutSourceLinkInput = {
    where: SourceEntryWhereUniqueInput
    create: XOR<SourceEntryCreateWithoutSourceLinkInput, SourceEntryUncheckedCreateWithoutSourceLinkInput>
  }

  export type SourceEntryUpsertWithoutSourceLinkInput = {
    update: XOR<SourceEntryUpdateWithoutSourceLinkInput, SourceEntryUncheckedUpdateWithoutSourceLinkInput>
    create: XOR<SourceEntryCreateWithoutSourceLinkInput, SourceEntryUncheckedCreateWithoutSourceLinkInput>
    where?: SourceEntryWhereInput
  }

  export type SourceEntryUpdateToOneWithWhereWithoutSourceLinkInput = {
    where?: SourceEntryWhereInput
    data: XOR<SourceEntryUpdateWithoutSourceLinkInput, SourceEntryUncheckedUpdateWithoutSourceLinkInput>
  }

  export type SourceEntryUpdateWithoutSourceLinkInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntry?: OsEntryUpdateOneWithoutSourceEntryNestedInput
    SourceHash?: SourceHashUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateWithoutSourceLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryCreateWithoutSourceMapDeviceInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    OsEntry?: OsEntryCreateNestedOneWithoutSourceEntryInput
    SourceHash?: SourceHashCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateWithoutSourceMapDeviceInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryCreateOrConnectWithoutSourceMapDeviceInput = {
    where: SourceEntryWhereUniqueInput
    create: XOR<SourceEntryCreateWithoutSourceMapDeviceInput, SourceEntryUncheckedCreateWithoutSourceMapDeviceInput>
  }

  export type DeviceEntryCreateWithoutSourceMapDeviceInput = {
    name: string
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceLookupCategory: DeviceLookupCategoryCreateNestedOneWithoutDeviceEntryInput
    DeviceLookupImage?: DeviceLookupImageCreateNestedOneWithoutDeviceEntryInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryUncheckedCreateWithoutSourceMapDeviceInput = {
    id?: number
    name: string
    category_id: number
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapModel?: DeviceMapModelUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedCreateNestedManyWithoutDeviceEntryInput
    DeviceMapSoc?: DeviceMapSocUncheckedCreateNestedManyWithoutDeviceEntryInput
    MapDeviceOs?: MapDeviceOsUncheckedCreateNestedManyWithoutDeviceEntryInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedCreateNestedManyWithoutDeviceEntryInput
  }

  export type DeviceEntryCreateOrConnectWithoutSourceMapDeviceInput = {
    where: DeviceEntryWhereUniqueInput
    create: XOR<DeviceEntryCreateWithoutSourceMapDeviceInput, DeviceEntryUncheckedCreateWithoutSourceMapDeviceInput>
  }

  export type SourceEntryUpsertWithoutSourceMapDeviceInput = {
    update: XOR<SourceEntryUpdateWithoutSourceMapDeviceInput, SourceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
    create: XOR<SourceEntryCreateWithoutSourceMapDeviceInput, SourceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    where?: SourceEntryWhereInput
  }

  export type SourceEntryUpdateToOneWithWhereWithoutSourceMapDeviceInput = {
    where?: SourceEntryWhereInput
    data: XOR<SourceEntryUpdateWithoutSourceMapDeviceInput, SourceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
  }

  export type SourceEntryUpdateWithoutSourceMapDeviceInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntry?: OsEntryUpdateOneWithoutSourceEntryNestedInput
    SourceHash?: SourceHashUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateWithoutSourceMapDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type DeviceEntryUpsertWithoutSourceMapDeviceInput = {
    update: XOR<DeviceEntryUpdateWithoutSourceMapDeviceInput, DeviceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
    create: XOR<DeviceEntryCreateWithoutSourceMapDeviceInput, DeviceEntryUncheckedCreateWithoutSourceMapDeviceInput>
    where?: DeviceEntryWhereInput
  }

  export type DeviceEntryUpdateToOneWithWhereWithoutSourceMapDeviceInput = {
    where?: DeviceEntryWhereInput
    data: XOR<DeviceEntryUpdateWithoutSourceMapDeviceInput, DeviceEntryUncheckedUpdateWithoutSourceMapDeviceInput>
  }

  export type DeviceEntryUpdateWithoutSourceMapDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutSourceMapDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type SourceEntryCreateWithoutSourcePrequisiteBuildInput = {
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    OsEntry?: OsEntryCreateNestedOneWithoutSourceEntryInput
    SourceHash?: SourceHashCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryUncheckedCreateWithoutSourcePrequisiteBuildInput = {
    id?: number
    os_id?: number | null
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
    SourceHash?: SourceHashUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceLink?: SourceLinkUncheckedCreateNestedManyWithoutSourceEntryInput
    SourceMapDevice?: SourceMapDeviceUncheckedCreateNestedManyWithoutSourceEntryInput
  }

  export type SourceEntryCreateOrConnectWithoutSourcePrequisiteBuildInput = {
    where: SourceEntryWhereUniqueInput
    create: XOR<SourceEntryCreateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedCreateWithoutSourcePrequisiteBuildInput>
  }

  export type SourceEntryUpsertWithoutSourcePrequisiteBuildInput = {
    update: XOR<SourceEntryUpdateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedUpdateWithoutSourcePrequisiteBuildInput>
    create: XOR<SourceEntryCreateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedCreateWithoutSourcePrequisiteBuildInput>
    where?: SourceEntryWhereInput
  }

  export type SourceEntryUpdateToOneWithWhereWithoutSourcePrequisiteBuildInput = {
    where?: SourceEntryWhereInput
    data: XOR<SourceEntryUpdateWithoutSourcePrequisiteBuildInput, SourceEntryUncheckedUpdateWithoutSourcePrequisiteBuildInput>
  }

  export type SourceEntryUpdateWithoutSourcePrequisiteBuildInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    OsEntry?: OsEntryUpdateOneWithoutSourceEntryNestedInput
    SourceHash?: SourceHashUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateWithoutSourcePrequisiteBuildInput = {
    id?: IntFieldUpdateOperationsInput | number
    os_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type DeviceImageColorsCreateManyColorLookupInput = {
    device_image_id: number
    dark_mode?: boolean | null
  }

  export type DeviceImageColorsUpdateWithoutColorLookupInput = {
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    DeviceLookupImage?: DeviceLookupImageUpdateOneRequiredWithoutDeviceImageColorsNestedInput
  }

  export type DeviceImageColorsUncheckedUpdateWithoutColorLookupInput = {
    device_image_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceImageColorsUncheckedUpdateManyWithoutColorLookupInput = {
    device_image_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceGroupMapDeviceCreateManyDeviceEntryInput = {
    group_id: number
  }

  export type DeviceMapArchitectureCreateManyDeviceEntryInput = {
    architecture_id: number
  }

  export type DeviceMapIdentifierCreateManyDeviceEntryInput = {
    identifier: string
  }

  export type DeviceMapModelCreateManyDeviceEntryInput = {
    model: string
  }

  export type DeviceMapReleaseCreateManyDeviceEntryInput = {
    id?: number
    datetime?: Date | string | null
    depth?: number | null
  }

  export type DeviceMapSocCreateManyDeviceEntryInput = {
    soc_id: number
  }

  export type MapDeviceOsCreateManyDeviceEntryInput = {
    os_id: number
  }

  export type OsEntryPreinstalledCreateManyDeviceEntryInput = {
    os_id: number
  }

  export type SourceMapDeviceCreateManyDeviceEntryInput = {
    source_id: number
  }

  export type DeviceGroupMapDeviceUpdateWithoutDeviceEntryInput = {
    DeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput
  }

  export type DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceEntryInput = {
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryInput = {
    group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapArchitectureUpdateWithoutDeviceEntryInput = {
    DeviceLookupArchitecture?: DeviceLookupArchitectureUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput
  }

  export type DeviceMapArchitectureUncheckedUpdateWithoutDeviceEntryInput = {
    architecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryInput = {
    architecture_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapIdentifierUpdateWithoutDeviceEntryInput = {
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapIdentifierUncheckedUpdateWithoutDeviceEntryInput = {
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryInput = {
    identifier?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelUpdateWithoutDeviceEntryInput = {
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelUncheckedUpdateWithoutDeviceEntryInput = {
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryInput = {
    model?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceMapReleaseUpdateWithoutDeviceEntryInput = {
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapReleaseUncheckedUpdateWithoutDeviceEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    depth?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceMapSocUpdateWithoutDeviceEntryInput = {
    DeviceLookupSoc?: DeviceLookupSocUpdateOneRequiredWithoutDeviceMapSocNestedInput
  }

  export type DeviceMapSocUncheckedUpdateWithoutDeviceEntryInput = {
    soc_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryInput = {
    soc_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsUpdateWithoutDeviceEntryInput = {
    OsEntry?: OsEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput
  }

  export type MapDeviceOsUncheckedUpdateWithoutDeviceEntryInput = {
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryInput = {
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryPreinstalledUpdateWithoutDeviceEntryInput = {
    OsEntry?: OsEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput
  }

  export type OsEntryPreinstalledUncheckedUpdateWithoutDeviceEntryInput = {
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryInput = {
    os_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourceMapDeviceUpdateWithoutDeviceEntryInput = {
    SourceEntry?: SourceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput
  }

  export type SourceMapDeviceUncheckedUpdateWithoutDeviceEntryInput = {
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryInput = {
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceCreateManyDeviceGroupEntryInput = {
    device_id: number
  }

  export type DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    child_group_id: number
  }

  export type DeviceGroupMapDeviceGroupCreateManyDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    parent_group_id: number
  }

  export type DeviceGroupMapDeviceUpdateWithoutDeviceGroupEntryInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceNestedInput
  }

  export type DeviceGroupMapDeviceUncheckedUpdateWithoutDeviceGroupEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceGroupEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    child_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryInput = {
    child_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    DeviceGroupEntry_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntry?: DeviceGroupEntryUpdateOneRequiredWithoutDeviceGroupMapDeviceGroup_DeviceGroupMapDeviceGroup_parent_group_idToDeviceGroupEntryNestedInput
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    parent_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceGroupMapDeviceGroupUncheckedUpdateManyWithoutDeviceGroupEntry_DeviceGroupMapDeviceGroup_child_group_idToDeviceGroupEntryInput = {
    parent_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapArchitectureCreateManyDeviceLookupArchitectureInput = {
    device_id: number
  }

  export type DeviceMapArchitectureUpdateWithoutDeviceLookupArchitectureInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapArchitectureNestedInput
  }

  export type DeviceMapArchitectureUncheckedUpdateWithoutDeviceLookupArchitectureInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceLookupArchitectureInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceEntryCreateManyDeviceLookupCategoryInput = {
    id?: number
    name: string
    image_id?: number | null
    is_internal?: boolean | null
    legacy_unique_key?: string | null
  }

  export type DeviceEntryUpdateWithoutDeviceLookupCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupImage?: DeviceLookupImageUpdateOneWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceLookupCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateManyWithoutDeviceLookupCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    image_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceEntryCreateManyDeviceLookupImageInput = {
    id?: number
    name: string
    category_id: number
    is_internal?: boolean | null
    legacy_unique_key?: string | null
  }

  export type DeviceImageColorsCreateManyDeviceLookupImageInput = {
    color_id: number
    dark_mode?: boolean | null
  }

  export type DeviceEntryUpdateWithoutDeviceLookupImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceLookupCategory?: DeviceLookupCategoryUpdateOneRequiredWithoutDeviceEntryNestedInput
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateWithoutDeviceLookupImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    DeviceGroupMapDevice?: DeviceGroupMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapArchitecture?: DeviceMapArchitectureUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapIdentifier?: DeviceMapIdentifierUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapModel?: DeviceMapModelUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapRelease?: DeviceMapReleaseUncheckedUpdateManyWithoutDeviceEntryNestedInput
    DeviceMapSoc?: DeviceMapSocUncheckedUpdateManyWithoutDeviceEntryNestedInput
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutDeviceEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutDeviceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutDeviceEntryNestedInput
  }

  export type DeviceEntryUncheckedUpdateManyWithoutDeviceLookupImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceImageColorsUpdateWithoutDeviceLookupImageInput = {
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ColorLookup?: ColorLookupUpdateOneRequiredWithoutDeviceImageColorsNestedInput
  }

  export type DeviceImageColorsUncheckedUpdateWithoutDeviceLookupImageInput = {
    color_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceImageColorsUncheckedUpdateManyWithoutDeviceLookupImageInput = {
    color_id?: IntFieldUpdateOperationsInput | number
    dark_mode?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeviceMapSocCreateManyDeviceLookupSocInput = {
    device_id: number
  }

  export type DeviceMapSocUpdateWithoutDeviceLookupSocInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutDeviceMapSocNestedInput
  }

  export type DeviceMapSocUncheckedUpdateWithoutDeviceLookupSocInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type DeviceMapSocUncheckedUpdateManyWithoutDeviceLookupSocInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsCreateManyOsEntryInput = {
    device_id: number
  }

  export type OsEntryBuildTrainCreateManyOsEntryInput = {
    build_train: string
  }

  export type OsEntryIpdCreateManyOsEntryInput = {
    ipd_type: string
    url?: string | null
    active?: boolean | null
  }

  export type OsEntryOsStringMapCreateManyOsEntryInput = {
    os_string: string
  }

  export type OsEntryPreinstalledCreateManyOsEntryInput = {
    device_id: number
  }

  export type OsEntryReleaseNoteCreateManyOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type OsEntrySafariVersionCreateManyOsEntryInput = {
    version: string
  }

  export type OsEntrySecurityNoteCreateManyOsEntryInput = {
    url: string
    active?: boolean | null
  }

  export type SourceEntryCreateManyOsEntryInput = {
    id?: number
    source_type?: string | null
    skip_update_links?: boolean | null
    size?: bigint | number | null
    windows_update_id?: string | null
    windows_revision_id?: string | null
  }

  export type MapDeviceOsUpdateWithoutOsEntryInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutMapDeviceOsNestedInput
  }

  export type MapDeviceOsUncheckedUpdateWithoutOsEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type MapDeviceOsUncheckedUpdateManyWithoutOsEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryBuildTrainUpdateWithoutOsEntryInput = {
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryBuildTrainUncheckedUpdateWithoutOsEntryInput = {
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryInput = {
    build_train?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryIpdUpdateWithoutOsEntryInput = {
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryIpdUncheckedUpdateWithoutOsEntryInput = {
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryIpdUncheckedUpdateManyWithoutOsEntryInput = {
    ipd_type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryOsStringMapUpdateWithoutOsEntryInput = {
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryOsStringMapUncheckedUpdateWithoutOsEntryInput = {
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryInput = {
    os_string?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntryPreinstalledUpdateWithoutOsEntryInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutOsEntryPreinstalledNestedInput
  }

  export type OsEntryPreinstalledUncheckedUpdateWithoutOsEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type OsEntryReleaseNoteUpdateWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryReleaseNoteUncheckedUpdateWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySafariVersionUpdateWithoutOsEntryInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySafariVersionUncheckedUpdateWithoutOsEntryInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type OsEntrySecurityNoteUpdateWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySecurityNoteUncheckedUpdateWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceEntryUpdateWithoutOsEntryInput = {
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateWithoutOsEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
    SourceHash?: SourceHashUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceLink?: SourceLinkUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourceMapDevice?: SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryNestedInput
    SourcePrequisiteBuild?: SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryNestedInput
  }

  export type SourceEntryUncheckedUpdateManyWithoutOsEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    source_type?: NullableStringFieldUpdateOperationsInput | string | null
    skip_update_links?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    windows_update_id?: NullableStringFieldUpdateOperationsInput | string | null
    windows_revision_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OsEntryCreateManyOsLookupNameInput = {
    id?: number
    version: string
    build?: string | null
    release_datetime?: Date | string | null
    release_datetime_depth?: number | null
    is_release?: boolean | null
    is_beta?: boolean | null
    is_rc?: boolean | null
    is_internal?: boolean | null
    is_rsr?: boolean | null
    is_sdk?: boolean | null
    is_simulator?: boolean | null
    image_id?: string | null
    embedded_os_build?: string | null
    bridge_os_build?: string | null
    notes?: string | null
    legacy_unique_key?: string | null
    search?: string | null
  }

  export type OsEntryUpdateWithoutOsLookupNameInput = {
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateWithoutOsLookupNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
    MapDeviceOs?: MapDeviceOsUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryBuildTrain?: OsEntryBuildTrainUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryIpd?: OsEntryIpdUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryOsStringMap?: OsEntryOsStringMapUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryPreinstalled?: OsEntryPreinstalledUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntryReleaseNote?: OsEntryReleaseNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySafariVersion?: OsEntrySafariVersionUncheckedUpdateManyWithoutOsEntryNestedInput
    OsEntrySecurityNote?: OsEntrySecurityNoteUncheckedUpdateManyWithoutOsEntryNestedInput
    SourceEntry?: SourceEntryUncheckedUpdateManyWithoutOsEntryNestedInput
  }

  export type OsEntryUncheckedUpdateManyWithoutOsLookupNameInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    build?: NullableStringFieldUpdateOperationsInput | string | null
    release_datetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    release_datetime_depth?: NullableIntFieldUpdateOperationsInput | number | null
    is_release?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_beta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rc?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_internal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_rsr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_sdk?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_simulator?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_id?: NullableStringFieldUpdateOperationsInput | string | null
    embedded_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    bridge_os_build?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    legacy_unique_key?: NullableStringFieldUpdateOperationsInput | string | null
    search?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashCreateManySourceEntryInput = {
    hash_type: string
    hash_value?: string | null
  }

  export type SourceLinkCreateManySourceEntryInput = {
    url: string
    active?: boolean | null
  }

  export type SourceMapDeviceCreateManySourceEntryInput = {
    device_id: number
  }

  export type SourcePrequisiteBuildCreateManySourceEntryInput = {
    build: string
  }

  export type SourceHashUpdateWithoutSourceEntryInput = {
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashUncheckedUpdateWithoutSourceEntryInput = {
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceHashUncheckedUpdateManyWithoutSourceEntryInput = {
    hash_type?: StringFieldUpdateOperationsInput | string
    hash_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceLinkUpdateWithoutSourceEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceLinkUncheckedUpdateWithoutSourceEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceLinkUncheckedUpdateManyWithoutSourceEntryInput = {
    url?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SourceMapDeviceUpdateWithoutSourceEntryInput = {
    DeviceEntry?: DeviceEntryUpdateOneRequiredWithoutSourceMapDeviceNestedInput
  }

  export type SourceMapDeviceUncheckedUpdateWithoutSourceEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourceMapDeviceUncheckedUpdateManyWithoutSourceEntryInput = {
    device_id?: IntFieldUpdateOperationsInput | number
  }

  export type SourcePrequisiteBuildUpdateWithoutSourceEntryInput = {
    build?: StringFieldUpdateOperationsInput | string
  }

  export type SourcePrequisiteBuildUncheckedUpdateWithoutSourceEntryInput = {
    build?: StringFieldUpdateOperationsInput | string
  }

  export type SourcePrequisiteBuildUncheckedUpdateManyWithoutSourceEntryInput = {
    build?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}